{"meta":{"title":"voiue","subtitle":"","description":"","author":"voiue","url":"https://voiue.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-03-08T11:01:57.380Z","updated":"2020-03-08T11:01:57.323Z","comments":true,"path":"404.html","permalink":"https://voiue.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-03-07T15:34:31.277Z","updated":"2020-03-07T15:34:31.164Z","comments":true,"path":"about/index.html","permalink":"https://voiue.github.io/about/index.html","excerpt":"","text":"山重水复疑无路 柳暗花明又一村 一个FPGA爱好者，喜欢折腾 e-mailvoiue@foxmail.com QQ2512316656"},{"title":"blog","date":"2020-03-07T11:43:11.000Z","updated":"2020-03-07T11:43:12.161Z","comments":true,"path":"blog/index.html","permalink":"https://voiue.github.io/blog/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-03-08T12:59:22.363Z","updated":"2020-03-08T12:59:22.263Z","comments":true,"path":"friends/index.html","permalink":"https://voiue.github.io/friends/index.html","excerpt":"友链","text":"友链"},{"title":"","date":"2020-03-10T08:38:20.277Z","updated":"2020-03-10T08:38:20.170Z","comments":true,"path":"js/snow.js","permalink":"https://voiue.github.io/js/snow.js","excerpt":"","text":"/*样式一*/ (function($){ $.fn.snow = function(options){ var $flake = $('').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('&#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = { minSize : 10, maxSize : 20, newOn : 1000, flakeColor : \"#AFDAEF\" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ }, options = $.extend({}, defaults, options); var interval= setInterval( function(){ var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css({ left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor }).animate({ top: endPositionTop, left: endPositionLeft, opacity: 0.2 },durationFall,'linear',function(){ $(this).remove() }); }, options.newOn); }; })(jQuery); $(function(){ $.fn.snow({ minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ }); });"},{"title":"","date":"2020-03-11T10:02:18.065Z","updated":"2020-03-11T10:02:18.020Z","comments":true,"path":"music/index.html","permalink":"https://voiue.github.io/music/index.html","excerpt":"","text":"Azusa | voiue body{ margin:0; background:#000 } #app{ position:absolute; top:0; left:0 } #bg{ position:absolute; width:100%; height:100%; left:0; top:0; z-index:1; mix-blend-mode:screen; background-repeat:no-repeat; background-position:50% 50%; background-size:cover; background-origin:padding-box; background-attachment:scroll; box-shadow:0 0 1000px #000 inset } < script async = \"\" > ! function() { var t = document.createElement(\"script\"); t.onload = function() { var e = new Stats; document.body.appendChild(e.dom), requestAnimationFrame(function t() { e.update(), requestAnimationFrame(t) }) }, t.src = \"//rawgit.com/mrdoob/stats.js/master/build/stats.min.js\", document.head.appendChild(t) }() < /script>"},{"title":"","date":"2020-03-11T07:49:19.488Z","updated":"2020-03-11T07:49:19.488Z","comments":true,"path":"music/example.d6feebd9.js","permalink":"https://voiue.github.io/music/example.d6feebd9.js","excerpt":"","text":"! function(e) { var t = {}; function r(i) { if (t[i]) return t[i].exports; var n = t[i] = { i: i, l: !1, exports: {} }; return e[i].call(n.exports, n, n.exports, r), n.l = !0, n.exports } r.m = e, r.c = t, r.d = function(e, t, i) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }) }, r.r = function(e) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 }) }, r.t = function(e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && \"object\" == typeof e && e && e.__esModule) return e; var i = Object.create(null); if (r.r(i), Object.defineProperty(i, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var n in e) r.d(i, n, function(t) { return e[t] }.bind(null, n)); return i }, r.n = function(e) { var t = e && e.__esModule ? function() { return e. default } : function() { return e }; return r.d(t, \"a\", t), t }, r.o = function(e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, r.p = \"\", r(r.s = 4) }([function(e, t) { e.exports = THREE }, function(e, t, r) { \"use strict\"; var i, n = \"object\" == typeof Reflect ? Reflect : null, o = n && \"function\" == typeof n.apply ? n.apply : function(e, t, r) { return Function.prototype.apply.call(e, t, r) }; i = n && \"function\" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : function(e) { return Object.getOwnPropertyNames(e) }; var s = Number.isNaN || function(e) { return e != e }; function a() { a.init.call(this) } e.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0; var l = 10; function h(e) { return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners } function u(e, t, r, i) { var n, o, s, a; if (\"function\" != typeof r) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof r); if (void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit(\"newListener\", t, r.listener ? r.listener : r), o = e._events), s = o[t]), void 0 === s) s = o[t] = r, ++e._eventsCount; else if (\"function\" == typeof s ? s = o[t] = i ? [r, s] : [s, r] : i ? s.unshift(r) : s.push(r), (n = h(e)) > 0 && s.length > n && !s.warned) { s.warned = !0; var l = new Error(\"Possible EventEmitter memory leak detected. \" + s.length + \" \" + String(t) + \" listeners added. Use emitter.setMaxListeners() to increase limit\"); l.name = \"MaxListenersExceededWarning\", l.emitter = e, l.type = t, l.count = s.length, a = l, console && console.warn && console.warn(a) } return e } function c(e, t, r) { var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, n = function() { for (var e = [], t = 0; t < arguments.length; t++) e.push(arguments[t]); this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, o(this.listener, this.target, e)) }.bind(i); return n.listener = r, i.wrapFn = n, n } function d(e, t, r) { var i = e._events; if (void 0 === i) return []; var n = i[t]; return void 0 === n ? [] : \"function\" == typeof n ? r ? [n.listener || n] : [n] : r ? function(e) { for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r]; return t }(n) : p(n, n.length) } function f(e) { var t = this._events; if (void 0 !== t) { var r = t[e]; if (\"function\" == typeof r) return 1; if (void 0 !== r) return r.length } return 0 } function p(e, t) { for (var r = new Array(t), i = 0; i < t; ++i) r[i] = e[i]; return r } Object.defineProperty(a, \"defaultMaxListeners\", { enumerable: !0, get: function() { return l }, set: function(e) { if (\"number\" != typeof e || e < 0 || s(e)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + e + \".\"); l = e } }), a.init = function() { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, a.prototype.setMaxListeners = function(e) { if (\"number\" != typeof e || e < 0 || s(e)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\"); return this._maxListeners = e, this }, a.prototype.getMaxListeners = function() { return h(this) }, a.prototype.emit = function(e) { for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]); var i = \"error\" === e, n = this._events; if (void 0 !== n) i = i && void 0 === n.error; else if (!i) return !1; if (i) { var s; if (t.length > 0 && (s = t[0]), s instanceof Error) throw s; var a = new Error(\"Unhandled error.\" + (s ? \" (\" + s.message + \")\" : \"\")); throw a.context = s, a } var l = n[e]; if (void 0 === l) return !1; if (\"function\" == typeof l) o(l, this, t); else { var h = l.length, u = p(l, h); for (r = 0; r < h; ++r) o(u[r], this, t) } return !0 }, a.prototype.addListener = function(e, t) { return u(this, e, t, !1) }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t) { return u(this, e, t, !0) }, a.prototype.once = function(e, t) { if (\"function\" != typeof t) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof t); return this.on(e, c(this, e, t)), this }, a.prototype.prependOnceListener = function(e, t) { if (\"function\" != typeof t) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof t); return this.prependListener(e, c(this, e, t)), this }, a.prototype.removeListener = function(e, t) { var r, i, n, o, s; if (\"function\" != typeof t) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof t); if (void 0 === (i = this._events)) return this; if (void 0 === (r = i[e])) return this; if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit(\"removeListener\", e, r.listener || t)); else if (\"function\" != typeof r) { for (n = -1, o = r.length - 1; o >= 0; o--) if (r[o] === t || r[o].listener === t) { s = r[o].listener, n = o; break } if (n < 0) return this; 0 === n ? r.shift() : function(e, t) { for (; t + 1 < e.length; t++) e[t] = e[t + 1]; e.pop() }(r, n), 1 === r.length && (i[e] = r[0]), void 0 !== i.removeListener && this.emit(\"removeListener\", e, s || t) } return this }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(e) { var t, r, i; if (void 0 === (r = this._events)) return this; if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this; if (0 === arguments.length) { var n, o = Object.keys(r); for (i = 0; i < o.length; ++i)\"removeListener\" !== (n = o[i]) && this.removeAllListeners(n); return this.removeAllListeners(\"removeListener\"), this._events = Object.create(null), this._eventsCount = 0, this } if (\"function\" == typeof(t = r[e])) this.removeListener(e, t); else if (void 0 !== t) for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]); return this }, a.prototype.listeners = function(e) { return d(this, e, !0) }, a.prototype.rawListeners = function(e) { return d(this, e, !1) }, a.listenerCount = function(e, t) { return \"function\" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t) }, a.prototype.listenerCount = f, a.prototype.eventNames = function() { return this._eventsCount > 0 ? i(this._events) : [] } }, function(e, t, r) { e.exports = r.p + \"https://cdn.jsdelivr.net/gh/voiue/cdn-assets@master/music/s.mp3\" }, function(e, t, r) { e.exports = r.p + \"https://cdn.jsdelivr.net/gh/voiue/cdn-assets@master/photo/C6C2AE-42D274-14D0CB.jpg\" }, function(e, t, r) { e.exports = r(11) }, function(e, t) { THREE.LuminosityHighPassShader = { shaderID: \"luminosityHighPass\", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new THREE.Color(0) }, defaultOpacity: { value: 0 } }, vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"), fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\") } }, function(e, t) { THREE.CopyShader = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"), fragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\") } }, function(e, t) { var r, i, n; THREE.EffectComposer = function(e, t) { if (this.renderer = e, void 0 === t) { var r = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: !1 }, i = e.getSize(new THREE.Vector2); this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, (t = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, r)).texture.name = \"EffectComposer.rt1\" } else this._pixelRatio = 1, this._width = t.width, this._height = t.height; this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = \"EffectComposer.rt2\", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === THREE.CopyShader && console.error(\"THREE.EffectComposer relies on THREE.CopyShader\"), void 0 === THREE.ShaderPass && console.error(\"THREE.EffectComposer relies on THREE.ShaderPass\"), this.copyPass = new THREE.ShaderPass(THREE.CopyShader), this.clock = new THREE.Clock }, Object.assign(THREE.EffectComposer.prototype, { swapBuffers: function() { var e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e }, addPass: function(e) { this.passes.push(e); var t = this.renderer.getDrawingBufferSize(new THREE.Vector2); e.setSize(t.width, t.height) }, insertPass: function(e, t) { this.passes.splice(t, 0, e) }, isLastEnabledPass: function(e) { for (var t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return !1; return !0 }, render: function(e) { void 0 === e && (e = this.clock.getDelta()); var t, r, i = this.renderer.getRenderTarget(), n = !1, o = this.passes.length; for (r = 0; r < o; r++) if (!1 !== (t = this.passes[r]).enabled) { if (t.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), t.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), t.needsSwap) { if (n) { var s = this.renderer.context; s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), s.stencilFunc(s.EQUAL, 1, 4294967295) } this.swapBuffers() } void 0 !== THREE.MaskPass && (t instanceof THREE.MaskPass ? n = !0 : t instanceof THREE.ClearMaskPass && (n = !1)) } this.renderer.setRenderTarget(i) }, reset: function(e) { if (void 0 === e) { var t = this.renderer.getSize(new THREE.Vector2); this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 }, setSize: function(e, t) { this._width = e, this._height = t; var r = this._width * this._pixelRatio, i = this._height * this._pixelRatio; this.renderTarget1.setSize(r, i), this.renderTarget2.setSize(r, i); for (var n = 0; n < this.passes.length; n++) this.passes[n].setSize(r, i) }, setPixelRatio: function(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } }), THREE.Pass = function() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 }, Object.assign(THREE.Pass.prototype, { setSize: function() {}, render: function() { console.error(\"THREE.Pass: .render() must be implemented in derived pass.\") } }), THREE.Pass.FullScreenQuad = (r = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), i = new THREE.PlaneBufferGeometry(2, 2), n = function(e) { this._mesh = new THREE.Mesh(i, e) }, Object.defineProperty(n.prototype, \"material\", { get: function() { return this._mesh.material }, set: function(e) { this._mesh.material = e } }), Object.assign(n.prototype, { render: function(e) { e.render(this._mesh, r) } }), n) }, function(e, t) { THREE.RenderPass = function(e, t, r, i, n) { THREE.Pass.call(this), this.scene = e, this.camera = t, this.overrideMaterial = r, this.clearColor = i, this.clearAlpha = void 0 !== n ? n : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1 }, THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), { constructor: THREE.RenderPass, render: function(e, t, r) { var i, n, o = e.autoClear; e.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (i = e.getClearColor().getHex(), n = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : r), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(i, n), this.scene.overrideMaterial = null, e.autoClear = o } }) }, function(e, t) { THREE.ShaderPass = function(e, t) { THREE.Pass.call(this), this.textureID = void 0 !== t ? t : \"tDiffuse\", e instanceof THREE.ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new THREE.Pass.FullScreenQuad(this.material) }, THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), { constructor: THREE.ShaderPass, render: function(e, t, r) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e)) } }) }, function(e, t) { THREE.UnrealBloomPass = function(e, t, r, i) { THREE.Pass.call(this), this.strength = void 0 !== t ? t : 1, this.radius = r, this.threshold = i, this.resolution = void 0 !== e ? new THREE.Vector2(e.x, e.y) : new THREE.Vector2(256, 256), this.clearColor = new THREE.Color(0, 0, 0); var n = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; var o = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2); this.renderTargetBright = new THREE.WebGLRenderTarget(o, s, n), this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\", this.renderTargetBright.texture.generateMipmaps = !1; for (var a = 0; a < this.nMips; a++) { var l = new THREE.WebGLRenderTarget(o, s, n); l.texture.name = \"UnrealBloomPass.h\" + a, l.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(l); var h = new THREE.WebGLRenderTarget(o, s, n); h.texture.name = \"UnrealBloomPass.v\" + a, h.texture.generateMipmaps = !1, this.renderTargetsVertical.push(h), o = Math.round(o / 2), s = Math.round(s / 2) } void 0 === THREE.LuminosityHighPassShader && console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\"); var u = THREE.LuminosityHighPassShader; this.highPassUniforms = THREE.UniformsUtils.clone(u.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new THREE.ShaderMaterial({ uniforms: this.highPassUniforms, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, defines: {} }), this.separableBlurMaterials = []; var c = [3, 5, 7, 9, 11]; for (o = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2), a = 0; a < this.nMips; a++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[a])), this.separableBlurMaterials[a].uniforms.texSize.value = new THREE.Vector2(o, s), o = Math.round(o / 2), s = Math.round(s / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0; this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === THREE.CopyShader && console.error(\"THREE.UnrealBloomPass relies on THREE.CopyShader\"); var d = THREE.CopyShader; this.copyUniforms = THREE.UniformsUtils.clone(d.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader, blending: THREE.AdditiveBlending, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.basic = new THREE.MeshBasicMaterial, this.fsQuad = new THREE.Pass.FullScreenQuad(null) }, THREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), { constructor: THREE.UnrealBloomPass, dispose: function() { for (var e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose(); for (e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose(); this.renderTargetBright.dispose() }, setSize: function(e, t) { var r = Math.round(e / 2), i = Math.round(t / 2); this.renderTargetBright.setSize(r, i); for (var n = 0; n < this.nMips; n++) this.renderTargetsHorizontal[n].setSize(r, i), this.renderTargetsVertical[n].setSize(r, i), this.separableBlurMaterials[n].uniforms.texSize.value = new THREE.Vector2(r, i), r = Math.round(r / 2), i = Math.round(i / 2) }, render: function(e, t, r, i, n) { this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha(); var o = e.autoClear; e.autoClear = !1, e.setClearColor(this.clearColor, 0), n && e.context.disable(e.context.STENCIL_TEST), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = r.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = r.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e); for (var s = this.renderTargetBright, a = 0; a < this.nMips; a++) this.fsQuad.material = this.separableBlurMaterials[a], this.separableBlurMaterials[a].uniforms.colorTexture.value = s.texture, this.separableBlurMaterials[a].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[a]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[a].uniforms.colorTexture.value = this.renderTargetsHorizontal[a].texture, this.separableBlurMaterials[a].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[a]), e.clear(), this.fsQuad.render(e), s = this.renderTargetsVertical[a]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, n && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(r), this.fsQuad.render(e)), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = o }, getSeperableBlurMaterial: function(e) { return new THREE.ShaderMaterial({ defines: { KERNEL_RADIUS: e, SIGMA: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, direction: { value: new THREE.Vector2(.5, .5) } }, vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\", fragmentShader: \"#include \\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tfloat fSigma = float(SIGMA);\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, fSigma);\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat x = float(i);\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(x, fSigma);\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}\" }) }, getCompositeMaterial: function(e) { return new THREE.ShaderMaterial({ defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\", fragmentShader: \"varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D blurTexture1;\\t\\t\\t\\tuniform sampler2D blurTexture2;\\t\\t\\t\\tuniform sampler2D blurTexture3;\\t\\t\\t\\tuniform sampler2D blurTexture4;\\t\\t\\t\\tuniform sampler2D blurTexture5;\\t\\t\\t\\tuniform sampler2D dirtTexture;\\t\\t\\t\\tuniform float bloomStrength;\\t\\t\\t\\tuniform float bloomRadius;\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\t\\t\\t\\t\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) { \\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\t\\t\\t\\t}\" }) } }), THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1, 0), THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0, 1) }, function(e, t, r) { \"use strict\"; function i(e, t) { return e + (Math.random() - .5) * t } r.r(t); var n = r(0), o = function() { function e(e, t, r, o, s, a, l, h, u) { var c, d; this.rotate = 360 * Math.random(), this.id = Math.random(), this.panelOpacity = .1, this.rotateSpeed = s, this.angle = r, this.speed = o, this.center = t, this.onDelete = u, this.distance = h.startShow, this.showDistance = h, this.panelMaterial = (new n.MeshBasicMaterial).copy(a), this.panelMaterial.transparent = !0, this.lineMaterial = (new n.LineBasicMaterial).copy(l), this.lineMaterial.transparent = !0; var f = new n.Geometry, p = new n.Geometry, m = [new n.Vector3(i(e, e / 2), i(e, e / 2), 0), new n.Vector3(-1 * i(e, e / 2), i(e, e / 2), 0), new n.Vector3(-1 * i(e, e / 2), -1 * i(e, e / 2), 0)]; (c = f.vertices).push.apply(c, m), (d = p.vertices).push.apply(d, m.concat([m[0]])), f.faces.push(new n.Face3(0, 1, 2)), f.computeFaceNormals(), f.computeVertexNormals(), this.line = new n.Line(p, this.lineMaterial), this.mesh = new n.Mesh(f, this.panelMaterial), this.group = new n.Group, this.translateOnAxis(this.translate(this.distance), 1), this.group.add(this.line), this.group.add(this.mesh), this.rotateZ(this.rotate), this.updatePosition(0) } return e.prototype.rotateZ = function(e) { this.mesh.geometry.rotateZ(e), this.line.geometry.rotateZ(e) }, e.prototype.translate = function(e) { var t = Math.cos(this.angle * Math.PI / 180) * e, r = Math.sin(this.angle * Math.PI / 180) * e; return new n.Vector3(t, r, 0) }, e.prototype.translateOnAxis = function(e, t) { this.group.translateOnAxis(e, t) }, e.prototype.updatePosition = function(e) { this.translateOnAxis(this.translate(e * this.speed), 1), this.distance += e * this.speed, this.rotateZ(this.rotateSpeed * e), this.panelMaterial.opacity = this.opacity(this.distance, this.showDistance) * this.panelOpacity, this.lineMaterial.opacity = this.opacity(this.distance, this.showDistance), this.distance > this.showDistance.endHide && this.delete() }, e.prototype.delete = function() { this.onDelete(this), this.mesh.geometry.dispose(), this.line.geometry.dispose() }, e.prototype.opacity = function(e, t) { return this.distance < t.endShow ? (this.distance - t.startShow) / (t.endShow - t.startShow) : this.distance > t.startHide ? (t.endHide - this.distance) / (t.endHide - t.startHide) : 1 }, e.prototype.transition = function(e) { this.updatePosition(e) }, e }(); function s(e, t, r, i) { void 0 === r && (r = 1), void 0 === i && (i = !1); for (var n = -1, o = Math.max(Math.ceil((t - e) / r), 0), s = Array(o); o--;) s[i ? o : ++n] = e, e += r; return s } var a, l = function() { function e(e, t, r) { this.lastStrength = 0, this.theStrength = 0, this.targetRange = 0, this._range = 0, this.baseRange = e, this.angle = t, this.center = r } return Object.defineProperty(e.prototype, \"positionA\", { get: function() { var e = this._range + this.baseRange, t = Math.cos(this.angle * Math.PI / 180) * e, r = Math.sin(this.angle * Math.PI / 180) * e; return new n.Vector2(this.center.x + t, this.center.y + r) }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"positionB\", { get: function() { var e = -1 * this._range + this.baseRange, t = Math.cos(this.angle * Math.PI / 180) * e, r = Math.sin(this.angle * Math.PI / 180) * e; return new n.Vector2(this.center.x + t, this.center.y + r) }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"strength\", { set: function(e) { this.lastStrength = this.theStrength, this.theStrength = e, this.targetRange = Math.max(this.theStrength - this.lastStrength, 0), this.targetRange > this._range && (this._range = this.targetRange) }, enumerable: !0, configurable: !0 }), e.prototype.transition = function(e) { this._range = Math.max(this._range - e * this._range * 5, 0) }, e }(), h = r(1), u = (a = function(e, t) { return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, t) { e.__proto__ = t } || function(e, t) { for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]) })(e, t) }, function(e, t) { function r() { this.constructor = e } a(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), c = function(e) { function t(t) { void 0 === t && (t = {}); var r = e.call(this) || this; return r.listener = new n.AudioListener, r.sound = new n.Audio(r.listener), r.audioLoader = new n.AudioLoader, r.analyser = new n.AudioAnalyser(r.sound, t.fftsize || 256), r.frequencyBinCount = r.analyser.analyser.frequencyBinCount, r } return u(t, e), t.prototype.load = function(e) { var t = this, r = e.src, i = e.onLoad, n = void 0 === i ? function(e) {} : i, o = e.onPrgress, s = void 0 === o ? function(e) {} : o, a = e.onError, l = void 0 === a ? function() {} : a; this.audioLoader.load(r, function(e) { return t.sound.setBuffer(e), t.sound.setLoop(!0), t.sound.play(), n(e) }, s, l) }, t.prototype.setVolume = function(e) { this.sound.setVolume(e) }, t.prototype.getFrequencyData = function() { return this.analyser.getFrequencyData() }, t }(h.EventEmitter), d = Object.assign(n, {}), f = (r(5), r(6), r(7), r(8), r(9), r(10), function() { function e(e) { var t = this; void 0 === e && (e = {}), this.scale = 1, this.Triangles = []; var r = e.width, i = void 0 === r ? window.innerWidth : r, n = e.height, o = void 0 === n ? window.innerHeight : n, a = e.subdivisionSize, h = void 0 === a ? 1024 : a, u = e.cutFront, f = void 0 === u ? 0 : u, p = e.cutEnd, m = void 0 === p ? 0 : p; this.cutFront = f, this.cutEnd = m; var v = new d.WebGLRenderer({ canvas: e.view, alpha: !0, antialias: !0 }); v.setSize(i, o); var g = new d.PerspectiveCamera(45, i / o, 1, 500); g.position.set(0, 0, 100), g.lookAt(new d.Vector3(0, 0, 0)); var T = new d.Scene; this.composer = new d.EffectComposer(v), this.composer.setSize(i, o); var E = new d.RenderPass(T, g); this.composer.addPass(E), this.bloomPass = new d.UnrealBloomPass(new d.Vector2(window.innerWidth, window.innerHeight), 1.5, .2, 0), this.composer.addPass(this.bloomPass); var y = new d.ShaderPass(d.CopyShader); y.renderToScreen = !0, this.composer.addPass(y), this.scene = T, this.camera = g, this.audio = new c({ fftsize: h }); var w = this.loadAudio(h).frequencyBinCount, b = new d.LineBasicMaterial({ color: 240116 }), x = w - m - f; this.nodes = s(0, x).map(function(e) { return new l(20, (e / x * 360 + 45) % 360, new d.Vector2(0, 0)) }), this.lineA = new d.Line((new d.BufferGeometry).addAttribute(\"position\", this.renderGeometries(this.nodes.map(function(e) { return e.positionA })).setDynamic(!0)), b), this.lineB = new d.Line((new d.BufferGeometry).addAttribute(\"position\", this.renderGeometries(this.nodes.map(function(e) { return e.positionB })).setDynamic(!0)), b), this.lines = s(0, x).map(function(e) { return new d.Line((new d.BufferGeometry).addAttribute(\"position\", t.renderGeometries([t.nodes[e].positionA, t.nodes[e].positionB]).setDynamic(!0)), b) }), this.lineGroup = this.loadLine(), this.TriangleGroup = this.loadTriangle(), this.scene.add(this.TriangleGroup), this.scene.add(this.lineGroup), this.renderer = v, this.clock = new d.Clock, this.render(), this.resize(i, o) } return e.prototype.loadGui = function() { var e = this, t = { projection: \"normal\", background: !1, exposure: 1, bloomStrength: 1.5, bloomThreshold: .2, bloomRadius: 0 }, r = new window.dat.GUI; r.add(t, \"exposure\", .1, 2), r.add(t, \"bloomThreshold\", 0, 1).onChange(function(t) { e.bloomPass.threshold = Number(t) }), r.add(t, \"bloomStrength\", 0, 3).onChange(function(t) { e.bloomPass.strength = Number(t) }), r.add(t, \"bloomRadius\", 0, 1).onChange(function(t) { e.bloomPass.radius = Number(t) }), r.open() }, e.prototype.resize = function(e, t) { this.camera.aspect = e / t, this.camera.fov = e"},{"title":"wiki","date":"2020-03-07T11:40:59.000Z","updated":"2020-03-07T11:40:59.697Z","comments":true,"path":"wiki/index.html","permalink":"https://voiue.github.io/wiki/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-10T15:04:55.000Z","updated":"2020-03-10T15:04:55.000Z","comments":true,"path":"music/azusa.js","permalink":"https://voiue.github.io/music/azusa.js","excerpt":"","text":"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"THREE\")); else if(typeof define === 'function' && define.amd) define([\"THREE\"], factory); else { var a = typeof exports === 'object' ? factory(require(\"THREE\")) : factory(root[\"THREE\"]); for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i]; } })(window, function(__WEBPACK_EXTERNAL_MODULE__0__) { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter }); /******/ } /******/ }; /******/ /******/ // define __esModule on exports /******/ __webpack_require__.r = function(exports) { /******/ if(typeof Symbol !== 'undefined' && Symbol.toStringTag) { /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }); /******/ } /******/ Object.defineProperty(exports, '__esModule', { value: true }); /******/ }; /******/ /******/ // create a fake namespace object /******/ // mode & 1: value is a module id, require it /******/ // mode & 2: merge all properties of value into the ns /******/ // mode & 4: return value when already ns object /******/ // mode & 8|1: behave like require /******/ __webpack_require__.t = function(value, mode) { /******/ if(mode & 1) value = __webpack_require__(value); /******/ if(mode & 8) return value; /******/ if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value; /******/ var ns = Object.create(null); /******/ __webpack_require__.r(ns); /******/ Object.defineProperty(ns, 'default', { enumerable: true, value: value }); /******/ if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key)); /******/ return ns; /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) { /******/ var getter = module && module.__esModule ? /******/ function getDefault() { return module['default']; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, 'a', getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = 48); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports) { module.exports = __WEBPACK_EXTERNAL_MODULE__0__; /***/ }), /* 1 */ /***/ (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(8); var createDesc = __webpack_require__(19); module.exports = __webpack_require__(4) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 3 */ /***/ (function(module, exports, __webpack_require__) { var store = __webpack_require__(15)('wks'); var uid = __webpack_require__(7); var Symbol = __webpack_require__(1).Symbol; var USE_SYMBOL = typeof Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(17)(function () { return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 5 */ /***/ (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 6 */ /***/ (function(module, exports) { var core = module.exports = { version: '2.5.7' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 7 */ /***/ (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 8 */ /***/ (function(module, exports, __webpack_require__) { var anObject = __webpack_require__(9); var IE8_DOM_DEFINE = __webpack_require__(29); var toPrimitive = __webpack_require__(30); var dP = Object.defineProperty; exports.f = __webpack_require__(4) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { /* empty */ } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(10); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 10 */ /***/ (function(module, exports) { module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 11 */ /***/ (function(module, exports) { module.exports = {}; /***/ }), /* 12 */ /***/ (function(module, exports, __webpack_require__) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(32); var defined = __webpack_require__(20); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(1); var hide = __webpack_require__(2); var has = __webpack_require__(5); var SRC = __webpack_require__(7)('src'); var TO_STRING = 'toString'; var $toString = Function[TO_STRING]; var TPL = ('' + $toString).split(TO_STRING); __webpack_require__(6).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == 'function'; if (isFunction) has(val, 'name') || hide(val, 'name', key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == 'function' && this[SRC] || $toString.call(this); }); /***/ }), /* 14 */ /***/ (function(module, exports, __webpack_require__) { var shared = __webpack_require__(15)('keys'); var uid = __webpack_require__(7); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); }; /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { var core = __webpack_require__(6); var global = __webpack_require__(1); var SHARED = '__core-js_shared__'; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: core.version, mode: __webpack_require__(16) ? 'pure' : 'global', copyright: '© 2018 Denis Pushkarev (zloirock.ru)' }); /***/ }), /* 16 */ /***/ (function(module, exports) { module.exports = false; /***/ }), /* 17 */ /***/ (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(10); var document = __webpack_require__(1).document; // typeof document.createElement is 'object' in old IE var is = isObject(document) && isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; }; /***/ }), /* 19 */ /***/ (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 20 */ /***/ (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError(\"Can't call method on \" + it); return it; }; /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(41); var enumBugKeys = __webpack_require__(23); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 22 */ /***/ (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it); }; /***/ }), /* 23 */ /***/ (function(module, exports) { // IE 8- don't enum bug keys module.exports = ( 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf' ).split(','); /***/ }), /* 24 */ /***/ (function(module, exports, __webpack_require__) { var def = __webpack_require__(8).f; var has = __webpack_require__(5); var TAG = __webpack_require__(3)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 25 */ /***/ (function(module, exports) { // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // \"Software\"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. function EventEmitter() { this._events = this._events || {}; this._maxListeners = this._maxListeners || undefined; } module.exports = EventEmitter; // Backwards-compat with node 0.10.x EventEmitter.EventEmitter = EventEmitter; EventEmitter.prototype._events = undefined; EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are // added to it. This is a useful default which helps finding memory leaks. EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows // that to be increased. Set to zero for unlimited. EventEmitter.prototype.setMaxListeners = function(n) { if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number'); this._maxListeners = n; return this; }; EventEmitter.prototype.emit = function(type) { var er, handler, len, args, i, listeners; if (!this._events) this._events = {}; // If there is no 'error' event listener then throw. if (type === 'error') { if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) { er = arguments[1]; if (er instanceof Error) { throw er; // Unhandled 'error' event } else { // At least give some kind of context to the user var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')'); err.context = er; throw err; } } } handler = this._events[type]; if (isUndefined(handler)) return false; if (isFunction(handler)) { switch (arguments.length) { // fast cases case 1: handler.call(this); break; case 2: handler.call(this, arguments[1]); break; case 3: handler.call(this, arguments[1], arguments[2]); break; // slower default: args = Array.prototype.slice.call(arguments, 1); handler.apply(this, args); } } else if (isObject(handler)) { args = Array.prototype.slice.call(arguments, 1); listeners = handler.slice(); len = listeners.length; for (i = 0; i < len; i++) listeners[i].apply(this, args); } return true; }; EventEmitter.prototype.addListener = function(type, listener) { var m; if (!isFunction(listener)) throw TypeError('listener must be a function'); if (!this._events) this._events = {}; // To avoid recursion in the case that type === \"newListener\"! Before // adding it to the listeners, first emit \"newListener\". if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener); if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object. this._events[type] = listener; else if (isObject(this._events[type])) // If we've already got an array, just append. this._events[type].push(listener); else // Adding the second element, need to change to array. this._events[type] = [this._events[type], listener]; // Check for listener leak if (isObject(this._events[type]) && !this._events[type].warned) { if (!isUndefined(this._maxListeners)) { m = this._maxListeners; } else { m = EventEmitter.defaultMaxListeners; } if (m && m > 0 && this._events[type].length > m) { this._events[type].warned = true; console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length); if (typeof console.trace === 'function') { // not supported in IE 10 console.trace(); } } } return this; }; EventEmitter.prototype.on = EventEmitter.prototype.addListener; EventEmitter.prototype.once = function(type, listener) { if (!isFunction(listener)) throw TypeError('listener must be a function'); var fired = false; function g() { this.removeListener(type, g); if (!fired) { fired = true; listener.apply(this, arguments); } } g.listener = listener; this.on(type, g); return this; }; // emits a 'removeListener' event iff the listener was removed EventEmitter.prototype.removeListener = function(type, listener) { var list, position, length, i; if (!isFunction(listener)) throw TypeError('listener must be a function'); if (!this._events || !this._events[type]) return this; list = this._events[type]; length = list.length; position = -1; if (list === listener || (isFunction(list.listener) && list.listener === listener)) { delete this._events[type]; if (this._events.removeListener) this.emit('removeListener', type, listener); } else if (isObject(list)) { for (i = length; i-- > 0;) { if (list[i] === listener || (list[i].listener && list[i].listener === listener)) { position = i; break; } } if (position < 0) return this; if (list.length === 1) { list.length = 0; delete this._events[type]; } else { list.splice(position, 1); } if (this._events.removeListener) this.emit('removeListener', type, listener); } return this; }; EventEmitter.prototype.removeAllListeners = function(type) { var key, listeners; if (!this._events) return this; // not listening for removeListener, no need to emit if (!this._events.removeListener) { if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type]; return this; } // emit removeListener for all listeners on all events if (arguments.length === 0) { for (key in this._events) { if (key === 'removeListener') continue; this.removeAllListeners(key); } this.removeAllListeners('removeListener'); this._events = {}; return this; } listeners = this._events[type]; if (isFunction(listeners)) { this.removeListener(type, listeners); } else if (listeners) { // LIFO order while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]); } delete this._events[type]; return this; }; EventEmitter.prototype.listeners = function(type) { var ret; if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [this._events[type]]; else ret = this._events[type].slice(); return ret; }; EventEmitter.prototype.listenerCount = function(type) { if (this._events) { var evlistener = this._events[type]; if (isFunction(evlistener)) return 1; else if (evlistener) return evlistener.length; } return 0; }; EventEmitter.listenerCount = function(emitter, type) { return emitter.listenerCount(type); }; function isFunction(arg) { return typeof arg === 'function'; } function isNumber(arg) { return typeof arg === 'number'; } function isObject(arg) { return typeof arg === 'object' && arg !== null; } function isUndefined(arg) { return arg === void 0; } /***/ }), /* 26 */ /***/ (function(module, exports, __webpack_require__) { var $iterators = __webpack_require__(27); var getKeys = __webpack_require__(21); var redefine = __webpack_require__(13); var global = __webpack_require__(1); var hide = __webpack_require__(2); var Iterators = __webpack_require__(11); var wks = __webpack_require__(3); var ITERATOR = wks('iterator'); var TO_STRING_TAG = wks('toStringTag'); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } } /***/ }), /* 27 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var addToUnscopables = __webpack_require__(28); var step = __webpack_require__(31); var Iterators = __webpack_require__(11); var toIObject = __webpack_require__(12); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype[@@iterator]() module.exports = __webpack_require__(34)(Array, 'Array', function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index >= O.length) { this._t = undefined; return step(1); } if (kind == 'keys') return step(0, index); if (kind == 'values') return step(0, O[index]); return step(0, [index, O[index]]); }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries'); /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = __webpack_require__(3)('unscopables'); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(2)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; }; /***/ }), /* 29 */ /***/ (function(module, exports, __webpack_require__) { module.exports = !__webpack_require__(4) && !__webpack_require__(17)(function () { return Object.defineProperty(__webpack_require__(18)('div'), 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = __webpack_require__(10); // instead of the ES6 spec version, we didn't implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val; if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; throw TypeError(\"Can't convert object to primitive value\"); }; /***/ }), /* 31 */ /***/ (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; }; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = __webpack_require__(33); // eslint-disable-next-line no-prototype-builtins module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == 'String' ? it.split('') : Object(it); }; /***/ }), /* 33 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var LIBRARY = __webpack_require__(16); var $export = __webpack_require__(35); var redefine = __webpack_require__(13); var hide = __webpack_require__(2); var Iterators = __webpack_require__(11); var $iterCreate = __webpack_require__(38); var setToStringTag = __webpack_require__(24); var getPrototypeOf = __webpack_require__(46); var ITERATOR = __webpack_require__(3)('iterator'); var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next` var FF_ITERATOR = '@@iterator'; var KEYS = 'keys'; var VALUES = 'values'; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY && kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ' Iterator'; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined; var $anyNative = NAME == 'Array' ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES && $native && $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods); } return methods; }; /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(1); var core = __webpack_require__(6); var hide = __webpack_require__(2); var redefine = __webpack_require__(13); var ctx = __webpack_require__(36); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { // optional / simple context binding var aFunction = __webpack_require__(37); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/* ...args */) { return fn.apply(that, arguments); }; }; /***/ }), /* 37 */ /***/ (function(module, exports) { module.exports = function (it) { if (typeof it != 'function') throw TypeError(it + ' is not a function!'); return it; }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var create = __webpack_require__(39); var descriptor = __webpack_require__(19); var setToStringTag = __webpack_require__(24); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]() __webpack_require__(2)(IteratorPrototype, __webpack_require__(3)('iterator'), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ' Iterator'); }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(9); var dPs = __webpack_require__(40); var enumBugKeys = __webpack_require__(23); var IE_PROTO = __webpack_require__(14)('IE_PROTO'); var Empty = function () { /* empty */ }; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(18)('iframe'); var i = enumBugKeys.length; var lt = ''; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(45).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(8); var anObject = __webpack_require__(9); var getKeys = __webpack_require__(21); module.exports = __webpack_require__(4) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length > i) dP.f(O, P = keys[i++], Properties[P]); return O; }; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { var has = __webpack_require__(5); var toIObject = __webpack_require__(12); var arrayIndexOf = __webpack_require__(42)(false); var IE_PROTO = __webpack_require__(14)('IE_PROTO'); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys while (names.length > i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; }; /***/ }), /* 42 */ /***/ (function(module, exports, __webpack_require__) { // false -> Array#indexOf // true -> Array#includes var toIObject = __webpack_require__(12); var toLength = __webpack_require__(43); var toAbsoluteIndex = __webpack_require__(44); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length > index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; /***/ }), /* 43 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.15 ToLength var toInteger = __webpack_require__(22); var min = Math.min; module.exports = function (it) { return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(22); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index < 0 ? max(index + length, 0) : min(index, length); }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { var document = __webpack_require__(1).document; module.exports = document && document.documentElement; /***/ }), /* 46 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = __webpack_require__(5); var toObject = __webpack_require__(47); var IE_PROTO = __webpack_require__(14)('IE_PROTO'); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; }; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.13 ToObject(argument) var defined = __webpack_require__(20); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 48 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js var web_dom_iterable = __webpack_require__(26); // CONCATENATED MODULE: ./src/util/randomRange.ts function randomRange(a,range){return a+(Math.random()-0.5)*range;} // EXTERNAL MODULE: external \"THREE\" var external_THREE_ = __webpack_require__(0); // CONCATENATED MODULE: ./src/Triangle.ts var Triangle_Triangle=/** @class */function(){function Triangle(size,center,angle,speed,rotateSpeed,material,lineMaterial,lineDistance,cb){var _a,_b;this.rotate=Math.random()*360;this.id=Math.random();this.panelOpacity=0.1;this.rotateSpeed=rotateSpeed;this.angle=angle;this.speed=speed;this.center=center;this.onDelete=cb;this.distance=lineDistance.startShow;this.showDistance=lineDistance;this.panelMaterial=new external_THREE_[\"MeshBasicMaterial\"]().copy(material);this.panelMaterial.transparent=true;this.lineMaterial=new external_THREE_[\"LineBasicMaterial\"]().copy(lineMaterial);this.lineMaterial.transparent=true;var panelGeometry=new external_THREE_[\"Geometry\"]();var lineGeometry=new external_THREE_[\"Geometry\"]();var vertices=[new external_THREE_[\"Vector3\"](randomRange(size,size/2),randomRange(size,size/2),0),new external_THREE_[\"Vector3\"](randomRange(size,size/2)*-1,randomRange(size,size/2),0),new external_THREE_[\"Vector3\"](randomRange(size,size/2)*-1,randomRange(size,size/2)*-1,0)];(_a=panelGeometry.vertices).push.apply(_a,vertices);(_b=lineGeometry.vertices).push.apply(_b,vertices.concat([vertices[0]]));panelGeometry.faces.push(new external_THREE_[\"Face3\"](0,1,2));panelGeometry.computeFaceNormals();panelGeometry.computeVertexNormals();this.line=new external_THREE_[\"Line\"](lineGeometry,this.lineMaterial);this.mesh=new external_THREE_[\"Mesh\"](panelGeometry,this.panelMaterial);this.group=new external_THREE_[\"Group\"]();this.translateOnAxis(this.translate(this.distance),1);this.group.add(this.line);this.group.add(this.mesh);this.rotateZ(this.rotate);this.updatePosition(0);}Triangle.prototype.rotateZ=function(angle){this.mesh.geometry.rotateZ(angle);this.line.geometry.rotateZ(angle);};Triangle.prototype.translate=function(distance){var x=Math.cos(this.angle*Math.PI/180)*distance;var y=Math.sin(this.angle*Math.PI/180)*distance;return new external_THREE_[\"Vector3\"](x,y,0);};Triangle.prototype.translateOnAxis=function(axis,distance){this.group.translateOnAxis(axis,distance);};Triangle.prototype.updatePosition=function(delay){this.translateOnAxis(this.translate(delay*this.speed),1);this.distance+=delay*this.speed;this.rotateZ(this.rotateSpeed*delay);this.panelMaterial.opacity=this.opacity(this.distance,this.showDistance)*this.panelOpacity;this.lineMaterial.opacity=this.opacity(this.distance,this.showDistance);if(this.distance>this.showDistance.endHide){this.delete();}};Triangle.prototype.delete=function(){this.onDelete(this);this.mesh.geometry.dispose();this.line.geometry.dispose();};Triangle.prototype.opacity=function(distance,showDistance){if(this.distanceshowDistance.startHide){return(showDistance.endHide-this.distance)/(showDistance.endHide-showDistance.startHide);}else{return 1;}};Triangle.prototype.transition=function(delay){this.updatePosition(delay);};return Triangle;}(); // CONCATENATED MODULE: ./src/util/range.ts function range_range(start,end,step,fromRight){if(step===void 0){step=1;}if(fromRight===void 0){fromRight=false;}var index=-1,length=Math.max(Math.ceil((end-start)/step),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}; // CONCATENATED MODULE: ./src/node.ts var node_node=/** @class */function(){function node(baseRange,angle,center){this.lastStrength=0;this.theStrength=0;this.targetRange=0;this._range=0;this.baseRange=baseRange;this.angle=angle;this.center=center;}Object.defineProperty(node.prototype,\"positionA\",{get:function(){var range=this._range+this.baseRange;var x=Math.cos(this.angle*Math.PI/180)*range;var y=Math.sin(this.angle*Math.PI/180)*range;return new external_THREE_[\"Vector2\"](this.center.x+x,this.center.y+y);},enumerable:true,configurable:true});Object.defineProperty(node.prototype,\"positionB\",{get:function(){var range=this._range*-1+this.baseRange;var x=Math.cos(this.angle*Math.PI/180)*range;var y=Math.sin(this.angle*Math.PI/180)*range;return new external_THREE_[\"Vector2\"](this.center.x+x,this.center.y+y);},enumerable:true,configurable:true});Object.defineProperty(node.prototype,\"strength\",{set:function(newStrength){this.lastStrength=this.theStrength;this.theStrength=newStrength;this.targetRange=Math.max(this.theStrength-this.lastStrength,0);if(this.targetRange>this._range)this._range=this.targetRange;},enumerable:true,configurable:true});node.prototype.transition=function(delay){this._range=Math.max(this._range-delay*this._range*5,0);};return node;}(); // EXTERNAL MODULE: ./node_modules/events/events.js var events = __webpack_require__(25); // CONCATENATED MODULE: ./src/audio.ts var __extends=undefined&&undefined.__extends||function(){var extendStatics=function(d,b){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return extendStatics(d,b);};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var audio_Audio=/** @class */function(_super){__extends(Audio,_super);function Audio(option){if(option===void 0){option={};}var _this=_super.call(this)||this;_this.listener=new external_THREE_[\"AudioListener\"]();_this.sound=new external_THREE_[\"Audio\"](_this.listener);_this.audioLoader=new external_THREE_[\"AudioLoader\"]();_this.analyser=new external_THREE_[\"AudioAnalyser\"](_this.sound,option.fftsize||256);_this.frequencyBinCount=_this.analyser.analyser.frequencyBinCount;return _this;}Audio.prototype.load=function(option){var _this=this;var src=option.src,_a=option.onLoad,onLoad=_a===void 0?function(buffer){return void 0;}:_a,_b=option.onPrgress,onPrgress=_b===void 0?function(xhr){return void 0;}:_b,_c=option.onError,onError=_c===void 0?function(){return void 0;}:_c;this.audioLoader.load(src,function(buffer){_this.sound.setBuffer(buffer);_this.sound.setLoop(true);return onLoad(buffer);},onPrgress,onError);};Audio.prototype.stop=function(){this.sound.stop();};Audio.prototype.play=function(){this.sound.play();};Audio.prototype.setVolume=function(volume){this.sound.setVolume(volume);};Audio.prototype.getFrequencyData=function(){return this.analyser.getFrequencyData();};return Audio;}(events[\"EventEmitter\"]); // CONCATENATED MODULE: ./src/lib/ExtendThree.ts var THREE=Object.assign(external_THREE_,{});/* harmony default export */ var ExtendThree = (THREE); // CONCATENATED MODULE: ./src/lib/LuminosityHighPassShader.js /** * @author bhouston / http://clara.io/ * * Luminosity * http://en.wikipedia.org/wiki/Luminosity */ExtendThree.LuminosityHighPassShader={shaderID:\"luminosityHighPass\",uniforms:{\"tDiffuse\":{type:\"t\",value:null},\"luminosityThreshold\":{type:\"f\",value:1.0},\"smoothWidth\":{type:\"f\",value:1.0},\"defaultColor\":{type:\"c\",value:new ExtendThree.Color(0x000000)},\"defaultOpacity\":{type:\"f\",value:0.0}},vertexShader:[\"varying vec2 vUv;\",\"void main() {\",\"vUv = uv;\",\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\"}\"].join(\"\\n\"),fragmentShader:[\"uniform sampler2D tDiffuse;\",\"uniform vec3 defaultColor;\",\"uniform float defaultOpacity;\",\"uniform float luminosityThreshold;\",\"uniform float smoothWidth;\",\"varying vec2 vUv;\",\"void main() {\",\"vec4 texel = texture2D( tDiffuse, vUv );\",\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\"float v = dot( texel.xyz, luma );\",\"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\",\"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\",\"gl_FragColor = mix( outputColor, texel, alpha );\",\"}\"].join(\"\\n\")}; // CONCATENATED MODULE: ./src/lib/CopyShader.js /** * @author alteredq / http://alteredqualia.com/ * * Full-screen textured quad shader */ExtendThree.CopyShader={uniforms:{\"tDiffuse\":{value:null},\"opacity\":{value:1.0}},vertexShader:[\"varying vec2 vUv;\",\"void main() {\",\"vUv = uv;\",\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\"}\"].join(\"\\n\"),fragmentShader:[\"uniform float opacity;\",\"uniform sampler2D tDiffuse;\",\"varying vec2 vUv;\",\"void main() {\",\"vec4 texel = texture2D( tDiffuse, vUv );\",\"gl_FragColor = opacity * texel;\",\"}\"].join(\"\\n\")}; // CONCATENATED MODULE: ./src/lib/EffectComposer.js /** * @author alteredq / http://alteredqualia.com/ */ExtendThree.EffectComposer=function(renderer,renderTarget){this.renderer=renderer;if(renderTarget===undefined){var parameters={minFilter:ExtendThree.LinearFilter,magFilter:ExtendThree.LinearFilter,format:ExtendThree.RGBAFormat,stencilBuffer:false};var size=renderer.getSize();renderTarget=new ExtendThree.WebGLRenderTarget(size.width,size.height,parameters);renderTarget.texture.name=\"EffectComposer.rt1\";}this.renderTarget1=renderTarget;this.renderTarget2=renderTarget.clone();this.renderTarget2.texture.name=\"EffectComposer.rt2\";this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2;this.passes=[];if(ExtendThree.CopyShader===undefined)console.error(\"THREE.EffectComposer relies on THREE.CopyShader\");this.copyPass=new ExtendThree.ShaderPass(ExtendThree.CopyShader);};Object.assign(ExtendThree.EffectComposer.prototype,{swapBuffers:function(){var tmp=this.readBuffer;this.readBuffer=this.writeBuffer;this.writeBuffer=tmp;},addPass:function(pass){this.passes.push(pass);var size=this.renderer.getSize();pass.setSize(size.width,size.height);},insertPass:function(pass,index){this.passes.splice(index,0,pass);},render:function(delta){var maskActive=false;var pass,i,il=this.passes.length;for(i=0;i"},{"title":"所有分类","date":"2020-03-07T12:48:40.678Z","updated":"2020-03-07T12:48:40.550Z","comments":true,"path":"blog/categories/index.html","permalink":"https://voiue.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-07T12:51:38.681Z","updated":"2020-03-07T12:51:38.573Z","comments":true,"path":"blog/tags/index.html","permalink":"https://voiue.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-11T05:40:45.170Z","updated":"2020-03-11T05:40:45.170Z","comments":true,"path":"music/three.js","permalink":"https://voiue.github.io/music/three.js","excerpt":"","text":"// threejs.org/license (function(l,sa){\"object\"===typeof exports&&\"undefined\"!==typeof module?sa(exports):\"function\"===typeof define&&define.amd?define([\"exports\"],sa):sa(l.THREE=l.THREE||{})})(this,function(l){function sa(){}function D(a,b){this.x=a||0;this.y=b||0}function X(a,b,c,d,e,f,g,h,k,m){Object.defineProperty(this,\"id\",{value:jf++});this.uuid=Y.generateUUID();this.name=\"\";this.image=void 0!==a?a:X.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:X.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:1001;this.wrapT= void 0!==d?d:1001;this.magFilter=void 0!==e?e:1006;this.minFilter=void 0!==f?f:1008;this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:1023;this.type=void 0!==h?h:1009;this.offset=new D(0,0);this.repeat=new D(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=void 0!==m?m:3E3;this.version=0;this.onUpdate=null}function ga(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1}function Db(a,b,c){this.uuid=Y.generateUUID();this.width= a;this.height=b;this.scissor=new ga(0,0,a,b);this.scissorTest=!1;this.viewport=new ga(0,0,a,b);c=c||{};void 0===c.minFilter&&(c.minFilter=1006);this.texture=new X(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding);this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.depthTexture=void 0!==c.depthTexture?c.depthTexture:null}function Eb(a,b,c){Db.call(this,a,b,c);this.activeMipMapLevel= this.activeCubeFace=0}function qa(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1}function p(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0}function J(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0=d||0"}],"posts":[{"title":"给pdf文件添加书签目录","slug":"add-bookmark-for-your-pdf","date":"2020-04-18T15:25:50.000Z","updated":"2020-04-18T15:25:50.000Z","comments":true,"path":"blog/2020-04-18-add-bookmark-for-your-pdf/","link":"","permalink":"https://voiue.github.io/blog/2020-04-18-add-bookmark-for-your-pdf/","excerpt":"pdf文档算是我们平时看到比较多的文档啦，而我们看pdf文件最喜欢的一个功能就是打开书签功能，这样我们就能快速定位，查看我们需要查看的内容，但是有时候会遇没有书签的pdf文档，这个时候看起来就有些不方便了，于是我在网上查了一下，还真的可以给pdf文件添加书签的办法，废话不多说，直接进入正题：","text":"pdf文档算是我们平时看到比较多的文档啦，而我们看pdf文件最喜欢的一个功能就是打开书签功能，这样我们就能快速定位，查看我们需要查看的内容，但是有时候会遇没有书签的pdf文档，这个时候看起来就有些不方便了，于是我在网上查了一下，还真的可以给pdf文件添加书签的办法，废话不多说，直接进入正题： 1，用Adobe acrobat 软件打开待添加书签的pdf文档。2，打开之后点击软件左边栏的书签（有时被隐藏了，点击一下界面左边靠近中间位置的箭头）。 3，打开书签栏之后，把pdf定位到要加书签的地方，然后点击新建书签（快捷键：Ctrl+B）。当然也可以用鼠标将要作为书签的文字选中，然后再按快捷键(Ctrl+B)，这样添加的书签标题就是刚刚选中的文字。 4，再输入书签的名称。5，如果要创建子书签，只需要像拖动文件夹一下，把要创立的子书签拖动到母书签那里，就行了。拖上去的时候，那里会显示一条细线，如题所示。 原文链接：https://blog.csdn.net/xiaotao_1/article/details/79357859","categories":[{"name":"tool","slug":"tool","permalink":"https://voiue.github.io/blog/categories/tool/"}],"tags":[{"name":"pdf","slug":"pdf","permalink":"https://voiue.github.io/blog/tags/pdf/"}]},{"title":"效率至上-一文带你真正走进vim","slug":"one-article-leads-you-to-vim","date":"2020-04-03T10:54:52.000Z","updated":"2020-04-03T10:54:52.000Z","comments":true,"path":"blog/2020-04-03-one-article-leads-you-to-vim/","link":"","permalink":"https://voiue.github.io/blog/2020-04-03-one-article-leads-you-to-vim/","excerpt":"vim一直是程序员之间比较有争议的一个话题。有人认为她是编辑器之神，有人则认为她古老过时，远远不如IDE，或是以当红小生vscode为代表的图形化文本编辑器。无论爱恨，我们的开发工作，大到远程登录服务器coding，修改config文件，小到git commit message，或多或少总要接触她。 为什么要写这篇blog呢，是因为我发现各大平台充斥的vim教程类blog其实很不友好，大多数是命令的堆砌，很少有对思想的解读。由此造成的结果，很多工程师对vim总是敬畏三分，或者就算部分人可以使用vim，也只是以自己的固有思维，结合vim的命令操作，并没有真正掌握vim的精髓。所以我尝试用自己的方式，试图帮助大家系统地建立起vim的知识系统。","text":"vim一直是程序员之间比较有争议的一个话题。有人认为她是编辑器之神，有人则认为她古老过时，远远不如IDE，或是以当红小生vscode为代表的图形化文本编辑器。无论爱恨，我们的开发工作，大到远程登录服务器coding，修改config文件，小到git commit message，或多或少总要接触她。 为什么要写这篇blog呢，是因为我发现各大平台充斥的vim教程类blog其实很不友好，大多数是命令的堆砌，很少有对思想的解读。由此造成的结果，很多工程师对vim总是敬畏三分，或者就算部分人可以使用vim，也只是以自己的固有思维，结合vim的命令操作，并没有真正掌握vim的精髓。所以我尝试用自己的方式，试图帮助大家系统地建立起vim的知识系统。 文章主要结构如下： 首先介绍vim编辑器最简单、基本的操作，让你快速入门，在遇到vim时，可以不至于惊慌，从容完成任务。如果想到某些操作，比如常用的复制、粘贴之类，可以到第二部分查找对应高阶操作，循序渐进使用vim。 接下来，将会介绍vim一系列高级操作，将我们的效率最大化。注：这部分信息量较大，建议您在阅读部分内容后，快速浏览不熟悉的命令，做到心中有数；随后可前进到第三部分；回过头来，再循序渐进，边学边练。 最后，试图讲述vim思想的精髓，既让我们真正对vim的操作融会贯通，又让我们可以在使用其他IDE/编辑器时应用这些思想，甚至在我们自己设计、实现功能、组件时，都能进行应用。这才算真正掌握了神器vim。 模式vim有三个模式，分别为普通（正常）模式、插入模式以及命令模式。 普通模式：一般用于浏览文件，也包括一些复制、粘贴、除等操作。 插入模式：主要用来输入、修改、删除字符，此时的操作，除了不能用鼠标外，与我们日常在编辑器中操作无异。普通模式下，通过i等命令进入插入模式。 命令模式：用以执行一些输入并执行一些vim或插件提供的指令。在普通模式下通过输入:后，可以发现，屏幕的右下角会出现:，此时便进入了命令模式。本文中使用：开头的命令，便可视为输入:进入命令模式后，输入后面的字符，执行命令。 很多人对于vim的第一点疑惑，便来源于此。我们习惯了图形化编辑器下，始终处于插入状态。然而在vim中，大多数情况下，我们会处于正常模式。只有当需要输入字符时，进入插入模式；当需要使用命令时，进入到命令模式。在插入和命令模式下，输入Esc便可返回正常模式。一张图概括如下： 注：后文讲解，如无特殊说明，均为普通模式下操作。 基本操作如果不追求效率，只想完成修改文件的任务，并保存退出，只需要掌握以下三个命令： 移动：h j k l最简单的移动，相当于键盘上面的方向键，分别对应左下上右。 进入插入模式：i 保存退出：ZZ（注意区分大小写） 流程如下： 普通模式下，通过h j k l移动到想要修改的位置 输入i进入插入模式，此时通过输入(字母、数字、符号)，删除(Backspace)等，完成基本修改操作 Esc回到普通模式，ZZ，保存修改并退出。 进阶：命令形式普通模式下，vim的命令主要分为以下三种： 动作，用以移动光标，或者定义操作的范围；比如： h：定义操作范围为一格，单独使用时，向左移动光标一格。 w：定义操作范围为一个单词，移动光标到下一个单词首部。 操作，这种命令需要在后面接表示操作范围的指令； d，删除，后接表示一个单词操作范围的w，即dw时，表示删除到当前词尾。 c，修改，后接表示一个单词操作范围的w，即cw时，表示修改当前单词。(编辑器行为表现为，删除到当前词尾，同时进入插入模式)。 命令，直接执行的命令，其中一部分，在执行命令后，直接进入编辑模式；比如： D，删除至行末。 I，到行首进入插入模式。 我们的使用方式主要也是三种：命令、动作、操作+动作。 此外，在动作类的命令前，加上number为可选项，可实现重复n次的效果： [number] + h/j/k/l向左/下/上/右移动number个字符。比如，’2j’，向下移动光标2个字符。 依旧使用d和w来举例，d是删除，w是单词，dw代表删除一个单词，d2w代表删除两个单词。后面的命令，大多都可应用此种形式组合使用，大家多注意，养成这种操作 + [次数] + 范围的思维模式，举一反三，便可发挥最大功效。 移动进阶单词级别的移动这里有仅大小写不同的两组命令，两组命令的功能，是相同的：跳转光标到对应位置。但是对应的单位不同，分别为word和string。具体区别是： string仅以空格分开； word以字母数字以外的字符分开。 以这个字符串为例：hello world-hehe111 abcde word有5个，分别为hello world, -, hehe111和abcde。 string有3个，分别为hello world-hehe111和abcde。 两组命令如下：（跳转光标至） w 下一个单词开头 e 当前或下一个单词结尾 b 当前或上一个单词开头 ge 上一个单词的结尾 W 下一个字符串的开头 E 当前或下一个字符串结尾 B 当前或上一个字符串的开头 GE 上一个字符串的结尾 举个例子，当光标位于hehe111的第一个字符h时，前后的单词/字符串信息如下： 前一个 当前 后一个 单词 - hehe111 abcde 字符串 hello world-hehe111 abcde 那么以上各个敲击以上各个命令的结果，便一目了然(加粗字表示命令运行后光标位置)： 句子，段落级别的移动 0 移动到当前行行首 ^ 移动到当前行的第一个非空字符 $ 移动到当前行尾 ( 跳转到当前或前一个句子的开头 ) 跳转到当前或下一个句子的结尾 { 跳转到当前或前一个段落的开头 } 跳转到当前或下一个段落的结尾 这里段落很容易理解，是以空行分隔开的。句子麻烦些，是按照句号来算的。 记得在这些命令前添加d试一下效果吧，掌握操作+范围这种命令形式吧。 页面级别的移动按行移动光标gg 移动到文本第一行行首G 移动到文本末行行首[n] + %：按百分比近似定位到某行，该行位于整个文件的n%处[n] + gg/G 跳转到第n行，常用。 要想用好上述几个命令，有两个简单的建议： 结合命令：ctrl-g。该命令的作用是显示当前行的位置信息（第几行，相对整个文本行数的百分比）。在命令模式下输入以下命令，或在~/.vimrc中添加如下代码片段 12set nu &quot; 显示行号set cursorline &quot; 高亮光标所在行&lt;&#x2F;pre&gt; 显示页面内移动光标 H：屏幕顶部行首 M：屏幕中央行首 L：屏幕底部行首 滚动与翻页 ctrl-d/u：前进/后退半页 ctrl-f/b：前进/后退整页 ctrl+e：上滚一行 ctrl+y：下滚一行 zt：使光标所在位置移动到屏幕的顶部（所有内容做位移） zz：使光标所在位置移动到屏幕的中央（所有内容做位移） zb：使光标所在位置移动到屏幕的底部（所有内容做位移） 匹配 f+单个字符：在本行内向右移动到指定字符 F+单个字符：在本行内向左移动到指定字符 t+单个字符：在本行内向右移动到指定字符的前一个字符 T+单个字符：在本行内向左移动到指定字符的前一个字符 %: 在“( )”、“[ ]”、“{ }”类符号的首尾间切换 * 和#: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）。 Mark m+[a~z] ：在当前光标做标记，如ma '+[mark]：光标返回指定标记所在的行，如'a，则光标返回到标记a所在行首 `+[mark]：光标返回指定标记 ctrl+o：跳转回光标前一个位置 ctrl+i：跳转回较新的光标位置 建议结合命令模式下如下两个命令，可获得更好体验： :marks：显示全部mark :delmarks [mark]：删除指定mark 编辑进阶进入插入模式在不同位置进入插入模式 i：在光标前插入字符 I：在行首插入字符 a：在光标后插入字符 A：在行尾插入字符 o：在光标下发插入空行 O：在光标上方插入空行 使用修改命令进入插入模式 c：修改，后面需要接范围 c+w：删除光标位置单词，并进入插入模式 c+l / s：删除光标位置字符，并进入插入模式 c+c / S：删除光标所在行，并进入插入模式 c+$ / C：删除光标位置到行尾的字符，并进入插入模式 r： 替换当前字符。 R：（进入replace模式）持续替换光标所在字符，直到使用ESC退出替换模式。 删除 x： 删除当前位置或下一个位置的字符。 d：删除，属于动作指令，后面需要加操作类指令。比如如下命令： de：删除到当前单词结尾。 dw：删除到下一个单词开始。 注意，此处与de的区别在于，dw会删除两个单词之间的空格。 daw：删除一个单词，包含单词的边界（空格）。 d0：删除至行首。 d$ / D：删除至行尾。 da[：删除[ ]整个块，包含符号本身； di[：删除[ ]块，不包含符号本身； da/di + ‘ “ { ( 等，也与接[类似，删除整个区块。唯一需要注意的，”和’仅仅在行内。 dt[x]：在本行，删除到[x]。比如，dt\"删除到双引号，dtf，删除到字母f。 d/foo：在全文， 删除到 “foo” 。 剪切剪切操作其实就是我们之前讲的删除。也就是d。删除的内容，默认会存放到剪切板中。也就相当于进行了剪切。 进阶操作符从这里大家可以看出，i和a的作用比较特殊，代表与区块相关的某种操作。区别就在于，i不包含区块边界符号。a包含。这两个操作符很重要，在后面的复制操作中还会用到。此外还有t，/。此外，i和a还可以接t，此时t表示一对xml标签。i：区块，不包含边界。a：区块，包含边界。t：”to”，本行到哪里。/：接匹配，全文到哪里。 粘贴 p：粘贴到光标后，或下一行。 P：粘贴到光标前，或前一行。 为什么会有光标前后或上下一行两种情况呢？是因为我们复制或剪切的内容有可能是字符串或者整行： 当复制内容为字符串时，粘贴到光标前/后。 当复制内容为整行时，粘贴到上/下一行。 复制 y，复制，属于操作，后面需要接动作来标识复制的范围。比如： yw：复制到当前单词结尾。 ye：从当前位置复制到本单词的最后一个字符。 y$：复制到当前行尾。 yy或Y：复制当前行。 nyy：复制从光标所在行起的n行，注意n在最前面。0y$： 命令意味着： 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符当然也可以结合我们刚刚介绍的进阶操作符来进行操作： yi\"：复制两个引号之间 yit：复制两个xml标签之间 y/[x]：复制到x。 剪切板vim 有 12 个剪切板，分别是 0、1、2、…、9、a、“、＋。:reg：查看各个剪切板里的内容。y，p默认使用 “剪切板中的内容。 \"[n]y：复制到剪切板n中。\"[n]p：粘贴剪切板n中的内容。 查看是否支持系统剪切板： 1vim --version | grep &quot;clipboard&quot; 观看输出中，clipboard前面是+还是-。若是-，则说明不支持系统剪切板。 +号剪切板比较特殊，是系统剪切板，用于与系统其他应用互动： \"+y，将内容复制到系统剪切板，ctrl＋v将其粘贴到其他应用中，比如vs code。 \"+p，将其他应用中复制的内容，粘贴到vim中。 可视模式v：进入可视模式。V：进入行选择模式。Crtl + v：进入块选择模式。 进入可视模式后，可以通过之前的移动操作，来进行选择。比如：hjkl：前后左右选择。$：选择到行尾。i\"：选择两个引号之间。 选择后，可以使用 d进行删除/剪切， y进行复制。 还可以使用以下很有意思的命令： gU：变大写。 gu：变小写。 J：把所有的行连接起来（变成一行）。 ：左右缩进。 = ：自动缩进 。 格式化=：调整格式化缩进。gg=G：全文代码格式化。 gg，到文章开头 =，调整格式 G，到文章结尾。 自动补全编辑模式下Ctrl + n/p出现提示，此时会出现补全的选项。按住Ctrl不放，用n和p来遍历提示选项，到达期待的选项后，无需其他操作，继续输入即可。 撤销 u：撤销前一个动作 U：撤销当前行的一系列动作 CTRL-R：Redo，意思就是我又不想撤销了。 查找替换 /： 查找，此时Terminal左下角会出现/，在后面输入想要查找的内容，回车即可。 ?：反向查找，同样道理，左下角会出现?。 /[search]\\c：忽略大小写。比如：/test\\c，查找test，忽略大小写 n： 下一个匹配 N： 前一个匹配 命令模式下： s/old/new/：用new替换old s/old/new/g：全局替换 set hlsearch：高亮搜索结果 宏录制qa操作序列q, @a, @@ qa把你的操作记录在寄存器a。 于是@a会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 命令 :w：保存修改 :wq：保存修改并退出 ZZ：保存修改并退出 q!：不保存修改，强制退出 e!：不保存修改，强制重新打开当前文件 大家可以看到，!的作用便在于，强制。除此以外，他还有另一个很强势的功能，就是执行shell命令。具体信息，大家可以详细阅读下一节。 .：重复执行前一个命令。这个命令很灵活、实用，建议多多尝试。 :help [command]：查看某命令的help此外，在命令行中执行如下命令，便可进入vim的教程。 1vimtutor 外部命令这是vim的一个很神奇的功能，在编辑的时候可以与外部文本互动，甚至执行一些shell命令。 :w [file-name]：将当前内容输出到指定文件中 :r [file-name]：将另外一个文件的内容输出到当前位置 :e filename：vim下打开指定文本 ctrl+w, s：水平拆分窗口 ctrl+w, v：垂直拆分窗口 ctrl+w, ARROW(h,j,k,l或方向键)：在窗口间切换光标。 ctrl+w, w：在窗口间切换光标。 :qa：关闭所有窗口。 :saveas：另存为。 :n/bn/bp：在打开的多个文件间切换。 :![command]：vim下执行某shell命令。 比如，:!ls，便会暂时切换到shell下，输出当前目录的文件名。此时输入回车，便可退回当前vim编辑的文件中。 如果你觉得这种输入命令的方式还不够过瘾，vim还提供了保留当前工作现场，直接进入shell的方式。这种命令一个典型的工作场景是，如我们编辑了一个文件，但是发现无法保存（没有写权限），此时可以先进入到shell下，执行类似chmod u+w [filename]，的命令，为当前用户获取该文件的写权限，然后再回到 vim 保存刚刚的修改。 有如下两种方法： :shell 或 :sh，当退出当前 shell 时（比如exit），就会回到 vim。 ctr-z 进入 shell，fg 退回 vim。 Config这部分主要是一些vim的config。可以直接命令模式输入，也可以保存到~/.vimrc中，便可每次打开vim自动应用。(其中一些命令是互相冲突的，请自行选择有用的命令)。 1234567891011121314151617syntax on # 开启语法高亮set nu[mber] # 显示行号set nonu[mber] # 隐藏行号set cursorline # 高亮当前行set ruler # 显示光标位置信息set noruler # 隐藏光标位置信息set hlsearch # 高亮匹配set nohlsearch # 取消高亮匹配nohlsearch # 临时取消高亮（只取消一次查询的高亮）set incsearch # 在输入字符串过程中显示匹配点set nowrapscan # 找到文尾后停止查找set wrapscan # 恢复为到文尾后自动从头开始set ic&#x2F;ignorecase) # 忽略大小写set noic&#x2F;noignorecase # 区分大小写&lt;&#x2F;pre&gt; VIM思想这部分主要是一些我在使用vim过程中的一些思考和感悟，试图尽力阐述出来。如果大家能有一些思考和收获，说明我的思考是有意义的。如果大家有不同见解，十分欢迎拍砖交流。 Why Normal 为什么vim下，要放弃人们习惯的插入模式，使用命令模式呢？仔细想一想，其实原因很简单：在没有鼠标的年代，人们只能依靠键盘来移动光标，修改文本。 为什么现在有了鼠标，我们还要用正常模式呢? 工作内容覆盖。我们每个人都认为，工程师的工作，是写代码。然而，其实我们主要的工作，是读，或者说，理解代码。经调查，工程师日常工作中，读：写代码的比例，为10：1(参考《Clean Code》一书)。所以默认的普通模式，主要满足占比重更大的”读“；遇到需要修改的时候，再进入编辑模式。 大量快捷键。相信每个人，都最起码知道一组快捷键：ctrl-c/v，也就是我们熟悉的copy &amp; paste. 如果你平时注重效率，养成了快捷键的习惯，还可能知道一些诸如ctrl-a/x/s/w等。不知你注意到没有，如刚刚列举的很多快捷键，都由特殊的命令符+字母构成。因为在此时，键盘上的大多数按键，都是可以输入到文本中的字符。而在vim的正常模式下面，无法直接向文件中输入这些字符，相当于不用按ctrl等特殊的命令符，直接可以把这些按键，用作命令的快捷键。 合理的快捷键 vim中的快捷键，布局非常合理。根据使用频繁程度，调整距离手边的距离。比如，最基础的移动操作，放在手边的HJKL。虽然移动将手移动到键盘上的方向键，并未真正的浪费多少时间，但是其对思维的打断，其实非常影响效率。 快捷键的设置，也是非常合理，结合了单词的意义、读音，非常便于记忆。比如： d delete c change w word e end b back I edit f find r replace 精细化，多维度命令快捷键应有尽有，各个维度移动，都切合使用者思维，几乎可以做到”指哪儿打哪儿“。 比如，移动、删除、复制、等等操作，都可以结合精细化的位置，根据符合人类思维的不同维度，进行操作。 比如，字符，单词，行，文章，屏幕，匹配（位置、文字、符号），以及类似书签的Mark等。 原子、组合命令vim的大部分快捷键，都是原子操作，并通过与范围结合，排列组合，灵活多变，完成各种强大的功能。这也与unix的主要思想契合：每个命令做好，且只做好同一件事。 与此同时，通过用数字和宏，代替无意义的重复。 此外，对一些常用操作，提供了现成的宏，方便操作。比如，dd，是删除整行，同时也可以直接用D来完成。I，A等，也是类似道理。 外部命令类似栈的思路，可以放下当前操作，保存现场，然后进入另一个操作。当操作完成后，回到当前现场。 思维模式vim的快捷键，或者说命令，不仅很符合我们的思维，而且还能在很大程度上扩展我们的思维。 拿编辑代码时最多的操作，移动光标来说。原来我们的移动，基本就是通过键盘的方向键，上下左右，或者通过鼠标，移动到想要去的位置。而在vim中，你会发现，光标除了上下左右，还可以移动到词首，词尾，句首，句尾，行首，行尾，页面首部，页面中部，页面尾部，文档首部，文档尾部，文档任意一行，甚至还可以移动到某个指定字母，某个tag，匹配大、中、小括号。度过最初的不适应后，通过刻意练习和日常使用，肌肉形成记忆，便无需刻意回想是用什么命令，而是潜意识完成操作。掌握了这些命令后，当你使用原来的编辑器时，也会去寻找这些快捷键。这就不仅仅是使用vim时候提供效率了，而是通过提高编辑操作的意识、思想，提高了整体的工作效率。 使用vim一段时间后，我在其他工具中进行编辑时，编再也无法忍受，一个一个自读地移动光标。于是也会主动去找单词、行级别移动的快捷键。 Mac系统 cmd + ←/→ 移动到：当前行首/尾部 alt + ←/→ 移动到：当前单词首/尾部 iterm： ctrl + f/b 前进/后退一个字符 Esc + f/b 前进/后退一个单词 ctrl + a/e 行首/行尾 ctrl + h/d 删除光标前/后一个字符 ctrl + w 删除光标前一个单词 ctrl + k/u 删除光标前/后所有内容 ctrl + y 粘贴之前删除的内容 后记这篇文章到这里也就结束了，洋洋洒洒写了这么多，一次读下来就接受，很难；仅仅通过阅读就掌握，更难。想要真正用熟vim，掌握思想，需要后续更多思考、实践。但是相信我，这些付出，一定是值得的。因为它不仅能让你掌握一个开发利器，更能带给你很有价值的思想。 原文链接：https://juejin.im/post/5c14ad47f265da614c4cb018","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"vim","slug":"Dev/vim","permalink":"https://voiue.github.io/blog/categories/Dev/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://voiue.github.io/blog/tags/vim/"}]},{"title":"如何在Linux中更改MAC地址","slug":"how-to-change-mac-address-on-linux","date":"2020-03-31T12:10:15.000Z","updated":"2020-03-31T12:10:15.000Z","comments":true,"path":"blog/2020-03-31-how-to-change-mac-address-on-linux/","link":"","permalink":"https://voiue.github.io/blog/2020-03-31-how-to-change-mac-address-on-linux/","excerpt":"在向你展示如何在 Linux 中更改 MAC 地址之前，让我们首先讨论为什么要更改它。 可能有几个原因。也许你不希望在公共网络上公开你的实际 MAC 地址（也称为物理地址）？还有可能是网络管理员可能已在路由器或防火墙中阻止了特定的 MAC 地址。 一个实用的“好处”是某些公共网络（例如机场 WiFi）允许在有限的时间内免费上网。如果你还想继续使用，那么伪造 Mac 地址可能会欺骗网络，让它认为是一台新设备。这也是一个有名的原因。 我将展示更改 MAC 地址（也称为欺骗/伪造 MAC 地址）的步骤。","text":"在向你展示如何在 Linux 中更改 MAC 地址之前，让我们首先讨论为什么要更改它。 可能有几个原因。也许你不希望在公共网络上公开你的实际 MAC 地址（也称为物理地址）？还有可能是网络管理员可能已在路由器或防火墙中阻止了特定的 MAC 地址。 一个实用的“好处”是某些公共网络（例如机场 WiFi）允许在有限的时间内免费上网。如果你还想继续使用，那么伪造 Mac 地址可能会欺骗网络，让它认为是一台新设备。这也是一个有名的原因。 我将展示更改 MAC 地址（也称为欺骗/伪造 MAC 地址）的步骤。 查找你的 MAC 地址和网络接口让我们找出一些关于 Linux 中网卡的细节。使用此命令获取网络接口详细信息： 1ip link show 在输出中，你将看到一些详细信息以及 MAC 地址： 123456781: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eno1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000 link&#x2F;ether 94:c6:f8:a7:d7:30 brd ff:ff:ff:ff:ff:ff3: enp0s31f6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000 link&#x2F;ether 38:42:f8:8b:a7:68 brd ff:ff:ff:ff:ff:ff4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default link&#x2F;ether 42:02:07:8f:a7:38 brd ff:ff:ff:ff:ff:ff 如你所见，在这里，我的网络接口称为enp0s31f6，MAC 地址为38:42:f8:8b:a7:68。 你可能需要在安全的地方记录下来，以便稍后还原到该原始 MAC 地址。 现在你可以继续更改 MAC 地址。 注意！ 如果在当前使用的网络接口上执行此操作，那么可能会中断你的网络连接。因此，请在其他网卡上尝试使用此方法，或者准备重启网络。 方法 1：使用 Macchanger 更改 MAC 地址Macchanger是查看、修改和操作网卡 MAC 地址的简单程序。它几乎在所有 GNU/Linux 操作系统中都可用，你可以使用发行版的包安装程序进行安装。 在 Arch Linux 或 Manjaro 上： 1sudo pacman -S macchanger 在 Fedora、CentOS 和 RHEL 上： 1sudo dnf install macchanger 在 Debian、Ubuntu、Linux Mint、Kali Linux 上： 1sudo apt install macchanger 重要！系统会要求你选择是否应将macchanger设置为在每次启动或关闭网络设备时自动运行。每当你接到网线或重启 WiFi 时，它都会提供一个新的 MAC 地址。 我建议不要自动运行它，除非你确实需要每次更改 MAC 地址。因此，选择“No”（按Tab键），然后按回车键继续。 如何使用 Macchanger 更改 MAC 地址 你还记得网络接口名称吗？你在前面的步骤中获得了它。 现在，要将随机 MAC 地址分配给该网卡，请使用： 1sudo macchanger -r enp0s31f6 更改 MAC 后，使用以下命令进行验证： 1ip addr 现在你将看到已经伪造 MAC。 要将 MAC 地址更改为特定值，请使用以下命令指定自定义 MAC 地址： 1macchanger --mac&#x3D;XX:XX:XX:XX:XX:XX 其中 XX:XX:XX:XX:XX:XX 是你要更改的新 MAC。 最后，要将 MAC 地址恢复为其原始硬件值，请运行以下命令： 1macchanger -p enp0s31f6 但是，你不必如此。重启系统后，更改将自动丢失，并且实际的 MAC 地址将再次恢复。 你可以随时查看手册页以获取更多详细信息。 方法 2：使用 iproute2 更改 Mac 地址（中级知识）我建议你使用 macchanger，但如果你不想使用它，那么可以使用另一种方法在 Linux 中更改 MAC 地址。 首先，使用以下命令关闭网卡： 1sudo ip link set dev enp0s31f6 down 接下来，使用以下命令设置新的 MAC： 1sudo ip link set dev enp0s31f6 address XX:XX:XX:XX:XX:XX 最后，使用以下命令重新打开网络： 1sudo ip link set dev enp0s31f6 up 现在，验证新的 MAC 地址： 1ip link show enp0s31f6 就是这些了。你已经成功地在 Linux 中修改了 MAC 地址。敬请期待 FOSS 更多有关 Linux 教程和技巧的文章。 原文链接：https://linux.cn/article-12008-1.html","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"linux","slug":"Dev/linux","permalink":"https://voiue.github.io/blog/categories/Dev/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://voiue.github.io/blog/tags/linux/"}]},{"title":"彻底理解文件系统","slug":"understand-file-system","date":"2020-03-26T09:09:51.000Z","updated":"2020-03-26T09:09:51.000Z","comments":true,"path":"blog/2020-03-26-understand-file-system/","link":"","permalink":"https://voiue.github.io/blog/2020-03-26-understand-file-system/","excerpt":"","text":"所有的应用程序都需要存储和检索信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。 第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。 因此，对于长久存储的信息我们有三个基本需求： 必须要有可能存储的大量的信息 信息必须能够在进程终止时保留 必须能够使多个进程同时访问有关信息 磁盘(Magnetic disk) 一直是用来长久保存信息的设备。近些年来，固态硬盘逐渐流行起来。 固态硬盘不仅没有易损坏的移动部件，而且能够提供快速的随机访问。相比而言，虽然磁带和光盘也被广泛使用，但是它们的性能相对较差，通常应用于备份。我们会在后面探讨磁盘，现在姑且把磁盘当作一种大小固定块的线性序列好了，并且支持如下操作 读块 k 写块 k 事实上磁盘支持更多的操作，但是只要有了读写操作，原则上就能够解决长期存储的问题。 然而，磁盘还有一些不便于实现的操作，特别是在有很多程序或者多用户使用的大型系统上（如服务器）。在这种情况下，很容易产生一些问题，例如 你如何找到这些信息？ 你如何保证一个用户不会读取另外一个用户的数据？ 你怎么知道哪些块是空闲的？等等问题 我们可以针对这些问题提出一个新的抽象 - 文件。进程和线程的抽象、地址空间和文件都是操作系统的重要概念。如果你能真正深入了解这三个概念，那么你就走上了成为操作系统专家的道路。 文件(Files)是由进程创建的逻辑信息单元。一个磁盘会包含几千甚至几百万个文件，每个文件是独立于其他文件的。事实上，如果你能把每个文件都看作一个独立的地址空间，那么你就可以真正理解文件的概念了。 进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是持久的，这也就是说，不会因为进程的创建和终止而受影响。一个文件只能在当用户明确删除的时候才能消失。尽管读取和写入都是最基本的操作，但还有许多其他操作，我们将在下面介绍其中的一些。 文件由操作系统进行管理，有关文件的构造、命名、访问、使用、保护、实现和管理方式都是操作系统设计的主要内容。从总体上看，操作系统中处理文件的部分称为文件系统(file system)，这就是我们所讨论的。 从用户角度来说，用户通常会关心文件是由什么组成的，如何给文件进行命名，如何保护文件，以及可以对文件进行哪些操作等等。尽管是用链表还是用位图记录内存空闲区并不是用户所关心的主题，而这些对系统设计人员来说至关重要。下面我们就来探讨一下这些主题 文件文件命名文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用名称访问该文件。 文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。 某些文件区分大小写字母，而大多数则不区分。UNIX属于第一类；历史悠久的MS-DOS属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：maria、Maria、MARIA 。在 MS-DOS ，所有这些命名都属于相同的文件。 这里可能需要在文件系统上预留一个位置。Windows 95 和 Windows 98 都使用了 MS-DOS 文件系统，叫做FAT-16，因此继承了它的一些特征，例如有关文件名的构造方法。Windows 98 引入了对 FAT-16 的一些扩展，从而导致了FAT-32的生成，但是这两者很相似。另外，Windows NT，Windows 2000，Windows XP，Windows Vista，Windows 7 和 Windows 8 都支持FAT文件系统，这种文件系统有些过时。然而，这些较新的操作系统还具有更高级的本机文件系统(NTFS)，有不同的特性，那就是基于Unicode编码的文件名。事实上，Windows 8 还配备了另一种文件系统，简称ReFS(Resilient File System)，但这个文件系统一般应用于 Windows 8 的服务器版本。下面除非我们特殊声明，否则我们在提到 MS-DOS 和 FAT 文件系统的时候，所指的就是 Windows 的 FAT-16 和 FAT-32。这里要说一下，有一种类似 FAT 的新型文件系统，叫做exFAT。它是微软公司对闪存和大文件系统开发的一种优化的 FAT 32 扩展版本。ExFAT 是现在微软唯一能够满足OS X读写操作的文件系统。 许多操作系统支持两部分的文件名，它们之间用 . 分隔开，比如文件名prog.c。原点后面的文件称为文件扩展名(file extension)，文件扩展名通常表示文件的一些信息。例如在 MS-DOS 中，文件名是 1 - 8 个字符，加上 1 - 3 个字符的可选扩展名组成。在 UNIX 中，如果有扩展名，那么扩展名的长度将由用户来决定，一个文件甚至可以包括两个或更多的扩展名，例如homepage.html.zip，html 表示一个 web 网页而 .zip 表示文件homepage.html已经采用 zip 程序压缩完成。一些常用的文件扩展名以及含义如下图所示 扩展名 含义 bak 备份文件 c c 源程序文件 gif 符合图形交换格式的图像文件 hlp 帮助文件 html WWW 超文本标记语言文档 jpg 符合 JPEG 编码标准的静态图片 mp3 符合 MP3 音频编码格式的音乐文件 mpg 符合 MPEG 编码标准的电影 o 目标文件（编译器输出格式，尚未链接） pdf pdf 格式的文件 ps PostScript 文件 tex 为 TEX 格式化程序准备的输入文件 txt 文本文件 zip 压缩文件 在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。 名为file.txt的文件是文本文件，这个文件名更多的是提醒所有者，而不是给计算机传递信息。但是另一方面，C 编译器可能要求它编译的文件以.c结尾，否则它会拒绝编译。然而，操作系统并不关心这一点。 对于可以处理多种类型的程序，约定就显得及其有用。例如 C 编译器可以编译、链接多种文件，包括 C 文件和汇编语言文件。这时扩展名就很有必要，编译器利用它们区分哪些是 C 文件，哪些是汇编文件，哪些是其他文件。因此，扩展名对于编译器判断哪些是 C 文件，哪些是汇编文件以及哪些是其他文件变得至关重要。 与 UNIX 相反，Windows 就会关注扩展名并对扩展名赋予了新的含义。用户(或进程) 可以在操作系统中注册扩展名，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。例如，双击 file.docx 启动了 Word 程序，并以 file.docx 作为初始文件。 文件结构文件的构造有多种方式。下图列出了常用的三种构造方式 上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是字节(bytes)。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。 把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。 图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：读操作返回一个记录，而写操作重写或者追加一个记录。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗记录树构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个key字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。 在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的pony记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由操作系统决定的。 文件类型很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有字符特殊文件(character special file) 和块特殊文件(block special file)。常规文件(Regular files) 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括可执行文件、文本文件、图像文件，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。 字符特殊文件和输入/输出有关，用于串行 I/O 类设备，如终端、打印机、网络等。块特殊文件用于磁盘类设备。我们主要讨论的是常规文件。 常规文件一般分为ASCII码文件或者二进制文件。ASCII 码文件由文本组成。在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符\\r。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符\\n）。一些系统（比如 Windows）两者都会使用。 ASCII 文件的优点在于显示和打印，还可以用任何文本编辑器进行编辑。进一步来说，如果许多应用程序使用 ASCII 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。 其他与 ASCII 不同的是二进制文件。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是字节序列，但是操作系统只有在文件格式正确的情况下才会执行。 这个文件有五个段：文件头、征文、数据、重定位位和符号表。文件头以魔数(magic number)为开始，表明这个文件是一个可执行文件（以防止意外执行非此格式的文件）。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在文件头后面，他们被加载到内存中或者重定位会根据重定位位进行判断。符号表则用于调试。 二进制文件的另外一种形式是存档文件，它由已编译但没有链接的库过程（模块）组合而成。每个文件都以模块头开始，其中记录了名称、创建日期、所有者、保护码和文件大小。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。 所有的操作系统必须至少能够识别一种文件类型：它自己的可执行文件。以前的 TOPS-20 系统（用于DECsystem 20）甚至要检查要执行的任何文件的创建时间，为了定位资源文件来检查自动文件创建后是否被修改过。如果被修改过了，那么就会自动编译文件。在 UNIX 中，就是在 shell 中嵌入make程序。此时操作系统要求用户必须采用固定的文件扩展名，从而确定哪个源程序生成哪个二进制文件。 什么是 make 程序？在软件发展过程中，make 程序是一个自动编译的工具，它通过读取称为Makefiles的文件来自动从源代码构建可执行程序和库，该文件指定了如何导出目标程序。尽管集成开发环境和特定于语言的编译器功能也可以用于管理构建过程，但 Make 仍被广泛使用，尤其是在 Unix 和类似 Unix 的操作系统中使用。 当程序从文件中读写数据时，请求会转到内核处理程序(kernel driver)。如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。 当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事儿。 块设备也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，块设备的概念是，相应的硬件可以一次读取或者写入整个块，例如磁盘上的一个扇区 字符设备也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。 目录(Directories) 是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于分层文件系统中，例如 Linux，MS-DOS 和 UNIX。 它显示所有本地和子目录（例如，cdn 目录中的 big 目录）。当前目录是 C 盘驱动器的根目录。之所以称为根目录，是因为该目录下没有任何内容，而其他目录都在该目录下分支。 文件访问早期的操作系统只有一种访问方式：序列访问(sequential access)。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。 在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为随机访问文件(random access file)。许多应用程序都需要这种方式。 随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。 有两种方法可以指示从何处开始读取文件。第一种方法是直接使用read从头开始读取。另一种是用一个特殊的seek操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。 文件属性文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的属性(attributes)。有些人也喜欢把它们称作元数据(metadata)。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：设置(set)和清除(clear)。下面是一些常用的属性 属性 含义 保护 谁可以访问文件、以什么方式存取文件 密码（口令） 访问文件所需要的密码（口令） 创建者 创建文件者的 ID 所有者 当前所有者 只读标志 0 表示读/写，1 表示只读 隐藏标志 0 表示正常，1 表示不再列表中显示 系统标志 0 表示普通文件，1 表示系统文件 存档标志 0 表示已经备份，1 表示需要备份 ASCII / 二进制标志 0 表示 ASCII 文件，1 表示二进制文件 随机访问标志 0 表示只允许顺序访问，1 表示随机访问 临时标志 0 表示正常，1 表示进程退出时删除该文件 加锁标志 0 表示未加锁，1 表示加锁 记录长度 一个记录中的字节数 键的位置 每个记录中的键的偏移量 键的长度 键字段的字节数 创建时间 创建文件的日期和时间 最后一次存取时间 上一次访问文件的日期和时间 最后一次修改时间 上一次修改文件的日期和时间 当前大小 文件的字节数 最大长度 文件可能增长到的字节数 没有一个系统能够同时具有上面所有的属性，但每个属性都在某个系统中采用。 前面四个属性（保护，口令，创建者，所有者）与文件保护有关，它们指出了谁可以访问这个文件，谁不能访问这个文件。 保护（File Protection）： 用于保护计算机上有价值数据的方法。文件保护是通过密码保护文件或者仅仅向特定用户或组提供权限来实现。 在一些系统中，用户必须给出口令才能访问文件。标志(flags)是一些位或者短属性能够控制或者允许特定属性。 隐藏文件位(hidden flag)表示该文件不在文件列表中出现。 存档标志位(archive flag)用于记录文件是否备份过，由备份程序清除该标志位；若文件被修改，操作系统则设置该标志位。用这种方法，备份程序可以知道哪些文件需要备份。 临时标志位(temporary flag) 允许文件被标记为是否允许自动删除当进程终止时。 记录长度(record-length)、键的位置(key-position)和键的长度(key-length)等字段只能出现在用关键字查找记录的文件中。它们提供了查找关键字所需要的信息。 不同的时间字段记录了文件的创建时间、最近一次访问时间以及最后一次修改时间，它们的作用不同。例如，目标文件生成后被修改的源文件需要重新编译生成目标文件。这些字段提供了必要的信息。 当前大小字段指出了当前的文件大小，一些旧的大型机操作系统要求在创建文件时指定文件呢最大值，以便让操作系统提前保留最大存储值。但是一些服务器和个人计算机却不用设置此功能。 文件操作使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用： Create，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。 Delete，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。 Open，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。 Close，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一块，即使这个块空间内部还不满。 Read，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。 Write，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。 append，使用 append 只能向文件末尾添加数据。 seek，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。 get attributes，进程运行时通常需要读取文件属性。 set attributes，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。 rename，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。 目录文件系统通常提供目录(directories) 或者文件夹(folders) 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。 一级目录系统目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为根目录(root directory)，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子 该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。 层次目录系统对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了层次目录系统(Hierarchical Directory Systems)，也称为目录树。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下 根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了子目录。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。 路径名当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个绝对路径名(absolute path name)，它由根目录到文件的路径组成。举个例子，/usr/ast/mailbox意味着根目录包含一个子目录usr，usr下面包含了一个mailbox。绝对路径名总是以/开头，并且是唯一的。在UNIX中，路径的组件由/分隔。在Windows中，分隔符为\\。 在 MULTICS 中，它是>。 因此，在这三个系统中，相同的路径名将被编写如下 123Windows \\usr\\ast\\mailboxUNIX &#x2F;usr&#x2F;ast&#x2F;mailboxMULTICS &gt;usr&gt;ast&gt;mailbox 不论使用哪种方式，如果路径名的第一个字符是分隔符，那就是绝对路径。 另外一种指定文件名的方法是相对路径名(relative path name)。它常常和工作目录(working directory) （也称作当前目录(current directory)）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是/usr/ast，那么绝对路径/usr/ast/mailbox可以直接使用mailbox来引用。也就是说，如果工作目录是/usr/ast，则 UNIX 命令 1cp &#x2F;usr&#x2F;ast&#x2F;mailbox &#x2F;usr&#x2F;ast&#x2F;mailbox.bak 和命令 1cp mailbox mailbox.bak 具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。 一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。 支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项.和..，长读作dot和dotdot。dot 指的是当前目录，dotdot 指的是其父目录（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。 一个进程的工作目录是/usr/ast，它可采用..沿树向上，例如，可用命令 1cp ..&#x2F;lib&#x2F;dictionary . 把文件usr/lib/dictionary复制到自己的目录下，第一个路径告诉系统向上找（到 usr 目录），然后向下到lib目录，找到 dictionary 文件 第二个参数 . 指定当前的工作目录，当 cp 命令用目录名作为最后一个参数时，则把全部的文件复制到该目录中。当然，对于上述复制，键入 1cp &#x2F;usr&#x2F;lib&#x2F;dictionary 是更常用的方法。用户这里采用.可以避免键入两次 dictionary 。无论如何，键入 1cp &#x2F;usr&#x2F;lib&#x2F;dictionary dictionary 也可正常工作，就像键入 1cp &#x2F;usr&#x2F;lib&#x2F;dictionary &#x2F;usr&#x2F;lib&#x2F;dictionary 一样。所有这些命令都能够完成同样的工作。 目录操作不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。 Create，创建目录，除了目录项.和..外，目录内容为空。 Delete，删除目录，只有空目录可以删除。只包含.和..的目录被认为是空目录，这两个目录项通常不能删除 opendir，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。 closedir，读目录结束后，应该关闭目录用于释放内部表空间。 readdir，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。 rename，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。 link，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为硬链接(hard link)。 unlink，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。 文件系统的实现在对文件有了基本认识之后，现在是时候把目光转移到文件系统的实现上了。之前用户关心的一直都是文件是怎样命名的、可以进行哪些操作、目录树是什么，如何找到正确的文件路径等问题。而设计人员关心的是文件和目录是怎样存储的、磁盘空间是如何管理的、如何使文件系统得以流畅运行的问题，下面我们就来一起讨论一下这些问题。 文件系统布局文件系统存储在磁盘中。大部分的磁盘能够划分出一到多个分区，叫做磁盘分区(disk partitioning) 或者是磁盘分片(disk slicing)。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为主引导记录(Master Boot Record, MBR)，用来引导(boot) 计算机。在 MBR 的结尾是分区表(partition table)。每个分区表给出每个分区由开始到结束的地址。系统管理员使用一个称为分区编辑器的程序来创建，调整大小，删除和操作分区。这种方式的一个缺点是很难适当调整分区的大小，导致一个分区具有很多可用空间，而另一个分区几乎完全被分配。 MBR 可以用在 DOS 、Microsoft Windows 和 Linux 操作系统中。从 2010 年代中期开始，大多数新计算机都改用 GUID 分区表（GPT）分区方案。 下面是一个用GParted进行分区的磁盘，表中的分区都被认为是活动的(active)。 当计算机开始引 boot 时，BIOS 读入并执行 MBR。 引导块MBR 做的第一件事就是确定活动分区，读入它的第一个块，称为引导块(boot block) 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。 在计算机中，引导就是启动计算机的过程，它可以通过硬件（例如按下电源按钮）或者软件命令的方式来启动。开机后，电脑的 CPU 还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中，然后才能让 CPU 开始执行。也就是计算机开机后，首先会进行软件的装载过程。 重启电脑的过程称为重新引导(rebooting)，从休眠或睡眠状态返回计算机的过程不涉及启动。 除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下 超级块紧跟在引导块后面的是超级块(Superblock)，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数 文件系统的大小 文件系统中的数据块数 指示文件系统状态的标志 分配组大小 在计算机启动或者文件系统首次使用时，超级块会被读入内存。 空闲空间块接着是文件系统中空闲块的信息，例如，可以用位图或者指针列表的形式给出。 BitMap 位图或者 Bit vector 位向量 位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。 使用链表进行管理 在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。 碎片 这里不得不提一个叫做碎片(fragment)的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。如果你不理解这个概念就给你举个例子。比如你用 Windows 电脑创建了一个文件，你会发现这个文件可以存储在任何地方，比如存在桌面上，存在磁盘中的文件夹中或者其他地方。你可以打开文件，编辑文件，删除文件等等。你可能以为这些都在一个地方发生，但是实际上并不是，你的硬盘驱动器可能会将文件中的一部分存储在一个区域内，另一部分存储在另外一个区域，在你打开文件时，硬盘驱动器会迅速的将文件的所有部分汇总在一起，以便其他计算机系统可以使用它。 inode 然后在后面是一个inode(index node)，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置 有一种简单的方法可以找到它们ls -lai命令。让我们看一下根文件系统： inode 节点主要包括了以下信息 模式/权限（保护） 所有者 ID 组 ID 文件大小 文件的硬链接数 上次访问时间 最后修改时间 inode 上次修改时间 文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。 紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。 文件的实现最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是有效利用文件空间和快速访问文件 ，主要有三种分配方案 连续分配 链表分配 索引分配 连续分配最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。 上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。 注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了3 又 1/2个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。 连续的磁盘空间分配有两个优点。 第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。 第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。 因此，连续的空间分配具有实现简单、高性能的特点。 不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象 这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。 刚开始的时候，这个碎片不是问题，因为每个新文件都会在之前文件的结尾处进行写入。然而，磁盘最终会被填满，因此要么压缩磁盘、要么重新使用空闲块的空间。压缩磁盘的开销太大，因此不可行；后者会维护一个空闲列表，这个是可行的。但是这种情况又存在一个问题，为空闲块匹配合适大小的文件，需要知道该文件的最终大小。 想象一下这种设计的结果会是怎样的。用户启动 word 进程创建文档。应用程序首先会询问最终创建的文档会有多大。这个问题必须回答，否则应用程序就不会继续执行。如果空闲块的大小要比文件的大小小，程序就会终止。因为所使用的磁盘空间已经满了。那么现实生活中，有没有使用连续分配内存的介质出现呢？ CD-ROM就广泛的使用了连续分配方式。 CD-ROM（Compact Disc Read-Only Memory）即只读光盘，也称作只读存储器。是一种在电脑上使用的光碟。这种光碟只能写入数据一次，信息将永久保存在光碟上，使用时通过光碟驱动器读出信息。 然而 DVD 的情况会更加复杂一些。原则上，一个90分钟的电影能够被编码成一个独立的、大约 4.5 GB 的文件。但是文件系统所使用的UDF(Universal Disk Format) 格式，使用一个 30 位的数来代表文件长度，从而把文件大小限制在 1 GB。所以，DVD 电影一般存储在 3、4个连续的 1 GB 空间内。这些构成单个电影中的文件块称为扩展区(extends)。 就像我们反复提到的，历史总是惊人的相似，许多年前，连续分配由于其简单和高性能被实际使用在磁盘文件系统中。后来由于用户不希望在创建文件时指定文件的大小，于是放弃了这种想法。但是随着 CD-ROM 、DVD、蓝光光盘等光学介质的出现，连续分配又流行起来。从而得出结论，技术永远没有过时性，现在看似很老的技术，在未来某个阶段可能又会流行起来。 链表分配第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示 每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案 与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。 另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。 还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。 使用内存表进行链表分配由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子 上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址4、7、 2、 10、 12，文件 B 使用了6、3、11 和 14。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为文件分配表(File Application Table,FAT)。 使用这种组织方式，整个块都可以存放数据。进而，随机访问也容易很多。虽然仍要顺着链在内存中查找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。 这种方式存在缺点，那就是必须要把整个链表放在内存中。对于 1TB 的磁盘和 1KB 的大小的块，那么这张表需要有 10 亿项。。。每一项对应于这 10 亿个磁盘块中的一块。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 的内存。FAT 的管理方式不能较好地扩展并应用于大型磁盘中。而这正是最初 MS-DOS 文件比较实用，并仍被各个 Windows 版本所安全支持。 inode最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为inode(索引节点) 的数据结构，每个文件都与一个inode进行关联，inode 由整数进行标识。 下面是一个简单例子的描述。 给出 inode 的长度，就能够找到文件中的所有块。 相对于在内存中使用表的方式而言，这种机制具有很大的优势。即只有在文件打开时，其 inode 才会在内存中。如果每个 inode 需要 n 个字节，最多 k 个文件同时打开，那么 inode 占有总共打开的文件是 kn 字节。仅需预留这么多空间。 这个数组要比我们上面描述的FAT(文件分配表) 占用的空间小的多。原因是用于保存所有磁盘块的链接列表的表的大小与磁盘本身成正比。如果磁盘有 n 个块，那么这个表也需要 n 项。随着磁盘空间的变大，那么该表也随之线性增长。相反，inode 需要节点中的数组，其大小和可能需要打开的最大文件个数成正比。它与磁盘是 100GB、4000GB 还是 10000GB 无关。 inode 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是最后一个磁盘地址不指向数据块，而是指向一个包含额外磁盘块地址的地址，如上图所示。一个更高级的解决方案是：有两个或者更多包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。Windows 的 NTFS 文件系统采用了相似的方法，所不同的仅仅是大的 inode 也可以表示小的文件。 NTFS 的全称是New Technology File System，是微软公司开发的专用系统文件，NTFS 取代 FAT(文件分配表) 和HPFS(高性能文件系统) ，并在此基础上进一步改进。例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率等。 目录的实现文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用那种情况，目录系统的主要功能就是将文件的 ASCII 码的名称映射到定位数据所需的信息上。 与此关系密切的问题是属性应该存放在哪里。每个文件系统包含不同的文件属性，例如文件的所有者和创建时间，需要存储的位置。一种显而易见的方法是直接把文件属性存放在目录中。有一些系统恰好是这么做的，如下。 在这种简单的设计中，目录有一个固定大小的目录项列表，每个文件对应一项，其中包含一个固定长度的文件名，文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。 对于采用 inode 的系统，会把 inode 存储在属性中而不是目录项中。在这种情况下，目录项会更短：仅仅只有文件名称和 inode 数量。这种方式如下所示 到目前为止，我们已经假设文件具有较短的、固定长度的名字。在 MS-DOS 中，具有 1 - 8 个字符的基本名称和 1 - 3 个字符的可拓展名称。在 UNIX 版本 7 中，文件有 1 - 14 个字符，包括任何拓展。然而，几乎所有的现代操作系统都支持可变长度的扩展名。这是如何实现的呢？ 最简单的方式是给予文件名一个长度限制，比如 255 个字符，然后使用上图中的设计，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间，因为只有很少的文件会有那么长的文件名称。所以，需要一种其他的结构来处理。 一种可选择的方式是放弃所有目录项大小相同的想法。在这种方法中，每个目录项都包含一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息和其他属性。这个固定长度的头的后面是一个任意长度的实际文件名，如下图所示 上图是 SPARC 机器使用正序放置。 处理机中的一串字符存放的顺序有正序(big-endian) 和逆序(little-endian) 之分。正序存放的就是高字节在前低字节在后，而逆序存放的就是低字节在前高字节在后。 这个例子中，有三个文件，分别是project-budget、personnel和foo。每个文件名以一个特殊字符（通常是 0 ）结束，用矩形中的叉进行表示。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字，如下图所示 这个方法的缺点是当文件被移除后，就会留下一块固定长度的空间，而新添加进来的文件大小不一定和空闲空间大小一致。 这个问题与我们上面探讨的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行紧凑拼接操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页上，在读取文件名时可能发生缺页中断。 处理可变长度文件名字的另外一种方法是，使目录项自身具有固定长度，而将文件名放在目录末尾的堆栈中。如上图所示的这种方式。这种方法的优点是当目录项被移除后，下一个文件将能够正常匹配移除文件的空间。当然，必须要对堆进行管理，因为在处理文件名的时候也会发生缺页异常。 到目前为止的所有设计中，在需要查找文件名时，所有的方案都是线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低。提高文件检索效率的一种方式是在每个目录上使用哈希表(hash table)，也叫做散列表。我们假设表的大小为 n，在输入文件名时，文件名被散列在 0 和 n - 1 之间，例如，它被 n 除，并取余数。或者对构成文件名字的字求和或类似某种方法。 无论采用哪种方式，在添加一个文件时都要对与散列值相对 应的散列表进行检查。如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表（这种构造方式是不是和 HashMap 使用的数据结构一样？），链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。 查找文件的过程和添加类似，首先对文件名进行哈希处理，在哈希表中查找是否有这个哈希值，如果有的话，就检查这条链上所有的哈希项，查看文件名是否存在。如果哈希不在链上，那么文件就不在目录中。 使用哈希表的优势是查找非常迅速，缺点是管理起来非常复杂。只有在系统中会有成千上万个目录项存在时，才会考虑使用散列表作为解决方案。 另外一种在大量目录中加快查找指令目录的方法是使用缓存，缓存查找的结果。在开始查找之前，会首先检查文件名是否在缓存中。如果在缓存中，那么文件就能立刻定位。当然，只有在较少的文件下进行多次查找，缓存才会发挥最大功效。 共享文件当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是C 的一个文件也出现在了 B 的目录下。 如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为链接(link)。那么文件系统现在就是一个有向无环图(Directed Acyclic Graph, 简称 DAG)，而不是一棵树了。 在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图，我们不会在此着重探讨关于图论的东西，大家可以自行 google。 将文件系统组织成为有向无环图会使得维护复杂化，但也是必须要付出的代价。 共享文件很方便，但这也会带来一些问题。如果目录中包含磁盘地址，则当链接文件时，必须把 C 目录中的磁盘地址复制到 B 目录中。如果 B 或者 C 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。 有两种方案可以解决这种问题。 第一种解决方案，磁盘块不列入目录中，而是会把磁盘块放在与文件本身相关联的小型数据结构中。目录将指向这个小型数据结构。这是UNIX中使用的方式（小型数据结构就是 inode）。 在第二种解决方案中，通过让系统建立一个类型为LINK的新文件，并把该文件放在 B 的目录下，使得 B 与 C 建立链接。新的文件中只包含了它所链接的文件的路径名。当 B 想要读取文件时，操作系统会检查 B 的目录下存在一个类型为 LINK 的文件，进而找到该链接的文件和路径名，然后再去读文件，这种方式称为符号链接(symbolic linking)。 上面的每一种方法都有各自的缺点，在第一种方式中，B 链接到共享文件时，inode 记录文件的所有者为 C。建立一个链接并不改变所有关系，如下图所示。 第一开始的情况如图 a 所示，此时 C 的目录的所有者是 C ，当目录 B 链接到共享文件时，并不会改变 C 的所有者关系，只是把计数 + 1，所以此时系统知道目前有多少个目录指向这个文件。然后 C 尝试删除这个文件，这个时候有个问题，如果 C 把文件移除并清除了 inode 的话，那么 B 会有一个目录项指向无效的节点。如果 inode 以后分配给另一个文件，则 B 的链接指向一个错误的文件。系统通过 inode 可知文件仍在被引用，但是没有办法找到该文件的全部目录项以删除它们。指向目录的指针不能存储在 inode 中，原因是有可能有无数个这样的目录。 所以我们能做的就是删除 C 的目录项，但是将 inode 保留下来，并将计数设置为 1 ，如上图 c 所示。c 表示的是只有 B 有指向该文件的目录项，而该文件的前者是 C 。如果系统进行记账操作的话，那么 C 将继续为该文件付账直到 B 决定删除它，如果是这样的话，只有到计数变为 0 的时刻，才会删除该文件。 对于符号链接，以上问题不会发生，只有真正的文件所有者才有一个指向 inode 的指针。链接到该文件上的用户只有路径名，没有指向 inode 的指针。当文件所有者删除文件时，该文件被销毁。以后若试图通过符号链接访问该文件将会失败，因为系统不能找到该文件。删除符号链接不会影响该文件。 符号链接的问题是需要额外的开销。必须读取包含路径的文件，然后要一个部分接一个部分地扫描路径，直到找到 inode 。这些操作也许需要很多次额外的磁盘访问。此外，每个符号链接都需要额外的 inode ，以及额外的一个磁盘块用于存储路径，虽然如果路径名很短，作为一种优化，系统可以将它存储在 inode 中。符号链接有一个优势，即只要简单地提供一个机器的网络地址以及文件在该机器上驻留的路径，就可以连接全球任何地方机器上的文件。 还有另一个由链接带来的问题，在符号链接和其他方式中都存在。如果允许链接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被链接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被链接的文件将被两次复制到磁盘上，而不是只是被链接起来。 日志结构文件系统技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。 这些因素结合起来意味着许多系统文件中出现性能瓶颈。为此，Berkeley设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是日志结构文件系统(Log-structured File System, LFS)。 日志结构文件系统由Rosenblum和Ousterhout于90年代初引入，旨在解决以下问题。 不断增长的系统内存 顺序 I/O 性能胜过随机 I/O 性能 现有低效率的文件系统 文件系统不支持 RAID（虚拟化） 另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为Page cache的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。 在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的inode map(inode 映射)。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。 日志结构文件系统主要使用四种数据结构：Inode、Inode Map、Segment、Segment Usage Table。 到目前为止，所有写入最初都缓存在内存中，并且追加在日志末尾，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。 真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。 为了处理这个问题，LFS 有一个清理(clean)线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的环形缓冲区，写线程将新的段写在前面，而清理线程则清理后面的段。 日志文件系统虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做日志文件系统，它会记录系统下一步将要做什么的日志。微软的NTFS文件系统、Linux 的ext3就使用了此日志。OS X将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如移除文件，这个操作在 UNIX 中需要三个步骤完成： 在目录中删除文件 释放 inode 到空闲 inode 池 将所有磁盘块归还给空闲磁盘池。 在 Windows 中，也存在类似的步骤。不存在系统崩溃时，这些步骤的执行顺序不会带来问题。但是一旦系统崩溃，就会带来问题。假如在第一步完成后系统崩溃。inode 和文件块将不会被任何文件获得，也不会再分配；它们只存在于废物池中的某个地方，并因此减少了可利用的资源。如果崩溃发生在第二步后，那么只有磁盘块会丢失。日志文件系统保留磁盘写入期间对文件系统所做的更改的日志或日志，该日志可用于快速重建可能由于系统崩溃或断电等事件而发生的损坏。 一般文件系统崩溃后必须运行fsck（文件系统一致性检查）实用程序。 为了让日志能够正确工作，被写入的日志操作必须是幂等的(idempotent)，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作更新位表并标记 inode k 或者块 n 是空闲的可以重复执行任意次。同样地，查找一个目录并且删除所有叫foobar的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。 为了增加可靠性，一个文件系统可以引入数据库中原子事务(atomic transaction) 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。 虚拟文件系统即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统。Windows 中的主要文件系统是NTFS 文件系统，但不是说 Windows 只有 NTFS 操作系统，它还有一些其他的例如旧的FAT -32或FAT -16驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。Windows 通过指定不同的盘符来处理这些不同的文件系统，比如C:，D:等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。 相比之下，UNIX 采用了一种不同的方式，即 UNIX 把多种文件系统整合到一个统一的结构中。一个 Linux 系统可以使用ext2作为根文件系统，ext3分区装载在/usr下，另一块采用Reiser FS文件系统的硬盘装载到/home下，以及一个 ISO 9660 的 CD - ROM 临时装载到/mnt下。从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，对于用户和进程是不可见的。 UNIX 操作系统使用一种虚拟文件系统(Virtual File System, VFS) 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构 还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个代理来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的POSIX 系统调用，比如 open、read、write 和 seek 等。VFS 对用户进程有一个上层接口，这个接口就是著名的 POSIX 接口。 VFS 也有一个对于实际文件的下层接口，就是上图中标记为 VFS 的接口。这个接口包含许多功能调用，这样 VFS 可以使每一个文件系统完成任务。因此，要创建一个可以与 VFS 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 VFS 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，VFS具有两个不同的接口：上一个到用户进程，下一个到具体文件系统。 当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件时，不管在启动时还是在操作过程中，它们也必须在 VFS 中注册。当一个文件系统注册时，根文件系统注册到 VFS。另外，在引导时或操作期间挂载其他文件系统时，它们也必须向 VFS 注册。当文件系统注册时，其基本作用是提供 VFS 所需功能的地址列表、调用向量表、或者 VFS 对象。因此一旦文件系统注册到 VFS，它就知道从哪里开始读取数据块。 装载文件系统后就可以使用它了。比如，如果一个文件系统装载到/usr并且一个进程调用它： 1open(&quot;&#x2F;usr&#x2F;include&#x2F;unistd.h&quot;,O_RDONLY) 当解析路径时， VFS 看到新的文件系统被挂载到/usr，并且通过搜索已经装载文件系统的超级块来确定它的超块。然后它找到它所转载的文件的根目录，在那里查找路径include/unistd.h。然后 VFS 创建一个 vnode 并调用实际文件系统，以返回所有的在文件 inode 中的信息。这个信息和其他信息一起复制到 vnode （内存中）。而这些其他信息中最重要的是指向包含调用 vnode 操作的函数表的指针，比如 read、write 和 close 等。 当 vnode 被创建后，为了进程调用，VFS 在文件描述符表中创建一个表项，并将它指向新的 vnode，最后，VFS 向调用者返回文件描述符，所以调用者可以用它去 read、write 或者 close 文件。 当进程用文件描述符进行一个读操作时，VFS 通过进程表和文件描述符确定 vnode 的位置，并跟随指针指向函数表，这样就调用了处理 read 函数，运行在实际系统中的代码并得到所请求的块。VFS 不知道请求时来源于本地硬盘、还是来源于网络中的远程文件系统、CD-ROM 、USB 或者其他介质，所有相关的数据结构欧如下图所示 从调用者进程号和文件描述符开始，进而是 vnode，读函数指针，然后是对实际文件系统的访问函数定位。 文件系统的管理和优化能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。 磁盘空间管理文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块。在存储管理系统中，主要有分段管理和分页管理两种方式。 正如我们所看到的，按连续字节序列存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。 块大小一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位。在分页系统中，分页大小也是主要因素。 拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块太大会浪费空间；分配的块太小会浪费时间。 记录空闲块一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示 第一种方法是采用磁盘块链表，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。 另一种空闲空间管理的技术是位图(bitmap)，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。 如果空闲块是长期连续的话，那么空闲列表可以改成记录连续分块而不是单个的块。每个块都会使用 8位、16位、32 位的计数来与每个块相联，来记录连续空闲块的数量。最好的情况是一个空闲块可以用两个数字来表示：第一个空闲块的地址和空闲块的计数。另一方面，如果磁盘严重碎片化，那么跟踪连续分块要比跟踪单个分块运行效率低，因为不仅要存储地址，还要存储数量。 这种情况说明了一个操作系统设计者经常遇到的一个问题。有许多数据结构和算法可以用来解决问题，但是选择一个最好的方案需要数据的支持，而这些数据是设计者无法预先拥有的。只有在系统部署完毕真正使用使用后才会获得。 现在，回到空闲链表的方法，只有一个指针块保存在内存中。创建文件时，所需要的块从指针块中取出。当它用完时，将从磁盘中读取一个新的指针块。类似地，删除文件时，文件的块将被释放并添加到主存中的指针块中。当块被填满时，写回磁盘。 在某些特定的情况下，这个方法导致了不必要的磁盘 IO，如下图所示 上面内存中的指针块仅有两个空闲块，如果释放了一个含有三个磁盘块的文件，那么该指针块就会溢出，必须将其写入磁盘，那么就会产生如下图的这种情况。 如果现在写入含有三个块的文件，已满的指针不得不再次读入，这将会回到上图 a 中的情况。如果有三个块的文件只是作为临时文件被写入，在释放它时，需要进行另一次磁盘写操作以将完整的指针块写回到磁盘。简而言之，当指针块几乎为空时，一系列短暂的临时文件可能会导致大量磁盘 I/O。 避免大部分磁盘 I/O 的另一种方法是拆分完整的指针块。这样，当释放三个块时，变化不再是从 a - b，而是从 a - c，如下图所示 现在，系统可以处理一系列临时文件，而不需要进行任何磁盘 I/O。如果内存中指针块满了，就写入磁盘，半满的指针块从磁盘中读入。这里的思想是：要保持磁盘上的大多数指针块为满的状态（减少磁盘的使用），但是在内存中保留了一个半满的指针块。这样，就可以既处理文件的创建又同时可以处理文件的删除操作，而不会为空闲表进行磁盘 I/O。 对于位图，会在内存中只保留一个块，只有在该块满了或空了的情形下，才到磁盘上取另一个块。通过在位图的单一块上进行所有的分配操作，磁盘块会紧密的聚集在一起，从而减少了磁盘臂的移动。由于位图是一种固定大小的数据结构，所以如果内核是分页的，就可以把位图放在虚拟内存中，在需要时将位图的页面调入。 磁盘配额为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种磁盘配额(enforcing disk quotas)的机制。系统管理员为每个用户分配最大的文件和块分配，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。 在用户打开一个文件时，操作系统会找到文件属性和磁盘地址，并把它们送入内存中的打开文件表。其中一个属性告诉文件所有者是谁。任何有关文件的增加都会记到所有者的配额中。 第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。 当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加硬限制和软限制的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。 什么是硬限制和软限制？硬限制是软限制的上限。软限制是为会话或进程实际执行的限制。这允许管理员（或用户）将硬限制设置为允许它们希望允许的最大使用上限。然后，其他用户和进程可以根据需要使用软限制将其资源使用量自限制到更低的上限。 当一个用户尝试登陆，系统将检查配额文件以查看用户是否超出了文件数量或磁盘块数量的软限制。如果违反了任一限制，则会显示警告，保存的警告计数减 1，如果警告计数为 0 ，表示用户多次忽略该警告，因而将不允许该用户登录。要想再得到登录的许可，就必须与系统管理员协商。 如果用户在退出系统时消除所超过的部分，他们就可以再一次终端会话期间超过其软限制，但无论什么情况下都不会超过硬限制。 文件系统备份文件系统的毁坏要比计算机的损坏严重很多。无论是硬件还是软件的故障，只要计算机文件系统被破坏，要恢复起来都是及其困难的，甚至是不可能的。因为文件系统无法抵御破坏，因而我们要在文件系统在被破坏之前做好数据备份，但是备份也不是那么容易，下面我们就来探讨备份的过程。 许多人认为为文件系统做备份是不值得的，并且很浪费时间，直到有一天他们的磁盘坏了，他们才意识到事情的严重性。相对来说，公司在这方面做的就很到位。磁带备份主要要处理好以下两个潜在问题中的一个 从意外的灾难中恢复 这个问题主要是由于外部条件的原因造成的，比如磁盘破裂，水灾火灾等。 从错误的操作中恢复 第二个问题通常是由于用户意外的删除了原本需要还原的文件。这种情况发生的很频繁，使得 Windows 的设计者们针对删除命令专门设计了特殊目录，这就是回收站(recycle bin)，也就是说，在删除文件的时候，文件本身并不真正从磁盘上消失，而是被放置到这个特殊目录下，等以后需要的时候可以还原回去。文件备份更主要是指这种情况，能够允许几天之前，几周之前的文件从原来备份的磁盘进行还原。 做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要备份整个文件还是仅备份一部分呢？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。 其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种增量转储(incremental dumps) 的思想。最简单的增量转储的形式就是周期性的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。 周期性：比如一周或者一个月 稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为最近的全面转储先要全部恢复，随后按逆序进行增量转储。为了方便恢复，人们往往使用更复杂的转储模式。 第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。 第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的瞬时快照，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。 磁盘转储到备份磁盘上有两种方案：物理转储和逻辑转储。物理转储(physical dump) 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。 第二个需要考虑的是坏块的转储。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些坏块(bad blocks)。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。 然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的文件来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。那么此文件是完全不可读的。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。 Windows 系统有分页文件(paging files)和休眠文件(hibernation files)。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。 物理转储和逻辑转储物理转储的主要优点是简单、极为快速（基本上是以磁盘的速度运行），缺点是全量备份，不能跳过指定目录，也不能增量转储，也不能恢复个人文件的请求。因此绝大多数情况下不会使用物理转储，而使用逻辑转储。 逻辑转储(logical dump)从一个或几个指定的目录开始，递归转储自指定日期开始后更改的文件和目录。因此，在逻辑转储中，转储磁盘上有一系列经过仔细识别的目录和文件，这使得根据请求轻松还原特定文件或目录。 既然逻辑转储是最常用的方式，那么下面就让我们研究一下逻辑转储的通用算法。此算法在 UNIX 系统上广为使用，如下图所示 待转储的文件系统，其中方框代表目录，圆圈代表文件。黄色的项目表是自上次转储以来修改过。每个目录和文件都被标上其 inode 号。 此算法会转储位于修改文件或目录路径上的所有目录（也包括未修改的目录），原因有两个。第一是能够在不同电脑的文件系统中恢复转储的文件。通过这种方式，转储和重新存储的程序能够用来在两个电脑之间传输整个文件系统。第二个原因是能够对单个文件进行增量恢复。 逻辑转储算法需要维持一个inode为索引的位图(bitmap)，每个 inode 包含了几位。随着算法的进行，位图中的这些位会被设置或清除。算法的执行分成四个阶段。第一阶段从起始目录（本例为根目录）开始检查其中所有的目录项。对每一个修改过的文件，该算法将在位图中标记其 inode。算法还会标记并递归检查每一个目录（不管是否修改过）。 在第一阶段结束时，所有修改过的文件和全部目录都在位图中标记了，如下图所示 理论上来说，第二阶段再次递归遍历目录树，并去掉目录树中任何不包含被修改过的文件或目录的标记。本阶段执行的结果如下 注意，inode 编号为 10、11、14、27、29 和 30 的目录已经被去掉了标记，因为它们所包含的内容没有修改。它们也不会转储。相反，inode 编号为 5 和 6 的目录本身尽管没有被修改过也要被转储，因为在新的机器上恢复当日的修改时需要这些信息。为了提高算法效率，可以将这两阶段的目录树遍历合二为一。 现在已经知道了哪些目录和文件必须被转储了，这就是上图 b 中标记的内容，第三阶段算法将以节点号为序，扫描这些 inode 并转储所有标记为需转储的目录，如下图所示 为了进行恢复，每个被转储的目录都用目录的属性（所有者、时间）作为前缀。 最后，在第四阶段，上图中被标记的文件也被转储，同样，由其文件属性作为前缀。至此，转储结束。 从转储磁盘上还原文件系统非常简单。一开始，需要在磁盘上创建空文件系统。然后恢复最近一次的完整转储。由于磁带上最先出现目录，所以首先恢复目录，给出文件系统的框架(skeleton)，然后恢复文件系统本身。在完整存储之后是第一次增量存储，然后是第二次重复这一过程，以此类推。 尽管逻辑存储十分简单，但是也会有一些棘手的问题。首先，既然空闲块列表并不是一个文件，那么在所有被转储的文件恢复完毕之后，就需要从零开始重新构造。 另外一个问题是关于链接。如果文件链接了两个或者多个目录，而文件只能还原一次，那么并且所有指向该文件的目录都必须还原。 还有一个问题是，UNIX 文件实际上包含了许多空洞(holes)。打开文件，写几个字节，然后找到文件中偏移了一定距离的地址，又写入更多的字节，这么做是合法的。但两者之间的这些块并不属于文件本身，从而也不应该在其上进行文件转储和恢复。 最后，无论属于哪一个目录，特殊文件，命名管道以及类似的文件都不应该被转储。 文件系统的一致性影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种不一致(inconsistent)的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。 为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有fsck；Windows有sfc，每当引导系统时（尤其是在崩溃后），都可以运行该程序。 可以进行两种一致性检查：块的一致性检查和文件的一致性检查。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。 然后检验程序使用原始设备读取所有的 inode，忽略文件的结构，只返回从零开始的所有磁盘块。从 inode 开始，很容易找到文件中的块数量。每当读取一个块时，该块在第一个表中的计数器 + 1，应用程序会检查空闲块或者位图来找到没有使用的块。空闲列表中块的每次出现都会导致其在第二表中的计数器增加。 如果文件系统一致，则每一个块或者在第一个表计数器为 1，或者在第二个表计数器中为 1，如下图所示 但是当系统崩溃后，这两张表可能如下所示 其中，磁盘块 2 没有出现在任何一张表中，这称为块丢失(missing block)。尽管块丢失不会造成实际的损害，但它的确浪费了磁盘空间，减少了磁盘容量。块丢失的问题很容易解决，文件系统检验程序把他们加到空闲表中即可。 有可能出现的另外一种情况如下所示 其中，块 4 在空闲表中出现了 2 次。这种解决方法也很简单，只要重新建立空闲表即可。 最糟糕的情况是在两个或者多个文件中出现同一个数据块，如下所示 比如上图的磁盘块 5，如果其中一个文件被删除，块 5 会被添加到空闲表中，导致一个块同时处于使用和空闲的两种状态。如果删除这两个文件，那么在空闲表中这个磁盘块会出现两次。 文件系统检验程序采取的处理方法是，先分配一磁盘块，把块 5 中的内容复制到空闲块中，然后把它插入到其中一个文件中。这样文件的内容未改变，虽然这些内容可以肯定是不对的，但至少保证了文件的一致性。这一错误应该报告给用户，由用户检查受检情况。 除了检查每个磁盘块计数的正确性之外，文件系统还会检查目录系统。这时候会用到一张计数器表，但这时是一个文件（而不是一个块）对应于一个计数器。程序从根目录开始检验，沿着目录树向下查找，检查文件系统的每个目录。对每个目录中的文件，使其计数 + 1。 注意，由于存在硬连接，一个文件可能出现在两个或多个目录中。而遇到符号链接是不计数的，不会对目标文件的计数器 + 1。 在检验程序完成后，会得到一张由 inode 索引的表，说明每个文件和目录的包含关系。检验程序会将这些数字与存储在文件 inode 中的链接数目做对比。如果 inode 节点的链接计数大户目录项个数，这时即使所有文件从目录中删除，这个计数仍然不是 0 ，inode 不会被删除。这种错误不严重，却因为存在不属于任何目录的文件而浪费了磁盘空间。 另一种错误则是潜在的风险。如果同一个文件链接两个目录项，但是 inode 链接计数只为 1，如果删除了任何一个目录项，对应 inode 链接计数变为 0。当 inode 计数为 0 时，文件系统标志 inode 为未使用，并释放全部的块。这会导致其中一个目录指向一未使用的 inode，而很有可能其块马上就被分配给其他文件。 文件系统性能访问磁盘的效率要比内存慢的多，是时候又祭出这张图了 从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式 高速缓存最常用的减少磁盘访问次数的技术是使用块高速缓存(block cache)或者缓冲区高速缓存(buffer cache)。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。 管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过高速缓存来完成。 高速缓存的操作如下图所示 由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。 如果高速缓存已满，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似，所有常用的页面置换算法我们之前已经介绍过，如果有不熟悉的小伙伴可以参考 内存：你跑慢点行不行？CPU：跑慢点你养我吗？内存：我不管！ FIFO 算法、第二次机会算法、LRU 算法、时钟算法、老化算法等。它们都适用于高速缓存。 块提前读第二个明显提高文件系统的性能是，在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。 当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。 减少磁盘臂运动高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。 不过，即使采用空闲表，也可以使用块簇技术。即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有 512 个字节，有可能系统采用 1 KB 的块（2 个扇区），但却按每 2 块（4 个扇区）一个单位来分配磁盘存储区。这和 2 KB 的磁盘块并不相同，因为在高速缓存中它仍然使用 1 KB 的块，磁盘与内存数据之间传送也是以 1 KB 进行，但在一个空闲的系统上顺序读取这些文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方法的变体。在分配块时，系统尽量把一个文件中的连续块存放在同一个柱面上。 在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：一次是访问 inode，一次是访问块。通常情况下，inode 的放置如下图所示 其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。 一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表，如上图 b 所示。 当然，只有在磁盘中装有磁盘臂的情况下，讨论寻道时间和旋转时间才是有意义的。现在越来越多的电脑使用固态硬盘(SSD)，对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问和顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。但是也引发了新的问题。 磁盘碎片整理在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。 磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序defrag就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。 磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。 相关参考： https://zhuanlan.zhihu.com/p/41358013what-is-an-inodewhat-is-fragmentation-defragmentationfree-space-management-in-operating-system…原文链接https://juejin.im/post/5e7aea03f265da57616abd46","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"操作系统","slug":"Dev/操作系统","permalink":"https://voiue.github.io/blog/categories/Dev/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"https://voiue.github.io/blog/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"如何请教别人","slug":"how-to-get-help","date":"2020-03-22T08:58:10.000Z","updated":"2020-03-22T08:58:10.000Z","comments":true,"path":"blog/2020-03-22-how-to-get-help/","link":"","permalink":"https://voiue.github.io/blog/2020-03-22-how-to-get-help/","excerpt":"合适的自我介绍上次有一个人在一个线下分享会后一直拉着我问问题，我一直忍着没有问他是谁，后来问了太多，我实在受不了了，我问他：你是谁呀，为什么好像和我很熟的样子？他说：哦，我是一个 iOS 开发，你没必要记住我的名字。 类似的情形出现过多次，还有一些人把名字故意取成很个性的，完全无法记住的 emoji 表情或者符号，也不做自我介绍，我完全无法记住这些人。 合适的自我介绍为什么重要呢？因为它代表着一种尊重和平等。我义务解答问题没有关系，但是我即使完全不求回报，也希望我到底帮助的是谁。这个提问者的名字，毕业学校，工作单位，以及他的问题，都会给我带来记忆。 这其实是基本的礼仪，看看那些著名演讲或者发布会的提问环节吧，提问者都会先自我介绍一番。","text":"合适的自我介绍上次有一个人在一个线下分享会后一直拉着我问问题，我一直忍着没有问他是谁，后来问了太多，我实在受不了了，我问他：你是谁呀，为什么好像和我很熟的样子？他说：哦，我是一个 iOS 开发，你没必要记住我的名字。 类似的情形出现过多次，还有一些人把名字故意取成很个性的，完全无法记住的 emoji 表情或者符号，也不做自我介绍，我完全无法记住这些人。 合适的自我介绍为什么重要呢？因为它代表着一种尊重和平等。我义务解答问题没有关系，但是我即使完全不求回报，也希望我到底帮助的是谁。这个提问者的名字，毕业学校，工作单位，以及他的问题，都会给我带来记忆。 这其实是基本的礼仪，看看那些著名演讲或者发布会的提问环节吧，提问者都会先自我介绍一番。 在吗？「在吗」，基本上以这种方式和我打招呼的提问者，通常都是令我感受非常差的。因为这意味着：我看到了必须回答在，我回答在了之后，还必须立即响应他后续的问题。 同学们，现在连 QQ 都取消在线状态了，有什么事情不能用留言的方式解决呢？说白了，还不是提问者自我为中心，他们希望偷懒，连在请教别人这件事情上，他们都希望不要浪费自己的打字 —- 如果对方不在，我就可以不用打字提问题了，免得提了别人不答。 但是，如果你这么不尊重对方的时间，又何来让对方免费的、在线互动地和你一问一答帮助你解决你的问题？ 凭什么？ 不会提问很多人都描述不清楚自己的问题，需要我来帮助他们一点点来弄清楚他到底想问什么。我举一个例子： 上次一个人在群里面问：有谁知道怎么更新 Mac 的 Numbers 吗？我以为他是一个 Mac 新手，于是我说：打开 Mac 的 App Store 应用，在 Updates 里面找到 Numbers，然后点 “update” 按钮。 结果他说：我知道，但是我为什么点了没有反应呢？我这个时候才发现，他其实是想问为什么 App Store 响应慢。于是我推荐他设置了一些加速下载的 DNS。 因为这个人我认识，所以我继续在帮助他。但是其实他给了我相当糟糕的体验。因为我在帮助他的时候，我在努力把解决方案说清楚，但是他懒得连问题都不想说清楚。或者，他认为只要他说「不会更新某个应用」，就表示的是 AppStore 卡顿，而不是别的意思。 提傻问题对于 iOS 开发者来说，向我提的最傻的两类问题是：审核问题和具体的 API 问题。 例如： 唐老师，麻烦看看：Your app uses public APIs in an unapproved manner, which does not comply with section 3.3.1 of the Apple Developer Program License Agreement. Specifically, your app was found to use “canOpenURL:” to scan for an arbitrarily large list of apps. Use of this method for generalized app detection is not appropriate. Since there is no accurate way of predicting how an API may be modified and what effects those modifications may have, Apple does not permit unapproved uses of public APIs in App Store apps. 审核的问题大部分情况下英文的审核意见已经说得非常清楚了，我实在没有什么动力做翻译。 另外如果是问 iOS 开发某个特定细节 API 的使用问题，其实是没有哪个人能够对苹果的所有 API 都了解得那么清楚的，与其问我，还不如用 Google 搜索或者查文档更好。 扔代码上来就扔一段代码，然后说：照着你的博客写的，为什么出问题了呢？好象我写了免费的博客，就有义务帮他找 Bug 一样。 当然，扔代码的还算好的，还有扔过来一个 GitHub 工程的，说：「麻烦帮忙看看」，这真的是要让我吐血。。。 情绪方面的问题巧哥，我 iOS 找不到工作怎么办？ 巧哥，我希望从 xx 方向换到 iOS 方向，你怎么看？ 巧哥，我的老大对我很差，你说我应不应该换一份工作？ 大部分这些问题，我其实也只能说：努力努力再努力，或者选择沉默。因为我确实也帮不上什么忙。如果需要找人安抚心情的话，找好朋友可能更适合。 不会感谢说句谢谢是最最基本的。 如果你的问题花费了别人大量的时间，例如几个小时或者一天，那么请别人吃个饭也是正常的。大家都是成年人，倒不是说要多功利，这仅是相互的尊重。 我现在如果有很困扰的问题要请教别人，简单几句能说清楚的，我会给别人微信留言说清楚，然后附一个 66 元的红包。简单几句说不清楚的，我会和别人约个时间当面请教，然后顺便请别人吃顿饭。外地的朋友，实在不知道如何感谢，我会说：希望以后如果需要我的时候，能够找我提供帮助。 我的困境最后分享一下我的困境。 我每天收到几十个求助的问题，但是我精力非常有限，对于我来说时间优先级肯定是：首先完成工作上的事情、然后完成家里的事情、然后是娱乐和学习、然后是和朋友聊天交流、然后是休息，如果上面这些做完了，偶尔有精力，正好遇上了会提问，提的问题又是经过深入思考，而恰好我又知道答案，答案又恰好不会花费特别多的时间，那么我才有可能回答。 当然，如果是朋友的问题，我会把这个看作我处理社交关系的一件事情，那我可能就会放弃一些休息或学习时间来帮助朋友，因为或许有一天我也会需要朋友的帮助，同时朋友的成功也会给我带来开心。 希望这篇文章能够教会大家这个简单的「换位思考」法则。 谢谢。 原文链接：http://blog.devtang.com/2017/03/04/how-to-get-help","categories":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/categories/others/"}],"tags":[{"name":"智慧","slug":"智慧","permalink":"https://voiue.github.io/blog/tags/%E6%99%BA%E6%85%A7/"}]},{"title":"什么是爱 - 读《少有人走的路》","slug":"what-is-love","date":"2020-03-22T08:08:44.000Z","updated":"2020-03-22T08:08:44.000Z","comments":true,"path":"blog/2020-03-22-what-is-love/","link":"","permalink":"https://voiue.github.io/blog/2020-03-22-what-is-love/","excerpt":"引言爱是什么？这或许是一个永恒的话题。我很少从学校的传统教育以及家庭教育中获得这方面的知识。 我小的时候对于爱的解释，印象中的故事竟然都是来自是电影：一部是 《泰坦尼克号》，另一部是 《真爱至上》。《泰坦尼克号》的男主 Jack 为了心爱的人，放弃自己生存的机会，让我以为爱是一种牺牲。而在大学时看的《真爱至上》，电影中的 10 个故事，讲了各种各样爱的故事，有小朋友之间的爱，有情侣之间的爱，更有同性之间的爱。电影最后的一句台词给爱下了一个更广泛的定义：「Love actually is everything.」","text":"引言爱是什么？这或许是一个永恒的话题。我很少从学校的传统教育以及家庭教育中获得这方面的知识。 我小的时候对于爱的解释，印象中的故事竟然都是来自是电影：一部是 《泰坦尼克号》，另一部是 《真爱至上》。《泰坦尼克号》的男主 Jack 为了心爱的人，放弃自己生存的机会，让我以为爱是一种牺牲。而在大学时看的《真爱至上》，电影中的 10 个故事，讲了各种各样爱的故事，有小朋友之间的爱，有情侣之间的爱，更有同性之间的爱。电影最后的一句台词给爱下了一个更广泛的定义：「Love actually is everything.」 我现在 30 多岁了，结婚了，也有了小孩，有些时候我觉得爱就一种亲情，但是又说不清楚。因为家庭生活中其实会有各种琐事，各种争吵，有些时候也会困惑，不知该如何处理。 还是要感谢李笑来老师，他推荐的这本 《少有人走的路》，用更详尽的篇章，从一个学术的角度讨论了什么是爱。这本书的作者斯科特·派克是一个心理医生，在书中的第二部分，作者详尽分析了各种关于爱的行为，告诉我们什么样的行为是爱，什么样的行为不是爱。 爱的定义作者从他的角度，给爱下了如下的定义： 爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。 这个定义非常有意思，完全不同于我们以前了解到的爱的描述，我们从中可以看到两个特征： 爱可以使双方都获得心智成熟。这就像是杨过和小龙女的「双修」一样，是一种共同进步的互利行为。 爱是一种自我完善的意愿。我们都希望通过它获得心智的成熟，人格的独立。 爱的误解弄清楚什么是爱是很难的，但是反过来，弄清楚什么不是爱相对来说容易一些，所以本书中分析了四种常见的错误的「爱」，分别是：坠入情网、依赖性、自我牺牲、（仅有）感觉。 坠入情网坠入情网不是爱。这可能是最常见的误区吧。年轻时的我们，由于荷尔蒙的分泌，对异性产生好感，进一步渴望和异性交往，然后坠入情网，最终啪啪啪以及结婚生子。作者认为坠入情网不是爱的核心理由是：坠入情网的 “爱” 不会持续太久，不管爱的对象是谁，早晚我们都会从情网的羁绊中 “爬出”。有一个词叫「七年之痒」，其实也是说这个道理。坠入情网这种爱更像是一种冲动和激情，随着时间会慢慢消退。 刚刚说到爱需要使双方心智变得成熟。但是坠入情网，惟一的好处就是消除寂寞。即便经由婚姻，使这一功用得以延长，也无助于心智的成熟。 悲观一点说，坠入情网其实是一种受人类本能控制的，来自我们 DNA 中繁衍需求的刺激。它的意义在于增加人类生殖机会，促进物种繁衍和生存。但是坠入情网其实是产生真正的爱的一个很好的媒介，后面我们再详细讨论。 依赖性依赖性不是爱。我们会见到各种依赖性的行为，比如小孩对父母的依赖，妻子对丈夫的依赖，甚至父母对小孩也有依赖。一些小孩长大之后离开家门，父母会特别难受，但都会调整接受。如果一个父母因为对小孩有依赖，阻止孩子去外地上学或者工作，那么这种依赖性就不是爱了，因为它其实对孩子的发展并不有利。 反过来，父母的这种行为对于自己也是不利的，因为这也体现出他们的人格并不独立。总有一天，孩子还是会追求自由与不受控制，到时候父母也容易产生心理问题。 所以，过度的依赖行为其实使孩子和父母都丧失了人格的独立性，是不利于心智发展的，所以不是爱。 自我牺牲自我牺牲不是爱。我们常常见到这样的行为：爷爷奶奶给孙子孙女买特别多的玩具，什么事情都惯着孩子，为了满足孩子的各种需求，甚至会牺牲一些自己的东西，例如金钱，健康，时间。这些牺牲如果是利于孩子身心发展的，那就是爱；如果最终使得孩子产生很坏的生活习惯和沟通方式，那么不但不是爱，还是一种伤害。 所以，自我牺牲的付出不一定是爱，还得看付出之后的效果是怎样的。 感觉爱，不是感觉。爱是一种行为，而不是一种感觉。如果你整天只是把爱挂在嘴上，但是并没有任何行为付出，那么其实这就不是爱。作者在书中指出，一些家庭的父母并不关心孩子的身心，只知道通过简单粗暴的方式来教育孩子，嘴上说是爱孩子，其实根本就没有付出真正上的行为。 作为父母，把孩子喂饱，提供教育相关的资金支持，仅仅是尽到了最基本的义务。而和孩子一起玩耍，交流，解决孩子的困难，纠正孩子的错误，关注和帮助孩子成长，才是更重要的行为。 如何爱那么，我们应该如何去爱呢？作者介绍了一些原则： 首先，爱与不爱最显著的区别之一，在于当事人的意识思维和潜意识思维的目标是否一致。 第二，爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。爱，能够帮助他人进步，也会使自我更加成熟。 第三，真正意义上的爱，既是爱自己，也是爱他人。爱，可以使自我和他人感觉到进步。不爱自己的人，绝不可能去爱他人。 第四，爱是自我完善，也是帮助他人完善。它意味着持续努力，超越自我界限。 在以上原则下，作者提供了一些实践的办法： 关注：爱最重要的体现形式，就是关注。体现关注，一种最常见、最重要的方式，就是 “倾听”。 自律：自律，是将爱转化为实际行动的过程。这里面涉及情绪的控制，我们既不能过于放纵情绪，也不能过于压抑情绪。 独立：爱的重要特征之一，在于爱者与被爱者都不是对方的附属品。付出真爱的人，应该永远把爱的对象视为独立的个体，永远尊重对方的独立和成长。 最终，如果我们这么做，就会产生精神贯注的现象： 真正的爱，是自我完善的特殊体验，跟自我界限有着密切关联。陶醉在爱的情感里，我们感觉灵魂无限延伸，奔向心爱的对象。我们渴望给对方滋养，我们希望对方成长。被自我界限之外的对象吸引，迫使我们产生冲动，想把激情乃至生命献给对方，心理学家把这样的激情状态，称为 “精神贯注”。我们贯注的对象，正是所爱的人或所爱的事物。 爱的风险即便我们做到了真正的爱，但是也会面临一些风险： 死亡的风险：精神贯注的代价之一，似乎是或早或晚你都要因为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中许多事物，包括子女、婚姻、性爱、晋升、友谊，但惟有这些事物，才能够使人生丰富多彩。 独立的风险：我们必须不再完全依赖任何人，成为一个人格独立的个体。 承诺的风险：我们需要具有责任感，承诺与爱相关的义务。 冲突的风险：我们需要面临与所爱的人的冲突，并且在冲突发生时，以帮助对方心智成熟作为出发点，来解决冲突。只有以爱为出发点，投入全部的情感，做出真挚的承诺，才能更好地滋养对方的心灵。例如，父母和孩子发生冲突时，首先应该自我检讨，认清自己的价值观，才能采取正确的方式，才能恰当地教育孩子。 关于死亡的风险我深有感触。我现在 30 岁了，整个身体都不像 20 多岁那样有活力了，加班太晚会感觉特别累。我相信有一天，我会发现自己真的老了，不光精力大不如从前，可能视力，听力都退化了，那个时候我需要放弃很多年轻时获得的成就，但是这就是人生，所有人都逃避不了死亡。 关于冲突，我也有一些体会。我有时候在家里会抱怨一些事情，后来我发现，这除了让我和家人产生矛盾以外，完全无助于解决任何问题。所以我开始反思我是否应该用更加有效的方式来和家人沟通，试过几次之后，我发现家人也这些事情也有自己的看法。在冲突发生时，用诚实和谦逊的态度先自我反省，再进一步沟通，最终大家会学会到更好的相处方式。这确实也让我的心智更加成熟了，对情绪的控制（自律能力）更强了。 总结《少有人走的路》 让我对爱有了更客观的认识，一句话总结：爱就是一种精神贯注的行为，它可以使自己和对方的心智都成长起来，从而获得健全的人格。 但是作者也坦诚地说，这样的定义还是无法解释很多爱的行为，不过对于我来说，已经学到很多了，推荐给大家。以下是本书第二部分的思维导图总结： 原文链接：http://blog.devtang.com/2016/09/16/what-is-love","categories":[{"name":"读书","slug":"读书","permalink":"https://voiue.github.io/blog/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://voiue.github.io/blog/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"理解 iOS 的内存管理","slug":"ios-memory-management","date":"2020-03-22T04:45:10.000Z","updated":"2020-03-22T04:45:10.000Z","comments":true,"path":"blog/2020-03-22-ios-memory-management/","link":"","permalink":"https://voiue.github.io/blog/2020-03-22-ios-memory-management/","excerpt":"远古时代的故事那些经历过手工管理内存（MRC）时代的人们，一定对 iOS 开发中的内存管理记忆犹新。那个时候大约是 2010 年，国内 iOS 开发刚刚兴起，tinyfool 大叔的大名已经如雷贯耳，而我还是一个默默无闻的刚毕业的小子。那个时候的 iOS 开发过程是这样的： 我们先写好一段 iOS 的代码，然后屏住呼吸，开始运行它，不出所料，它崩溃了。在 MRC 时代，即使是最牛逼的 iOS 开发者，也不能保证一次性就写出完美的内存管理代码。于是，我们开始一步一步调试，试着打印出每个怀疑对象的引用计数（Retain Count），然后，我们小心翼翼地插入合理的 retain 和 release 代码。经过一次又一次的应用崩溃和调试，终于有一次，应用能够正常运行了！于是我们长舒一口气，露出久违的微笑。","text":"远古时代的故事那些经历过手工管理内存（MRC）时代的人们，一定对 iOS 开发中的内存管理记忆犹新。那个时候大约是 2010 年，国内 iOS 开发刚刚兴起，tinyfool 大叔的大名已经如雷贯耳，而我还是一个默默无闻的刚毕业的小子。那个时候的 iOS 开发过程是这样的： 我们先写好一段 iOS 的代码，然后屏住呼吸，开始运行它，不出所料，它崩溃了。在 MRC 时代，即使是最牛逼的 iOS 开发者，也不能保证一次性就写出完美的内存管理代码。于是，我们开始一步一步调试，试着打印出每个怀疑对象的引用计数（Retain Count），然后，我们小心翼翼地插入合理的 retain 和 release 代码。经过一次又一次的应用崩溃和调试，终于有一次，应用能够正常运行了！于是我们长舒一口气，露出久违的微笑。 是的，这就是那个年代的 iOS 开发者，通常情况下，我们在开发完一个功能后，需要再花好几个小时，才能把引用计数管理好。 苹果在 2011 年的时候，在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。 在 ARC 刚刚出来的时候，业界对此黑科技充满了怀疑和观望，加上现有的 MRC 代码要做迁移本来也需要额外的成本，所以 ARC 并没有被很快接受。直到 2013 年左右，苹果认为 ARC 技术足够成熟，直接将 macOS（当时叫 OS X）上的垃圾回收机制废弃，从而使得 ARC 迅速被接受。 2014 年的 WWDC 大会上，苹果推出了 Swift 语言，而该语言仍然使用 ARC 技术，作为其内存管理方式。 为什么我要提这段历史呢？就是因为现在的 iOS 开发者实在太舒服了，大部分时候，他们根本都不用关心程序的内存管理行为。但是，虽然 ARC 帮我们解决了引用计数的大部分问题，一些年轻的 iOS 开发者仍然会做不好内存管理工作。他们甚至不能理解常见的循环引用问题，而这些问题会导致内存泄漏，最终使得应用运行缓慢或者被系统终止进程。 所以，我们每一个 iOS 开发者，需要理解引用计数这种内存管理方式，只有这样，才能处理好内存管理相关的问题。 什么是引用计数引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 和 Swift 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。 为了更形象一些，我们再来看一段 Objective-C 的代码。新建一个工程，因为现在默认的工程都开启了自动的引用计数 ARC（Automatic Reference Count)，我们先修改工程设置，给 AppDelegate.m 加上 -fno-objc-arc 的编译参数（如下图所示），这个参数可以启用手工管理引用计数的模式。 然后，我们在中输入如下代码，可以通过 Log 看到相应的引用计数的变化。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@\"Reference Count = %u\", [object retainCount]); NSObject *another = [object retain]; NSLog(@\"Reference Count = %u\", [object retainCount]); [another release]; NSLog(@\"Reference Count = %u\", [object retainCount]); [object release]; // 到这里时，object 的内存被释放了 return YES;&#125; 运行结果： 123Reference Count &#x3D; 1Reference Count &#x3D; 2Reference Count &#x3D; 1 对 Linux 文件系统比较了解的同学可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于我们这里的 retain)，当删除一个文件时（相当于我们这里的 release)，系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 我们为什么需要引用计数从上面那个简单的例子中，我们还看不出来引用计数真正的用处。因为该对象的生命期只是在一个函数内，所以在真实的应用场景下，我们在函数内使用一个临时的对象，通常是不需要修改它的引用计数的，只需要在函数返回前将该对象销毁即可。 引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。我们举一个具体的例子： 假如对象 A 生成了一个对象 M，需要调用对象 B 的某一个方法，将对象 M 作为参数传递过去。在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么对象 A 就需要在对象 B 不再需要对象 M 的时候，将对象 M 销毁。但对象 B 可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象 A 在调用完对象 B 之后，马上就销毁参数对象 M，然后对象 B 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。如下图所示： 我们另外还有一种办法，就是对象 A 在构造完对象 M 之后，始终不销毁对象 M，由对象 B 来完成对象 M 的销毁工作。如果对象 B 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 AB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在对象 A 中，释放在对象 B 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象 B 需要再向对象 C 传递对象 M，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 不要向已经释放的对象发送消息有些同学想测试当对象释放时，其 retainCount 是否变成了 0，他们的试验代码如下： 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@\"Reference Count = %u\", [object retainCount]); [object release]; NSLog(@\"Reference Count = %u\", [object retainCount]); return YES;&#125; 但是，如果你真的这么实验，你得到的输出结果可能是以下这样： 12Reference Count &#x3D; 1Reference Count &#x3D; 1 我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。 那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。 拿我们之前提到的 Linux 文件系统举列，Linux 文件系统下删除一个文件，也不是真正的将文件的磁盘区域进行抹除操作，而只是删除该文件的索引节点号。这也和引用计数的内存回收方式类似，即回收时只做标记，并不抹除相关的数据。 ARC 下的内存管理问题ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外还有 10% 内存管理，是需要开发者自己处理的，这主要就是与底层 Core Foundation 对象交互的那部分，底层的 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。 对于 ARC 盲目依赖的 iOS 新人们，由于不知道引用计数，他们的问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要自己手工管理它们的引用计数时，显得一筹莫展。 循环引用（Reference Cycle）问题引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 主动断开循环引用解决循环引用问题主要有两个办法，第一个办法是我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。例如在我开源的 YTKNetwork 网络库中，网络请求的回调 block 是被持有的，但是如果这个 block 中又存在对于 View Controller 的引用，就很容易产生从循环引用，因为： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self，所以持有了 Controller 解决办法就是，在网络请求结束后，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。相关的代码见： 1234567// https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKBaseRequest.m// 第 147 行：- (void)clearCompletionBlock &#123; // 主动释放掉对于 block 的引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存（这通常与具体的业务逻辑相关），所以这种解决方法并不常用，更常见的办法是使用弱引用 (weak reference) 的办法。 使用弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。举个例子来说，两个 ViewController A 和 B，ViewController A 需要弹出 ViewController B，让用户输入一些内容，当用户输入完成后，ViewController B 需要将内容返回给 ViewController A。这个时候，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 相互引用对方造成循环引用问题，如下所示： 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： 我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 使用 Xcode 检测循环引用Xcode 的 Instruments 工具集可以很方便的检测循环引用。为了测试效果，我们在一个测试用的 ViewController 中填入以下代码，该代码中的 firstArray 和 secondArray 相互引用了对方，构成了循环引用。 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; NSMutableArray *firstArray = [NSMutableArray array]; NSMutableArray *secondArray = [NSMutableArray array]; [firstArray addObject:secondArray]; [secondArray addObject:firstArray];&#125; 在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。如下图 这个时候 iOS 模拟器会运行起来，我们在模拟器里进行一些界面的切换操作。稍等几秒钟，就可以看到 Instruments 检测到了我们的这次循环引用。Instruments 中会用一条红色的条来表示一次内存泄漏的产生。如下图所示： 我们可以切换到 Leaks 这栏，点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。这样我们就可以非常方便地找到循环引用的对象了。 Core Foundation 对象的内存管理下面我们就来简单介绍一下对底层 Core Foundation 对象的内存管理。底层的 Core Foundation 对象，在创建时大多以 XxxCreateWithXxx 这样的方式创建，例如： 12345// 创建一个 CFStringRef 对象CFStringRef str= CFStringCreateWithCString(kCFAllocatorDefault, “hello world\", kCFStringEncodingUTF8);// 创建一个 CTFontRef 对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@\"ArialMT\", fontSize, NULL); 对于这些对象的引用计数的修改，要相应的使用 CFRetain 和 CFRelease 方法。如下所示： 1234567// 创建一个 CTFontRef 对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@\"ArialMT\", fontSize, NULL);// 引用计数加 1CFRetain(fontRef);// 引用计数减 1CFRelease(fontRef); 对于 CFRetain 和 CFRelease 两个方法，读者可以直观地认为，这与 Objective-C 对象的 retain 和 release 方法等价。 所以对于底层 Core Foundation 对象，我们只需要延续以前手工管理引用计数的办法即可。 除此之外，还有另外一个问题需要解决。在 ARC 下，我们有时需要将一个 Core Foundation 对象转换成一个 Objective-C 对象，这个时候我们需要告诉编译器，转换过程中的引用计数需要做如何的调整。这就引入了 bridge 相关的关键字，以下是这些关键字的说明： __bridge: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_retained：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_transfer：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法。 我们根据具体的业务逻辑，合理使用上面的 3 种转换关键字，就可以解决 Core Foundation 对象与 Objective-C 对象相对转换的问题了。 总结在 ARC 的帮助下，iOS 开发者的内存管理工作已经被大大减轻，但是我们仍然需要理解引用计数这种内存管理方式的优点和常见问题，特别要注意解决循环引用问题。对于循环引用问题有两种主要的解决办法，一是主动断开循环引用，二是使用弱引用的方式避免循环引用。对于 Core Foundation 对象，由于不在 ARC 管理之下，我们仍然需要延续以前手工管理引用计数的办法。 在调试内存问题时，Instruments 工具可以很好地对我们进行辅助，善用 Instruments 可以节省我们大量的调试时间。 愿每一个 iOS 开发者都可以掌握 iOS 的内存管理技能。 原文链接：http://blog.devtang.com/2016/07/30/ios-memory-management","categories":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/categories/others/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://voiue.github.io/blog/tags/iOS/"},{"name":"内存管理","slug":"内存管理","permalink":"https://voiue.github.io/blog/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"作为码农，我们为什么要写作","slug":"why-we-need-write","date":"2020-03-21T10:07:11.000Z","updated":"2020-03-21T10:07:11.000Z","comments":true,"path":"blog/2020-03-21-why-we-need-write/","link":"","permalink":"https://voiue.github.io/blog/2020-03-21-why-we-need-write/","excerpt":"在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。 不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。","text":"在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。 不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。 提高自己对知识的掌握层次美国教育心理学家 Bloom 将知识认知分为了两个维度，其中认知历程维度又分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。 对于写作者来说，在写作过程中，因为需要对知识进行精确地表述，常常要对知识的细节再次的探索。在这个过程中，写作者可能会发现自己的观点不清晰的地方，通过二次学习，使自己的理解更加完善。写作者也可能会发现自己观点中的错误，从而改正自己的曲解。在经历过这段过程后，通常对于自己所写的知识的掌握程度，都上升了一个层次。 我自己的每次技术写作都经历了这样的提高过程。所以，我更多时候是把写作当成学习的一种方式。这种学习方式比普通的学习方式更加深入，效果更好。当然，花费的时间也更多。 提高表达和沟通的能力作为一个程序员，日常的工作大部分时间都是面对电脑。许多人周末也喜欢当一个技术宅，待在家里上网、看电影或者玩游戏来消遣。长时间的面对机器，使得我们的语言表达能力极度衰退。而写作是一个很好的机会，让我们练习自己的表达能力。 长时间写作之后，你会更加注意平时沟通的语言。你的用词更加精准，表达更加生动。在表达能力提高的同时，你的沟通效率也得到提高。 接受读者的沟通和反馈当你的文章通过博客或者 InfoQ 网站发表出来后，你就会接着获得写作的第三个好处：来自读者的沟通和反馈。一篇好的文章通常会吸引一些读者回复，通过和读者的交流，你可以收获以下好处：1 错误内容反馈：尽管文章在写作时经历过二次学习，但是人难免会犯错。写作将你的思想完全暴露出来，有水平的读者可以指出你文章中的错误，从而使你对知识的理解更加准确。我的很多博客文章都有一些细微错误，通过读者的找反馈，我很快就将错误内容改正过来了，自己的水平也得到了提高。 2 认识朋友：一个乐于分享的人总会比沉默寡言的人更招人喜欢。所以通过写作，你可以结交很多和你一样，乐于分享的朋友。 3 了解更多相关信息：一些读者会回复说：” 某某框架也用了这个技术方案 “，或者是：” 你的这个实现方案没有另一个某某开源方案好 “。这些信息，作为你当前文章知识点的补充，使你能够了解更多相关的资料，再一次完善自己所学的知识。 影响力当你持续的写作，坚持一年以上，你就会慢慢收获影响力。这个时候，你也会收到技术大会的分享邀请，出版社的约稿邀请，著名互联网公司的工作邀请，甚至是创业项目的合伙人邀请。你相比那些不分享的人，获得了更多的机会。当然你的技术观点也会被更多人接受，你也会收获到传递知识的乐趣。 #结束语 在写作过程中，你将收获提高自己对知识的掌握层次和提高表达和沟通的能力的好处。 在写作结束后，你将收获错误内容反馈、认识朋友和了解更多相关信息的好处。 在坚持写作一段时间，你将收获影响力和传递知识的乐趣。 另外，《暗时间》 的作者刘未鹏在 他的文章，也总结了很多写作的好处，大家也可以看看。 看了写作的这么多好处，你是否心动？那赶快创建一个博客，开始你的技术写作之旅吧！ 原文链接：http://blog.devtang.com/2014/01/08/why-we-need-write","categories":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/categories/others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/tags/others/"}]},{"title":"给网站添加小插件","slug":"add-widget-with-your-website","date":"2020-03-16T13:02:58.000Z","updated":"2020-03-17T07:02:58.000Z","comments":true,"path":"blog/2020-03-16-add-widget-with-your-website/","link":"","permalink":"https://voiue.github.io/blog/2020-03-16-add-widget-with-your-website/","excerpt":"Hamster 在网页中插入下面这些内容即可","text":"Hamster 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;hamster&#x2F;hamster.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;225&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;hamster&#x2F;hamster.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;&#x2F;object&gt; Dog 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;dog&#x2F;dog.swf?3?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;225&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;dog&#x2F;dog.swf?3?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;bgcolor&quot; value&#x3D;&quot;FFFFFF&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Newton’s Cradle 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;newtonscradle&#x2F;newtonsCradle.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;225&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;newtonscradle&#x2F;newtonsCradle.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;&#x2F;object&gt; Ball Clock 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;ballclock&#x2F;ballclock.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;220&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;ballclock&#x2F;ballclock.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;&#x2F;object&gt; Turtle 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;turtles&#x2F;turtle.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;turtles&#x2F;turtle.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Penguins 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;penguins&#x2F;penguins.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;penguins&#x2F;penguins.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Fish 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;fish&#x2F;fish.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;fish&#x2F;fish.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Tree Frog 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;treefrog&#x2F;treefrog.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;treefrog&#x2F;treefrog.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Spider 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;spider&#x2F;spider.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;spider&#x2F;spider.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;bgcolor&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Disc Drop 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;discdrop&#x2F;discDrop.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;225&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;discdrop&#x2F;discDrop.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;bgcolor&quot; value&#x3D;&quot;FFFFFF&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Pendulum Clock 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;pendulumclock&#x2F;pendulumClockV2.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;pendulumclock&#x2F;pendulumClockV2.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;bgcolor&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;object&gt; Stingray 在网页中插入下面这些内容即可 1&lt;object type&#x3D;&quot;application&#x2F;x-shockwave-flash&quot; style&#x3D;&quot;outline:none;&quot; data&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;stingray&#x2F;stingray.swf?&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;&lt;param name&#x3D;&quot;movie&quot; value&#x3D;&quot;http:&#x2F;&#x2F;cdn.abowman.com&#x2F;widgets&#x2F;stingray&#x2F;stingray.swf?&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;AllowScriptAccess&quot; value&#x3D;&quot;always&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&gt;&lt;&#x2F;param&gt;&lt;param name&#x3D;&quot;scale&quot; value&#x3D;&quot;noscale&quot;&#x2F;&gt;&lt;param name&#x3D;&quot;salign&quot; value&#x3D;&quot;tl&quot;&#x2F;&gt;&lt;&#x2F;object&gt; 插件网站http://abowman.com","categories":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/categories/others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://voiue.github.io/blog/tags/others/"}]},{"title":"理解inode","slug":"inode","date":"2020-03-15T12:51:52.000Z","updated":"2020-03-15T12:51:52.000Z","comments":true,"path":"blog/2020-03-15-inode/","link":"","permalink":"https://voiue.github.io/blog/2020-03-15-inode/","excerpt":"inode是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。 我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。 下面就是我的inode学习笔记，尽量保持简单。","text":"inode是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。 我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。 下面就是我的inode学习笔记，尽量保持简单。 理解inode一、inode是什么？理解inode，要从文件储存说起。 文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。 文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 二、inode的内容inode包含文件的元信息，具体来说有以下内容： 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 链接数，即有多少文件名指向这个inode 文件数据block的位置 可以用stat命令，查看某个文件的inode信息： 1stat example.txt 总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。 三、inode的大小inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。 每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。 查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。 1df -i 查看每个inode节点的大小，可以用如下命令： 1sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep &quot;Inode size&quot; 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。 四、inode号码每个inode都有一个号码，操作系统用inode号码来识别不同的文件。 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 使用ls -i命令，可以看到文件名对应的inode号码： 1ls -i example.txt 五、目录文件Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。 ls命令只列出目录文件中的所有文件名： 1ls &#x2F;etc ls -i命令列出整个目录文件，即文件名和inode号码： 1ls -i &#x2F;etc 如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。 1ls -l &#x2F;etc 理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。 六、硬链接一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。 这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 ln命令可以创建硬链接： 1ln 源文件 目标文件 运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。 反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。 这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。 七、软链接除了硬链接以外，还有一种特殊情况。 文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。 这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。 ln -s命令可以创建软链接。 1ln -s 源文文件或目录 目标文件或目录 八、inode的特殊作用由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。 1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。 2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。 3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。 （完） 原文链接：http://www.ruanyifeng.com/blog/2011/12/inode.html","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"linux","slug":"Dev/linux","permalink":"https://voiue.github.io/blog/categories/Dev/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://voiue.github.io/blog/tags/linux/"},{"name":"磁盘","slug":"磁盘","permalink":"https://voiue.github.io/blog/tags/%E7%A3%81%E7%9B%98/"},{"name":"inode","slug":"inode","permalink":"https://voiue.github.io/blog/tags/inode/"}]},{"title":"常用 Git 命令清单","slug":"git-cheat-sheet","date":"2020-03-13T12:25:14.000Z","updated":"2020-03-13T12:25:14.000Z","comments":true,"path":"blog/2020-03-13-git-cheat-sheet/","link":"","permalink":"https://voiue.github.io/blog/2020-03-13-git-cheat-sheet/","excerpt":"我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。","text":"我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote&#x2F;branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs&#x2F;tags&#x2F;[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty&#x3D;format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive （完） 原文链接：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"https://voiue.github.io/blog/categories/Dev/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://voiue.github.io/blog/tags/Git/"}]},{"title":"Hexo博客中加入Bili标签插件添加视频","slug":"add-bili-vedio-with-tag-in-hexo","date":"2020-03-13T08:27:21.000Z","updated":"2020-03-13T08:27:21.000Z","comments":true,"path":"blog/2020-03-13-add-bili-vedio-with-tag-in-hexo/","link":"","permalink":"https://voiue.github.io/blog/2020-03-13-add-bili-vedio-with-tag-in-hexo/","excerpt":"这篇文章是上篇文章《Hexo博客中加入B站视频播放器》的第二种实现过程，使用新增hexo标签的形式来添加B站视频。使用起来更方便~ 回顾下之前的实现过程代码如下： 123&#123;% raw %&#125;&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;24897960&amp;cid&#x3D;42007693&amp;page&#x3D;3&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#123;% endraw %&#125;","text":"这篇文章是上篇文章《Hexo博客中加入B站视频播放器》的第二种实现过程，使用新增hexo标签的形式来添加B站视频。使用起来更方便~ 回顾下之前的实现过程代码如下： 123&#123;% raw %&#125;&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;24897960&amp;cid&#x3D;42007693&amp;page&#x3D;3&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#123;% endraw %&#125; 两个视频见唯一不同就是iframe标签中src的?后面aid=24897960&amp;cid=42007693&amp;page=3这部分。所以我们可以把它封装成一个hexo tag标签插件。 有关于标签插件具体可以查看官方API文档标签Tag。 以下内容来自官方文档：标签插件（Tag）标签插件帮助开发者在文章中快速插入内容。 概要 12hexo.extend.tag.register(name, function(args, content)&#123;&#125;, options); 标签函数会传入两个参数：args 和 content，前者代表开发者在使用标签插件时传入的参数，而后者则是标签插件所覆盖的内容。 youtube视频栗子1234hexo.extend.tag.register(&#39;youtube&#39;, function(args)&#123; var id &#x3D; args[0]; return &#39;&lt;div class&#x3D;&quot;video-container&quot;&gt;&lt;iframe width&#x3D;&quot;560&quot; height&#x3D;&quot;315&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;&#39; + id + &#39;&quot; frameborder&#x3D;&quot;0&quot; allowfullscreen&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#39;;&#125;); youtube使用栗子1&#123;% youtube video_id %&#125; 咳咳，看了以上内容应该已经大致了解，接下来开始实现。 第一步 找到标签插件位置位置在博客目录\\node_modules\\hexo\\lib\\plugins\\tag\\下。先看下index.js内容如下: 我们学着youtube在后面加个bilibili 1tag.register(&#39;bili&#39;, require(&#39;.&#x2F;bili&#39;)); 第二步 编写tag插件bili.js上一步我们注册了bili插件，但是还没有插件的js文件，可以看到他的require目录是./所以就在当前目录下（即tag目录下）新建bili.js文件，不理解./的童鞋可以搜索下绝对路径与相对路径的意思就懂了。 建好js文件后我们开始编写插件，代码如下： 12345678910111213141516&#39;use strict&#39;;&#x2F;*** Bilibili tag** Syntax:* &#123;% bili video_id %&#125;*&#x2F;function biliTag(args, content) &#123; var id &#x3D; args[0]; return &#96;&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?$&#123;id&#125;&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#96;;&#125;module.exports &#x3D; biliTag; 第三步 在md文章中使用在文章中使用的语法为 1&#123;% bili bili_id %&#125; 其中bili_id为你从B站获取的iframe的src的id部分。比如分享的iframe代码如下: 1&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;24897960&amp;cid&#x3D;42007944&amp;page&#x3D;1&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot;&gt; &lt;&#x2F;iframe&gt; bili_id就是aid=24897960&amp;cid=42007944&amp;page=1，使用语法就是 1&#123;% bili aid&#x3D;24897960&amp;cid&#x3D;42007944&amp;page&#x3D;1 %&#125; 在文章中加入以上标签就可以快速插入B站视频了。","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"hexo","slug":"Dev/hexo","permalink":"https://voiue.github.io/blog/categories/Dev/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://voiue.github.io/blog/tags/hexo/"}]},{"title":"Github常用命令","slug":"github-common-command","date":"2020-03-11T09:11:06.000Z","updated":"2020-03-11T09:11:06.000Z","comments":true,"path":"blog/2020-03-11-github-common-command/","link":"","permalink":"https://voiue.github.io/blog/2020-03-11-github-common-command/","excerpt":"本地仓库推送至github12345678$ git init coding$ git add.$ git commit -m &quot;balabala&quot; github上新建仓库（最好同名）复制链接$ git remote add origin + 你的链接$ git pull --rebase oring master$ git push -u origin master","text":"本地仓库推送至github12345678$ git init coding$ git add.$ git commit -m &quot;balabala&quot; github上新建仓库（最好同名）复制链接$ git remote add origin + 你的链接$ git pull --rebase oring master$ git push -u origin master 平时推送123$ git add .$ git commit -m &quot;balabala&quot;$ git push github仓库克隆到本地coding再推送12345$ git clone 仓库链接 coding$ git add .$ git commit -m &quot;balabala&quot;$ git push PR（pull request）1234567891011 github网页上fork源仓库$ git clone 自己fork的项目$ git remote add upstream 源仓库$ git remote -v$ git checkout -b 新的分支 change code$ git status$ git add .$ git commit -m &quot;说明&quot;$ git push origin 分支名 github网页上提交pr(New pull request) 原文链接：https://www.hojun.cn/2018/03/24/ck70npt44000ue0tusk97bg40/","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"https://voiue.github.io/blog/categories/Dev/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://voiue.github.io/blog/tags/Git/"}]},{"title":"删除github的release或tag","slug":"delete-github-release-or-tag","date":"2020-03-10T13:46:54.000Z","updated":"2020-03-10T13:46:54.000Z","comments":true,"path":"blog/2020-03-10-delete-github-release-or-tag/","link":"","permalink":"https://voiue.github.io/blog/2020-03-10-delete-github-release-or-tag/","excerpt":"如何删除或者说如何更新当前的release呢？今天刚开始学习利用jsDeliver搭建图床的时候就遇到这个问题。 刚开始的时候跟着网上的教程创建了一个cdn-wallpaper的仓库，也push了一张图片进去了，根据jsDeliver的引用链接成功的设置了博客的背景图片，但是后面发现这张图片的名字太长了，于是就把这张图片的名字删减了一部分，之后就重新提交到github仓库了，但是发现博客的背景却引用不了这个图片，通过网页调试发现引用的链接居然无效。","text":"如何删除或者说如何更新当前的release呢？今天刚开始学习利用jsDeliver搭建图床的时候就遇到这个问题。 刚开始的时候跟着网上的教程创建了一个cdn-wallpaper的仓库，也push了一张图片进去了，根据jsDeliver的引用链接成功的设置了博客的背景图片，但是后面发现这张图片的名字太长了，于是就把这张图片的名字删减了一部分，之后就重新提交到github仓库了，但是发现博客的背景却引用不了这个图片，通过网页调试发现引用的链接居然无效。 更新release回到cdn-wallpaper项目的主界面，点击release进去后，发现旁边有个edit按钮，于是就点击后就update release了，继续刷新博客，还是不能引用刚刚的图片。看来，这个release还是没有更新成功，于是索性直接把这个1.0版本的release删掉，之后重新再release一次，发现还是有问题。 删除tag上面的删除操错虽然把release删除了，但是这个release对应的tag还没有删除，后来网上搜了一下，还真找到了解决办法。要删除哪个版本的release就要点击对应的版本（我这里是1.0版本）。因为github的release是建立在tag上的，是对tag的一层封装。Git的tag只是一个标签，而github的release在tag的基础上还可以包含更多的打包文件，比如可执行文件等。因此，在github上，删除了release后，这个release对应的tag还存在，还要继续再删除一次，这个tag才会消失。 参考链接：https://www.maixj.net/ict/release-tag-22821","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"https://voiue.github.io/blog/categories/Dev/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://voiue.github.io/blog/tags/Git/"}]},{"title":"超级励志的视频","slug":"ultra-inspirational","date":"2020-03-10T11:42:23.000Z","updated":"2020-03-13T11:42:23.000Z","comments":true,"path":"blog/2020-03-10-ultra-inspirational/","link":"","permalink":"https://voiue.github.io/blog/2020-03-10-ultra-inspirational/","excerpt":"","text":"","categories":[{"name":"video","slug":"video","permalink":"https://voiue.github.io/blog/categories/video/"}],"tags":[{"name":"video","slug":"video","permalink":"https://voiue.github.io/blog/tags/video/"},{"name":"励志","slug":"励志","permalink":"https://voiue.github.io/blog/tags/%E5%8A%B1%E5%BF%97/"}]},{"title":"利用jsDeliver+github实现免费CDN","slug":"free-cdn-with-jsdeliver-and-github","date":"2020-03-10T11:23:20.000Z","updated":"2020-03-10T11:23:20.000Z","comments":true,"path":"blog/2020-03-10-free-cdn-with-jsdeliver-and-github/","link":"","permalink":"https://voiue.github.io/blog/2020-03-10-free-cdn-with-jsdeliver-and-github/","excerpt":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 jsDeliverjsDeliver是一个免费开源的CDN解决方案，用于帮助开发者和站长。包含JavaScript库、jQuery插件、CSS框架、字体等等Web上常用的静态资源。 githubgithub是一个面向开源及私有软件项目托管平台，因为只支持git作为唯一的版本库格式进行托管，故名github 操作流程jsDeliver不支持加载超过20M的资源，所以一些视频最好压缩到20M一下 1、新建github仓库并clone至本地1$ git clone 你的仓库链接 #本地克隆github仓库 2、将需要的静态资源放到本地git仓库中，并提交到github仓库1234$ git status #查看状态$ git add . #添加所有文件到暂存区$ git commit -m &#39;第一次提交&#39; #把文件提交到仓库，文字部分是备注信息说明$ git push #推送至远程仓库 3、在github仓库中点击release发布（版本号可以自定义）4、通过jsDeliver引用资源1234567$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;你的用户名&#x2F;你的仓库名@发布的版本号&#x2F;文件路径&lt;green&gt;# 举个栗子&lt;&#x2F;green&gt;$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;voiue&#x2F;cdn-wallpaper@1.0&#x2F;abstract&#x2F;8782D9-08FE07-E5E73E.jpg #加载1.0版本&lt;green&gt;# 注意：如果不加 @发布的版本号 默认加载最新版本&lt;&#x2F;green&gt;&lt;green&gt;# 举个栗子&lt;&#x2F;green&gt;$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;voiue&#x2F;cdn-wallpaper&#x2F;abstract&#x2F;8782D9-08FE07-E5E73E.jpg # 加载最新版本 参考链接：https://www.itrhx.com/2019/02/10/A18-free-cdn/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/fofade/p/11380935.html","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"CDN","slug":"Dev/CDN","permalink":"https://voiue.github.io/blog/categories/Dev/CDN/"}],"tags":[{"name":"jsDeliver","slug":"jsDeliver","permalink":"https://voiue.github.io/blog/tags/jsDeliver/"},{"name":"github","slug":"github","permalink":"https://voiue.github.io/blog/tags/github/"},{"name":"CDN","slug":"CDN","permalink":"https://voiue.github.io/blog/tags/CDN/"}]},{"title":"windows虚拟内存-折腾","slug":"virtual-memory","date":"2020-03-09T12:16:11.000Z","updated":"2020-03-09T12:16:11.000Z","comments":true,"path":"blog/2020-03-09-virtual-memory/","link":"","permalink":"https://voiue.github.io/blog/2020-03-09-virtual-memory/","excerpt":"由于自己电脑之前是机械硬盘的，读写速度太慢了，后来就买了个120G的固态硬盘给扩展了，机械硬盘就用来存资料文档啥的，固态硬盘就被我分成40G的用作系统（C）盘，剩下的用作软件安装（D）盘。 对操作系统有些了解的人应该听说过虚拟内存的概念，这里也不做过多的解释。虚拟内存默认是有系统自动托管的，对应着windows系统磁盘根目录下的pagefiles.sys文件，但是随着用户的慢慢使用，这个pagefiles.sys文件会越来越大，直到有一天，我发现C盘和D盘都红了，我才意识到了——该折腾了。","text":"由于自己电脑之前是机械硬盘的，读写速度太慢了，后来就买了个120G的固态硬盘给扩展了，机械硬盘就用来存资料文档啥的，固态硬盘就被我分成40G的用作系统（C）盘，剩下的用作软件安装（D）盘。 对操作系统有些了解的人应该听说过虚拟内存的概念，这里也不做过多的解释。虚拟内存默认是有系统自动托管的，对应着windows系统磁盘根目录下的pagefiles.sys文件，但是随着用户的慢慢使用，这个pagefiles.sys文件会越来越大，直到有一天，我发现C盘和D盘都红了，我才意识到了——该折腾了。 开始折腾于是开始找原因，到磁盘里面一个个文件夹看属性，看占多大空间，可是不管怎样还是凭空少了20多G的空间没了，于是心想，肯定是操作系统给隐藏起来了，接着就用组合键WIN + R ，输入cmd打开命令行，输入D:回车将路径切换到D盘根目录下，然后输入命令dir /a，果不其然居然有一个20多G的pagefiles.sys文件，于是想把它删掉，却发现怎么也删不掉，来回的折腾，对于经常折腾系统的我来说，删掉这个文件也很容易，于是拿出之前制作好的U盘启动盘（就是可以用来重装系统的那种），开机从U盘启动，然后就把那个pagefiles.sys文件删除了，D盘的20多G的空间瞬间又回来了，心里乐呵呵的。 然并卵重新开机后发现磁盘也不再是红色的啦，可是用着没多长时间发现磁盘又变红了，输入上面的命令，又产生了那个文件，心里那个失望啊(T_T)，这可不是办法啊，每次删掉都会重新生成这么大的文件，太麻烦了，终于今天又产生了这个文件，这次居然直接系统卡死了，这不能忍啊，于是又开始网上找原因，说是可以手动修改虚拟内存的大小，也就是不让系统来托管，网上的都是建议虚拟内存设置的是物理内存的2倍，我电脑内存是8G，也就是要设置成16G，那相比20多G的也少不了多少啊，于是就打算将虚拟内存设置成8G大小，具体设置方法，先用组合键WIN + Pause ,打开系统属性，然后“高级”—&gt;“性能”里面的“设置”—&gt;再选“高级”—&gt;“虚拟内存”里面的“更改”—&gt;将第一行的“自动管理所有驱动器的文件大小”前面的☑去掉，然后选择要手动设置虚拟内存的磁盘，勾选☑自定义大小，因为是8G的内存，所以我就将初始值设置成4096（MB），也就是4G，最大值设置成8192（MB），也就是8G，然后点击旁边的设置 ，这个一定要点，不然不会生效，之后再点击最下面的确定，这样就将D盘的虚拟内存大小设置好了，同样的可以来设置C盘，其他盘等等。 &nbsp; &nbsp; &nbsp; 大功告成按照上面的设置完了后，我们再打开我的电脑（快捷键：WIN + E），发现磁盘的颜色又恢复正常了，容量也都回来了，相比之前占用的20多G的pagefiles.sys文件，现在只是会占用4G的空间了（注意：这个虚拟内存不能比我这还设置的更小了，不然会对操作系统的性能产生很大的影响，笔者之前可是深有体会的，特别是对图片的加载速度，比如在浏览器里面要上传个本地的图片，这个过程要加载10S左右，期间还不能操作鼠标点击，不然浏览器就无响应了，当时一直找不到问题出在哪里，后来将虚拟内存改成自动托管后，这个速度真的是明显的提提升啊） 参考链接：http://www.winwin7.com/JC/Win7JC-7699.html","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"虚拟内存","slug":"Dev/虚拟内存","permalink":"https://voiue.github.io/blog/categories/Dev/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://voiue.github.io/blog/tags/windows/"},{"name":"虚拟内存","slug":"虚拟内存","permalink":"https://voiue.github.io/blog/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"}]},{"title":"十万蝼蚁不如一个巨人","slug":"its-better-to-be-a-titan","date":"2020-03-09T11:18:29.000Z","updated":"2020-03-09T11:18:29.000Z","comments":true,"path":"blog/2020-03-09-its-better-to-be-a-titan/","link":"","permalink":"https://voiue.github.io/blog/2020-03-09-its-better-to-be-a-titan/","excerpt":"混乱不是深渊。混乱是阶梯。很多人想往上爬 却失败了且永无机会再试。他们坠落而亡。有人本有机会攀爬，但他们拒绝了。他们守着王国不放守着诸神守着爱情尽皆幻想。唯有阶梯是真实存在。攀爬才是生活的全部。—— Game of Thrones","text":"混乱不是深渊。混乱是阶梯。很多人想往上爬 却失败了且永无机会再试。他们坠落而亡。有人本有机会攀爬，但他们拒绝了。他们守着王国不放守着诸神守着爱情尽皆幻想。唯有阶梯是真实存在。攀爬才是生活的全部。—— Game of Thrones 物竞天择世界是残酷的，强者以弱者为食。 个体意识每个人都是一个独立的个体，群众的力量再强大，他们也不属于你，只是在某些时刻能够帮到你。与其成为一个强大群体中微不足道的一员，不如成为一个强大的个体。 群体意识社会不需要太多巨人，需要团结在一起才能发挥威力的蚂蚁一族。像牧羊一样，管好头羊，其他都会乖乖跟着头羊，即使有不听话的，也不会威胁到牧羊人。但如果羊羔中有几个或更多比牧羊人掌管的头羊更强壮的个体，牧羊人就会低位不保。这些羊羔如果足够聪明的话，是不应该过早展露实力的，冲动的结局则是变成一桌美食。 珍惜当下活着本来就是如临深渊，如履薄冰，永远不能保证下一刻不会遭遇意外。每天早上睁开眼就能看到熟悉的世界，能够记得自己走过的人生，都值得庆幸。不做别人的棋子，更不教育自己的后代如何做好这一颗棋子，生活是你自己的。 时间、效率、实力我一直把时间作为衡量价值的标准，因为只有时间是有限的、平等的。效率则是将时间转化成实力的最关键一步，是靠自己的努力获得的，谁也赠予不了，谁也偷不了。实力则是我的人生观中的价值所在，也是唯一的追求。 选择你可以选择随遇而安，只需要一双发现美的眼睛和积极乐观的心态。 也可以攀爬，你会发现到处都是陷阱，一步跌落，就是万丈深渊。哪怕你认为现在的处境已经跌落人生低谷，但是事实是前方依然会有更深的陷阱在等着你。 原文链接：https://xaoxuu.com/blog/2016-05-22-its-better-to-be-a-titan/","categories":[{"name":"读书","slug":"读书","permalink":"https://voiue.github.io/blog/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://voiue.github.io/blog/tags/essay/"}]},{"title":"写博客必备神器","slug":"write-blog-tools","date":"2020-03-09T07:40:03.000Z","updated":"2020-03-09T07:40:03.000Z","comments":true,"path":"blog/2020-03-09-write-blog-tools/","link":"","permalink":"https://voiue.github.io/blog/2020-03-09-write-blog-tools/","excerpt":"完成了博客的搭建之后，接下来就是内容创作了。而创作的过程中，我们又会有一系列的问题，比如： 我们用什么工具来写文章呢？ 怎么才能快速生成格式化的Markdown 表格呢？ 怎么样才能画出一些高逼格的图片呢？ 这些图片的存储和处理怎么办呢？文章中的代码高亮如何实现呢？ 要解决这些问题其实并不难，无非就是引入不同的工具来帮助我们，好的工具可以让我们的创作事半功倍！","text":"完成了博客的搭建之后，接下来就是内容创作了。而创作的过程中，我们又会有一系列的问题，比如： 我们用什么工具来写文章呢？ 怎么才能快速生成格式化的Markdown 表格呢？ 怎么样才能画出一些高逼格的图片呢？ 这些图片的存储和处理怎么办呢？文章中的代码高亮如何实现呢？ 要解决这些问题其实并不难，无非就是引入不同的工具来帮助我们，好的工具可以让我们的创作事半功倍！ Markdown编辑器先来推荐一下我们要用的最重要的一个工具：Markdown编辑器。我们需要使用它来完成所有的创作内容，本人尝试了非常多的编辑器，最终锁定在下面这款Typora，因此推荐给大家。 推荐工具：Typora 官方地址：https://www.typora.io/ 推荐理由：作为一款免费编辑器，可以说是相当良心，是我目前所知道的最好用的免费编辑器了，没有之一！！！它支持多个主流的操作系统，不论你是Windows用户还是Mac用户，都能轻易的安装和使用它！除此之外，它还有不同的主题选择、导出一些常用格式（PDF、Word、HTML）等等非常有用的功能！ Markdown表格生成器对于强迫症来说，写Markdown表格是一件很痛苦的事情，在语法对齐的问题上我真的是受尽了折磨，所以强烈推荐一个在线Markdown表格生成工具，它出来能快速生成格式化后的Markdown表格外，还支持导入各种数据，在线编辑，简直强大！ 推荐工具：Table Convert Online 官方地址：https://tableconvert.com/ 推荐理由：作为一款免费的在线工具，支持Excel、JSON、HTML、CSV甚至是从URL中提取HTML表格转为Markdown表格，多功能集一身，并融合在一个界面，使用非常方便，不需要切换界面。还可以像编辑Excel一样编辑生成各种表格，不愧为表格中的瑞士军刀！ 画图工具对于我们这些写技术文章的博主来说，画画流程图、架构图是辅助描述文章内容的最佳途径，下面要推荐的ProcessOn就是目前我用得最多的画图工具。 推荐工具：ProcessOn 官方地址：https://processon.com/ 推荐理由：难得的国产在线图片编辑器，支持多人协作。同时，还有大量好看的图标支持，可以让我们的绘图更加生动！ 图片存储可能有人会问，为什么要图片存储呢？我们直接存Wordpress或者Hexo的目录下不久好了吗？实际上，使用这些主要是为了经济性的考虑，随着访问量的增大，图片对于我们的虚拟主机或ECS的空间以及带宽消耗都会造成一定的压力，使用类似图床的平台就可以帮助我们减轻这些压力。 推荐工具：外链工厂 官方地址：http://www.wailian.work/ 推荐理由：简单好用、足够稳定，释放自己虚拟空间或虚拟主机的存储和带宽消耗，但是记得做好备份哦！ 代码高亮如果你跟我一样是一名程序猿，那么代码高亮是必备的。大多Hexo的主题中都包含了高亮插件，但是有些并没有，那么我们需要知道鼎鼎大名的highlight.js。对于一些已经有这个插件的主题，也可以通过官网来做一些定制，没有的直接引入来使用即可。 推荐工具：highlight.js 官方地址：https://highlightjs.org/ 推荐理由：使用于所有主流编程语言，兼容性好，多种多样的预设样式，总有一款适合你！ 原文链接：http://fech.in/2019/write-blog-tools/","categories":[{"name":"tool","slug":"tool","permalink":"https://voiue.github.io/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://voiue.github.io/blog/tags/tool/"}]},{"title":"Hexo template","slug":"hexo-template","date":"2020-03-04T16:00:00.000Z","updated":"2020-04-25T14:59:42.931Z","comments":true,"path":"blog/2020-03-05-hexo-template/","link":"","permalink":"https://voiue.github.io/blog/2020-03-05-hexo-template/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Dev","slug":"Dev","permalink":"https://voiue.github.io/blog/categories/Dev/"},{"name":"hexo","slug":"Dev/hexo","permalink":"https://voiue.github.io/blog/categories/Dev/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://voiue.github.io/blog/tags/hexo/"}]}]}