<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于FPGA芯片命名规则的解释</title>
      <link href="/blog/2020-07-05-explanation-of-FPGA-chip-naming-rules/"/>
      <url>/blog/2020-07-05-explanation-of-FPGA-chip-naming-rules/</url>
      
        <content type="html"><![CDATA[<h2 id="Xilinx的FPGA芯片"><a href="#Xilinx的FPGA芯片" class="headerlink" title="Xilinx的FPGA芯片"></a>Xilinx的FPGA芯片</h2><p>&emsp;&emsp;例如XC7VX485T-2FFG1761C:<br>&emsp;&emsp;<code>XC7VX485T</code>是芯片型号，表示属于Xilinx公司的V7系列的芯片，485T表示其有48.5万个逻辑单元。<br>&emsp;&emsp;<code>-2</code>表示速度等级，对于Xilinx FPGA来说，一般有-1，-2，-3三个等级，值越大，速度越高。<br>&emsp;&emsp;<code>FFG</code>表示封装方式，<code>1761</code>表示引脚数，<code>C</code>代表的是温度等级Temperature grade ，这里是商用(Commercial)，如果是<code>I</code> 就是工业用。<br>&emsp;&emsp;同一款芯片可以有多个速度等级，不同的速度等级代表着不同的性能，不同的性能又导致芯片价格的巨大差异。芯片的速度等级不是设计出来的，而是在芯片生产出来之后，实际测试标定出来的。速度快的芯片在总产量中的比率低，价格也就相应地高。那么是什么因素导致了同一批芯片的性能差异，主要有下面两点：<br>&emsp;&emsp;芯片的速度等级决定于芯片内部的门延时和线延时，这两个因素又决定于晶体管的长度L和容值C，这两个数值的差异最终决定于芯片的生产工艺。<br>&emsp;&emsp;在芯片生产过程中，有一个阶段叫做speed binning。就是采用一定的方法，按照一组标准对生产出来的芯片进行筛选和分类，进而划分不同的速度等级。</p><a id="more"></a><h2 id="Altera的FPGA芯片"><a href="#Altera的FPGA芯片" class="headerlink" title="Altera的FPGA芯片"></a>Altera的FPGA芯片</h2><p>以EP2C35F672C6N为例做一个说明：</p><p><code>EP</code>：工艺；</p><p><code>2C</code>：cyclone II（飓风）（S代表Stratix，A代表arria）；</p><p><code>35</code>：逻辑单元数，35表示大约有35k的逻辑单元；</p><p><code>F</code>：表示PCB封装类型，F是FBGA封装，E(EQFP)、Q(PQFP)、U(UBGA)、M(MBGA)；</p><p><strong>Package Type：</strong></p><p>E: PlasTIc Enhanced Quad Flat Pack (EQFP)</p><p>Q: PlasTIc Quad Flat Pack (PQFP)</p><p>F: FineLine Ball-Grid Array (FBGA)</p><p>U: Ultra FineLine Ball-Grid Array (UBGA)</p><p>M: Micro FineLine Ball-Grid Array (MBGA)</p><p><code>672</code>：表示引脚数量；</p><p><code>C</code>：工作温度，C表示可以工作在0°C到85°C，I表示可以工作在-40°到100°C，A表示可以工作在-40°C到125°C；</p><p><strong>OperaTIng Temperature：</strong></p><p>C: Commercial temperature (TJ = 0°C to 85°C)</p><p>I: Industrial temperature (TJ = -40°C to 100°C)</p><p>A: AutomoTIve temperature (TJ = -40°C to 125°C)</p><p><code>6</code>：速度等级，6约最大是500Mhz，7约最大是430Mhz，8约最大是400Mhz；</p><p><code>N</code>：后缀，N表示无铅，ES工程样片。</p><p>以下是cyclone iv的手册参考</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/fpga_naming_rules0.png" /></fancybox></center><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/fpga_naming_rules.png" /></fancybox></center>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命名规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-14-Vivado时序约束中Tcl命令的对象及属性</title>
      <link href="/blog/2020-06-24-1-14-tcl-commands/"/>
      <url>/blog/2020-06-24-1-14-tcl-commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Vivado时序约束中Tcl命令的对象及属性"><a href="#Vivado时序约束中Tcl命令的对象及属性" class="headerlink" title="Vivado时序约束中Tcl命令的对象及属性"></a>Vivado时序约束中Tcl命令的对象及属性</h1><p>&emsp;&emsp;在前面的章节中，我们用了很多Tcl的指令，但有些指令并没有把所有的参数多列出来解释，这一节，我们就把约束中的Tcl指令详细讲一下。</p><p>我们前面讲到过<code>get_pins</code>和<code>get_ports</code>的区别，而且我们也用过<code>get_cells</code>、<code>get_clocks</code>和<code>get_nets</code>这几个指令，下面就通过一张图直观展现它们的区别。</p><a id="more"></a><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial55.png"  alt="" /></fancybox></center><p><code>get_clocks</code>后面的对象是我们之前通过<code>create_clocks</code>或者<code>create_generated_clocks</code>创建的时钟，不在硬件上直接映射。</p><p>&emsp;&emsp;我们再来看下各个命令的属性。</p><h2 id="1-port"><a href="#1-port" class="headerlink" title="1. port"></a>1. port</h2><p>我们可以通过Tcl脚本查看port的所有属性，比如上面的wave_gen工程中，有一个port是<code>clk_pin_p</code>，采用如下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set inst [get_ports clk_pin_p]</span><br><span class="line">report_property $inst</span><br></pre></td></tr></table></figure><p>显示如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial56.png"  alt="" /></fancybox></center><p><code>get_ports</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有端口</span><br><span class="line">get_ports *</span><br><span class="line"></span><br><span class="line"># 获取名称中包含data的端口</span><br><span class="line">get_ports *data*</span><br><span class="line"></span><br><span class="line"># 获取所有输出端口</span><br><span class="line">get_ports -filter &#123;DIRECTION &#x3D;&#x3D; OUT&#125;</span><br><span class="line"></span><br><span class="line"># 获取所有输入端口</span><br><span class="line">all_inputs</span><br><span class="line"></span><br><span class="line"># 获取输入端口中名字包含data的端口</span><br><span class="line">get_ports -filter &#123;DIRECTION &#x3D;&#x3D; IN&#125; *data*</span><br><span class="line"></span><br><span class="line"># 获取总线端口</span><br><span class="line">get_ports -filter &#123;BUS_NAME !&#x3D; &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-cell"><a href="#2-cell" class="headerlink" title="2. cell"></a>2. cell</h2><p>按照上面的同样的方式，获取cell的property，如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial57.png"  alt="" /></fancybox></center><p><code>get_cells</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 获取顶层模块</span><br><span class="line">get_cells *</span><br><span class="line"></span><br><span class="line"># 获取名称中包含字符gen的模块</span><br><span class="line">get_cells *gen*</span><br><span class="line"></span><br><span class="line"># 获取clk_gen_i0下的所有模块</span><br><span class="line">get_cells clk_gen_i0&#x2F;*</span><br><span class="line"></span><br><span class="line"># 获取触发器为FDRE类型且名称中包含字符samp</span><br><span class="line">get_cells -hier -filter &#123;REF_NAME &#x3D;&#x3D; FDRE&#125; *samp*</span><br><span class="line"></span><br><span class="line"># 获取所有的时序单元逻辑</span><br><span class="line">get_cells -hier -filter &#123;IS_SEQUENTIAL &#x3D;&#x3D; 1&#125;</span><br><span class="line"></span><br><span class="line"># 获取模块uart_rx_i0下两层的LUT3</span><br><span class="line">get_cells -filter &#123;REF_NAME &#x3D;&#x3D; LUT3&#125; *uart_tx_i0&#x2F;*&#x2F;*</span><br></pre></td></tr></table></figure><h2 id="3-pin"><a href="#3-pin" class="headerlink" title="3. pin"></a>3. pin</h2><p>获取pin的property，如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial58.png"  alt="" /></fancybox></center><p><code>get_pins</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有pins</span><br><span class="line">get_pins *</span><br><span class="line"></span><br><span class="line"># 获取名称中包含字符led的引脚</span><br><span class="line">get_pins -hier -filter &#123;NAME &#x3D;~ *led*&#125;</span><br><span class="line"></span><br><span class="line"># 获取REF_PIN_NAME为led的引脚</span><br><span class="line">get_pins -hier -filter &#123;REF_PIN_NAME &#x3D;&#x3D; led&#125;</span><br><span class="line"></span><br><span class="line"># 获取时钟引脚</span><br><span class="line">get_pins -hier -filter &#123;IS_CLOCK &#x3D;&#x3D; 1&#125;</span><br><span class="line"></span><br><span class="line"># 获取名称中包含cmd_parse_i0的使能引脚</span><br><span class="line">get_pins -filter &#123;IS_ENABLE &#x3D;&#x3D; 1&#125; cmd_parse_i0&#x2F;*&#x2F;*</span><br><span class="line"></span><br><span class="line"># 获取名称中包含字符cmd_parse_i0且为输入的引脚</span><br><span class="line">get_pins -filter &#123;DIRECTION &#x3D;&#x3D; IN&#125; cmd_parse_i0&#x2F;*&#x2F;*</span><br></pre></td></tr></table></figure><h2 id="4-net"><a href="#4-net" class="headerlink" title="4. net"></a>4. net</h2><p>获取net的property，如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial59.png"  alt="" /></fancybox></center><p><code>get_nets</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有nets</span><br><span class="line">get_nets *</span><br><span class="line"></span><br><span class="line"># 获取名称中包含字符send_resp_val的网线</span><br><span class="line">get_nets -hier *send_resp_val*</span><br><span class="line">get_nets -filter &#123;NAME &#x3D;~ *send_resp_val*&#125; -hier</span><br><span class="line"></span><br><span class="line"># 获取穿过边界的同一网线的所有部分</span><br><span class="line">get_nets &#123;resp_gen_i0&#x2F;data4[0]&#125; -segments</span><br><span class="line"></span><br><span class="line"># 获取模块cmd_parse_i0下的所有网线</span><br><span class="line">get_nets -filter &#123;PARENT_CELL &#x3D;&#x3D; cmd_parse_i0&#125; -hier</span><br><span class="line"></span><br><span class="line"># 获取模块cmd_parse_i0下的名称中包含字符arg_cnt[]的网线</span><br><span class="line">get_nets -filter &#123;PARENT_CELL &#x3D;&#x3D; cmd_parse_i0&#125; -hier *arg_cnt[*]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这5个tcl指令的常用选项如下表：</p><table><thead><tr><th>命令</th><th>-hierarchy</th><th>-filter</th><th>-of_objects</th><th>-regexp</th><th>-nocase</th></tr></thead><tbody><tr><td>get_cells</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>get_nets</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>get_pins</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>get_ports</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>get_clocks</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>&emsp;&emsp;这5个Tcl命令对应的5个对象之间也有着密切的关系，下图所示的箭头的方向表示已知箭头末端对象可获取箭头指向的对象。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial60.png"  alt="" /></fancybox></center><p>&emsp;&emsp;以wave_gen中的<code>clk_gen_i0</code>模块为例来说明上面的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 获取模块的输入引脚</span><br><span class="line">get_pins -of [get_cells &#123;clk_gen_i0&#x2F;clk_core_i0&#125;] -filter &#123;DIRECTION &#x3D;&#x3D; IN&#125;</span><br><span class="line"></span><br><span class="line"># 已知引脚名获取所在模块</span><br><span class="line">get_cells -of [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_in1_n]</span><br><span class="line"></span><br><span class="line"># 已知模块名获取与该模块相连的网线</span><br><span class="line">get_nets -of [get_cells &#123;clk_gen_i0&#x2F;clk_core_i0&#125;]</span><br><span class="line"></span><br><span class="line"># 已知引脚名获取与该引脚相连的网线</span><br><span class="line">get_nets -of [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_rx]</span><br><span class="line"></span><br><span class="line"># 已知时钟引脚获取时钟引脚对应的时钟</span><br><span class="line">get_clocks -of [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_rx]</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><p>-hier不能和层次分隔符“/”同时使用，但“/”可出现在-filter中</p></li><li><p>可根据属性过滤查找目标对象</p></li><li><p>-filter中的属性为：“==”（相等）、“!=”（不相等）、”=<del>“（匹配）、”!</del>“（不匹配）若有多个表达式，其返回值为bool类型时，支持逻辑操作</p></li></ol><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=14" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>谢鸣：<a href="http://www.technomania.cn/" target="_blank" rel="noopener">http://www.technomania.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-13-Vivado时序约束辅助工具</title>
      <link href="/blog/2020-06-18-1-13-vivado-timing-tools/"/>
      <url>/blog/2020-06-18-1-13-vivado-timing-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="时序约束辅助工具"><a href="#时序约束辅助工具" class="headerlink" title="时序约束辅助工具"></a>时序约束辅助工具</h1><p>&emsp;&emsp;上面我们讲的都是xdc文件的方式进行时序约束，Vivado中还提供了两种图形界面的方式，帮我们进行时序约束：时序约束编辑器（Edit Timing Constraints ）和时序约束向导（Constraints Wizard）。两者都可以在综合或实现后的Design中打开。</p><a id="more"></a><h2 id="1-时序约束编辑器"><a href="#1-时序约束编辑器" class="headerlink" title="1. 时序约束编辑器"></a>1. 时序约束编辑器</h2><p>&emsp;&emsp;打开之后就可显示出我们之前做的所有约束，当然，还可以再添加、删除或修改时序约束。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial51.png"  alt="" /></fancybox></center><p>&emsp;&emsp;比如我们要新添加一个主时钟，先选中左边的<code>Create Clock</code>，再点击<code>+</code>号添加约束，然后就会看到下面的界面，按下图中步骤操作。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial52.png"  alt="" /></fancybox></center><p>其中，选择时钟按钮会弹出一个新的窗口，如下图所示，我们只需根据时钟名字进行查找并选择即可。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial53.png"  alt="" /></fancybox></center><h2 id="2-时序约束向导"><a href="#2-时序约束向导" class="headerlink" title="2. 时序约束向导"></a>2. 时序约束向导</h2><p>&emsp;&emsp;时序约束向导可以自动识别出未约束的主时钟，我们把wave_gen工程的xdc文件中对clk2的时钟约束注释掉，重新综合并实现后，打开时序约束向导，可以看到clk2被检测出未约束，点击编辑按钮，设置参数后就可完成约束。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial54.png"  alt="" /></fancybox></center><p>&emsp;&emsp;时序约束向导会按照主时钟约束、衍生时钟约束、输入延迟约束、输出延迟约束、时序例外约束、异步时钟约束等的顺序引导设计者创建约束。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=13" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-12-FPGA时序约束实战篇之多周期路径约束</title>
      <link href="/blog/2020-06-16-1-12-multicycle-path/"/>
      <url>/blog/2020-06-16-1-12-multicycle-path/</url>
      
        <content type="html"><![CDATA[<h2 id="多周期路径约束"><a href="#多周期路径约束" class="headerlink" title="多周期路径约束"></a>多周期路径约束</h2><p>&emsp;&emsp;多周期路径，我们一般按照以下4个步骤来约束：</p><ol><li>带有使能的数据</li></ol><p>&emsp;&emsp;首先来看带有使能的数据，在本工程中的Tming Report中，也提示了同一个时钟域之间的几个路径建立时间不满足要求</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial63.png?raw=true"  alt="" /></fancybox></center><a id="more"></a><p>&emsp;&emsp;其实这几个路径都是带有使能的路径，使能的周期为2倍的时钟周期，本来就应该在2个时钟周期内去判断时序收敛。因此，我们添加时序约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 2 -setup -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;]</span><br><span class="line">set_multicycle_path 1 -hold -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;]</span><br></pre></td></tr></table></figure><p>也可以写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;] 2</span><br><span class="line">set_multicycle_path -hold -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;] 1</span><br></pre></td></tr></table></figure><p>这两种写法是等价的。</p><p>我们也可以直接点击右键通过GUI的方式进行约束，效果都是一样的。</p><p>&emsp;&emsp;在工程的<code>uart_tx_ctl.v</code>和<code>uart_rx_ctl.v</code>文件中，也存在带有使能的数据，但这些路径在未加多路径约束时并未报出时序错误或者警告。</p><p>在接收端，捕获时钟频率是200MHz，串口速率是115200，采用16倍的Oversampling，因此使能信号周期是时钟周期的200e6/115200/16=108.5倍。</p><p>在接收端，捕获时钟频率是166667MHz，串口速率是115200，采用16倍的Oversampling，因此使能信号周期是时钟周期的166.667e6/115200/16=90.4倍。</p><p>&emsp;&emsp;因此，时序约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 串口接收端</span><br><span class="line">set_multicycle_path  -from [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] 108</span><br><span class="line">set_multicycle_path -hold -from [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] 107</span><br><span class="line"># 串口发送端</span><br><span class="line">set_multicycle_path -from [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] 90</span><br><span class="line">set_multicycle_path -hold -from [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] 89</span><br></pre></td></tr></table></figure><p>约束中的<code>filter</code>参数也将在下一章节具体讲解。</p><ol start="2"><li>两个有数据交互的时钟之间存在相位差</li></ol><p>&emsp;&emsp;在本工程中，没有这种应用场景，因此不需要添加此类约束。</p><ol start="3"><li>存在快时钟到慢时钟的路径</li></ol><p>&emsp;&emsp;在本工程中，没有这种应用场景，因此不需要添加此类约束。</p><ol start="4"><li>存在慢时钟到快时钟的路径</li></ol><p>&emsp;&emsp;在本工程中，没有这种应用场景，因此不需要添加此类约束。</p><p>综上，我们所有的时序约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 主时钟约束</span><br><span class="line">create_clock -period 25.000 -name clk2 [get_ports clk_in2]</span><br><span class="line"></span><br><span class="line"># 衍生时钟约束</span><br><span class="line">create_generated_clock -name clk_samp -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_tx] -divide_by 32 [get_pins clk_gen_i0&#x2F;BUFHCE_clk_samp_i0&#x2F;O]</span><br><span class="line">create_generated_clock -name spi_clk -source [get_pins dac_spi_i0&#x2F;out_ddr_flop_spi_clk_i0&#x2F;ODDR_inst&#x2F;C] -divide_by 1 -invert [get_ports spi_clk_pin]</span><br><span class="line">create_generated_clock -name clk_tx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT1]</span><br><span class="line">create_generated_clock -name clk_rx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT0]</span><br><span class="line"></span><br><span class="line"># 设置异步时钟</span><br><span class="line">set_clock_groups -asynchronous -group [get_clocks clk_samp] -group [get_clocks clk2]</span><br><span class="line"></span><br><span class="line"># 延迟约束</span><br><span class="line">create_clock -period 6.000 -name virtual_clock</span><br><span class="line">set_input_delay -clock [get_clocks -of_objects [get_ports clk_pin_p]] 0.000 [get_ports rxd_pin]</span><br><span class="line">set_input_delay -clock [get_clocks -of_objects [get_ports clk_pin_p]] -min -0.500 [get_ports rxd_pin]</span><br><span class="line">set_input_delay -clock virtual_clock -max 0.000 [get_ports lb_sel_pin]</span><br><span class="line">set_input_delay -clock virtual_clock -min -0.500 [get_ports lb_sel_pin]</span><br><span class="line">set_output_delay -clock virtual_clock -max 0.000 [get_ports &#123;txd_pin &#123;led_pins[*]&#125;&#125;]</span><br><span class="line">set_output_delay -clock virtual_clock -min -0.500 [get_ports &#123;txd_pin &#123;led_pins[*]&#125;&#125;]</span><br><span class="line">set_output_delay -clock spi_clk -max 1.000 [get_ports &#123;spi_mosi_pin dac_cs_n_pin dac_clr_n_pin&#125;]</span><br><span class="line">set_output_delay -clock spi_clk -min -1.000 [get_ports &#123;spi_mosi_pin dac_cs_n_pin dac_clr_n_pin&#125;]</span><br><span class="line"></span><br><span class="line"># 伪路径约束</span><br><span class="line">set_false_path -from [get_clocks clk_rx] -to [get_clocks clk_tx]</span><br><span class="line">set_false_path -from [get_ports rst_pin]</span><br><span class="line"></span><br><span class="line"># 多周期约束</span><br><span class="line">set_multicycle_path 2 -setup -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;]</span><br><span class="line">set_multicycle_path 1 -hold -from [get_cells &#123;cmd_parse_i0&#x2F;send_resp_data_reg[*]&#125; -include_replicated_objects] -to [get_cells &#123;resp_gen_i0&#x2F;to_bcd_i0&#x2F;bcd_out_reg[*]&#125;]</span><br><span class="line"></span><br><span class="line"># 串口接收端</span><br><span class="line">set_multicycle_path 108 -setup -from [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL]</span><br><span class="line">set_multicycle_path 107 -hold -from [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_rx_i0&#x2F;uart_rx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL]</span><br><span class="line"># 串口发送端</span><br><span class="line">set_multicycle_path 90 -setup -from [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] </span><br><span class="line">set_multicycle_path 89 -hold -from [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL] -to [get_cells uart_tx_i0&#x2F;uart_tx_ctl_i0&#x2F;* -filter IS_SEQUENTIAL]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重新Synthesis并Implementation后，可以看到，已经没有了时序错误</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial49.png"  alt="" /></fancybox></center><p>&emsp;&emsp;仅有的两个warning也只是说rst没有设置input_delay，spi_clk_pin没有设置output_delay，但我们已经对rst设置了伪路径，而spi_clk_pin是我们约束的输出时钟，无需设置output_delay。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial49.png"  alt="" /></fancybox></center><p>&emsp;&emsp;到这里，教科书版的时序约束教程就基本讲完了。但我们平时的工程中，跟上面这种约束还是有差异的：</p><ol><li><p>首先是虚拟时钟，这个约束在平时的工程中基本不会用到，像需要设置虚拟时钟的场景，我们也都是通过设计来保证时序收敛，设置虚拟时钟的意义不大。    </p></li><li><p>第二就是output delay，在FPGA的最后一级寄存器到输出的路径上，往往都使用了IOB，也就是IO block，因此最后一级寄存器的位置是固定的，从buffer到pad的走线延时是确定的。在这种情况下，是否满足时序要求完全取决于设计，做约束只是验证一下看看时序是否收敛。所以也基本不做。但是input delay是需要的，因为这是上一级器件输出的时序关系。</p></li><li><p>第三个就是多周期路径，我们讲了那么多多周期路径的应用场景，但实际我们是根据Timing report来进行约束的，即便那几种场景都存在，但如果Timing report中没有提示任何的时序 warning，我们往往也不会去添加约束。</p></li><li><p>第四个就是在设置了多周期后，如果还是提示Intra-Clocks Paths的setup time不过，那就要看下程序，是否写的不规范。比如</p></li></ol><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=12" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p><strong>注：视频中5分37秒之后的内容有错误，在下面的文字部分已经删除，但视频不太好修改。请大家一定要注意，在这里向大家道歉。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-11-FPGA时序约束实战篇之伪路径约束</title>
      <link href="/blog/2020-06-15-1-11-false-path/"/>
      <url>/blog/2020-06-15-1-11-false-path/</url>
      
        <content type="html"><![CDATA[<h2 id="5-伪路径约束"><a href="#5-伪路径约束" class="headerlink" title="5. 伪路径约束"></a>5. 伪路径约束</h2><p>&emsp;&emsp;在不加伪路径的时序约束时，Timing Report会提示很多的error，其中就有跨时钟域的error。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial47.png"  alt="" /></fancybox></center><a id="more"></a><p>我们可以直接在上面右键，然后设置两个时钟的伪路径。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial62.png?raw=true"  alt="" /></fancybox></center><p>这样会在xdc中自动生成如下约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -from [get_clocks -of_objects [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT0]] -to [get_clocks -of_objects [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT1]]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这两个时钟我们已经在前面通过generated指令创建过了，因此get_pins那一长串就没必要重复写了，所以我们可以手动添加这两个时钟的伪路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -from [get_clocks clk_rx] -to [get_clocks clk_tx]</span><br></pre></td></tr></table></figure><p>伪路径的设置是单向的，如果两个时钟直接存在相互的数据的传输，则还需要添加从<code>clk_tx</code>到<code>clk_rx</code>的路径，这个工程中只有从rx到tx的数据传输，因此这一条就可以了。</p><p>这里再修改一条第7讲中的错误，第7讲中时钟树的图里，只有从<code>clk_rx</code>到<code>clk_tx</code>的箭头，不应该有从<code>clk_tx</code>到<code>clk_rx</code>的箭头。</p><p>&emsp;&emsp;在伪路径一节中，我们讲到过异步复位也需要添加伪路径，<code>rst_pin</code>的复位输入在本工程中就是当做异步复位使用，因此还需要添加一句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -from [get_ports rst_pin]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于<code>clk_samp</code>和<code>clk2</code>，它们之间存在数据交换，但我们在前面已经约束过<code>asynchronous</code>了，这里就可以不用重复约束了。</p><p>&emsp;&emsp;这里需要提示一点，添加了上面这些约束后，综合时会提示xdc文件的的warning。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial48.png"  alt="" /></fancybox></center><p>但这可能是Vivado的综合过程中，读取到该约束文件时，内部电路并未全都建好，就出现了没有发现<code>clk_gen_i0/clk_core_i0/inst/mmcm_adv_inst/CLKIN1</code>等端口的情况，有如下几点证明：</p><ol><li>这个端口在代码中确实是存在的</li><li>若把该xdc文件，设置为仅在Implementation中使用，则不会提示该warning</li><li>在Implementation完成后，无论是Timing Report还是通过tcl的<code>report_clocks</code>指令，都可以看到这几个时钟已经被正确约束。下图所示即为设置完上面的约束后的Timing Report。</li></ol><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial61.png?raw=true"  alt="" /></fancybox></center><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=11" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-10-FPGA时序约束实战篇之延迟约束</title>
      <link href="/blog/2020-06-13-1-10-dealy-constraints/"/>
      <url>/blog/2020-06-13-1-10-dealy-constraints/</url>
      
        <content type="html"><![CDATA[<h2 id="延迟约束"><a href="#延迟约束" class="headerlink" title="延迟约束"></a>延迟约束</h2><p>&emsp;&emsp;对于延迟约束，相信很多同学是不怎么用的，主要可能就是不熟悉这个约束，也有的是嫌麻烦，因为有时还要计算PCB上的走线延迟导致的时间差。而且不加延迟约束，Vivado也只是在Timing Report中提示warning，并不会导致时序错误，这也会让很多同学误以为这个约束可有可无。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial45.png"  alt="" /></fancybox></center><a id="more"></a><p>&emsp;&emsp;但其实这种想法是不对的，比如在很多ADC的设计中，输出的时钟的边沿刚好是数据的中心位置，而如果我们不加延迟约束，则Vivado会默认时钟和数据是对齐的。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial46.png"  alt="" /></fancybox></center><p>&emsp;&emsp;对于输入管脚，首先判断捕获时钟是主时钟还是衍生时钟，如果是主时钟，直接用<code>set_input_delay</code>即可，如果是衍生时钟，要先创建虚拟时钟，然后再设置delay。对于输出管脚，判断有没有输出随路时钟，若有，则直接使用<code>set_output_delay</code>，若没有，则需要创建虚拟时钟。</p><p>&emsp;&emsp;在本工程中，输入输出数据管脚的捕获时钟如下表所示：</p><table><thead><tr><th>管脚</th><th>输入输出</th><th>捕获时钟</th><th>时钟类型</th><th>是否有随路时钟</th><th>是否需要虚拟时钟</th></tr></thead><tbody><tr><td>rxd_pin</td><td>输入</td><td>clk_pin_p</td><td>主时钟</td><td>x</td><td>No</td></tr><tr><td>txd_pin</td><td>输出</td><td>clk_tx</td><td>x</td><td>无</td><td>Yes</td></tr><tr><td>lb_sel_pin</td><td>输入</td><td>clk_tx</td><td>衍生时钟</td><td>x</td><td>Yes</td></tr><tr><td>led_pins[7:0]</td><td>输出</td><td>clk_tx</td><td>衍生时钟</td><td>无</td><td>Yes</td></tr><tr><td>spi_mosi_pin</td><td>输出</td><td>spi_clk</td><td>衍生时钟</td><td>有</td><td>No</td></tr><tr><td>dac_*</td><td>输出</td><td>spi_clk</td><td>衍生时钟</td><td>有</td><td>No</td></tr></tbody></table><p>&emsp;&emsp;根据上表，我们创建的延迟约束如下，其中的具体数字在实际工程中要根据上下游器件的时序关系（在各个器件手册中可以找到）和PCB走线延迟来决定。未避免有些约束有歧义，我们把前面的所有约束也加进来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 主时钟约束</span><br><span class="line">create_clock -period 25.000 -name clk2 [get_ports clk_in2]</span><br><span class="line"></span><br><span class="line"># 衍生时钟约束</span><br><span class="line">create_generated_clock -name clk_samp -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_tx] -divide_by 32 [get_pins clk_gen_i0&#x2F;BUFHCE_clk_samp_i0&#x2F;O]</span><br><span class="line">create_generated_clock -name spi_clk -source [get_pins dac_spi_i0&#x2F;out_ddr_flop_spi_clk_i0&#x2F;ODDR_inst&#x2F;C] -divide_by 1 -invert [get_ports spi_clk_pin]</span><br><span class="line">create_generated_clock -name clk_tx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT1]</span><br><span class="line">create_generated_clock -name clk_rx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT0]</span><br><span class="line"></span><br><span class="line"># 设置异步时钟</span><br><span class="line">set_clock_groups -asynchronous -group [get_clocks clk_samp] -group [get_clocks clk2]</span><br><span class="line"></span><br><span class="line"># 延迟约束</span><br><span class="line">create_clock -period 6.000 -name virtual_clock</span><br><span class="line">set_input_delay -clock [get_clocks -of_objects [get_ports clk_pin_p]] 0.000 [get_ports rxd_pin]</span><br><span class="line">set_input_delay -clock [get_clocks -of_objects [get_ports clk_pin_p]] -min -0.500 [get_ports rxd_pin]</span><br><span class="line">set_input_delay -clock virtual_clock -max 0.000 [get_ports lb_sel_pin]</span><br><span class="line">set_input_delay -clock virtual_clock -min -0.500 [get_ports lb_sel_pin]</span><br><span class="line">set_output_delay -clock virtual_clock -max 0.000 [get_ports &#123;txd_pin &#123;led_pins[*]&#125;&#125;]</span><br><span class="line">set_output_delay -clock virtual_clock -min -0.500 [get_ports &#123;txd_pin &#123;led_pins[*]&#125;&#125;]</span><br><span class="line">set_output_delay -clock spi_clk -max 1.000 [get_ports &#123;spi_mosi_pin dac_cs_n_pin dac_clr_n_pin&#125;]</span><br><span class="line">set_output_delay -clock spi_clk -min -1.000 [get_ports &#123;spi_mosi_pin dac_cs_n_pin dac_clr_n_pin&#125;]</span><br></pre></td></tr></table></figure><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=10" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-9-FPGA时序约束实战篇之衍生时钟约束</title>
      <link href="/blog/2020-06-12-1-9-generated-clock/"/>
      <url>/blog/2020-06-12-1-9-generated-clock/</url>
      
        <content type="html"><![CDATA[<h2 id="约束衍生时钟"><a href="#约束衍生时钟" class="headerlink" title="约束衍生时钟"></a>约束衍生时钟</h2><p>&emsp;&emsp;系统中有4个衍生时钟，但其中有两个是MMCM输出的，不需要我们手动约束，因此我们只需要对<code>clk_samp</code>和<code>spi_clk</code>进行约束即可。约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create_generated_clock -name clk_samp -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;clk_tx] -divide_by 32 [get_pins clk_gen_i0&#x2F;BUFHCE_clk_samp_i0&#x2F;O]</span><br><span class="line">create_generated_clock -name spi_clk -source [get_pins dac_spi_i0&#x2F;out_ddr_flop_spi_clk_i0&#x2F;ODDR_inst&#x2F;C] -divide_by 1 -invert [get_ports spi_clk_pin]</span><br></pre></td></tr></table></figure><a id="more"></a><p>&emsp;&emsp;我们再运行<code>report_clocks</code>，显示如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial43.png"  alt="" /></fancybox></center><p>我们在理论篇的“create_generated_clock”一节中讲到，我们可以重新设置Vivado自动生成的衍生时钟的名字，这样可以更方便我们后续的使用。按照前文所讲，只需设置<code>name</code>和<code>source</code>参数即可，其中这个<code>source</code>可以直接从<code>report_clocks</code>中得到，因此我们的约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create_generated_clock -name clk_tx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT1]</span><br><span class="line">create_generated_clock -name clk_rx -source [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKIN1] [get_pins clk_gen_i0&#x2F;clk_core_i0&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT0]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;大家可以对比下<code>report_clocks</code>的内容和约束指令，很容易就能看出它们之间的关系。</p><p>把上述的约束指令在tcl中运行后，我们再运行一遍<code>report_clocks</code>，显示如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial44.png"  alt="" /></fancybox></center><p>在时序树的分析中，我们看到，<code>clk_samp</code>和<code>clk2</code>两个异步时钟之间存在数据交互，因此要进行约束，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_clock_groups -asynchronous -group [get_clocks clk_samp] -group [get_clocks clk2]</span><br></pre></td></tr></table></figure><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-8-FPGA时序约束实战篇之主时钟约束</title>
      <link href="/blog/2020-06-10-1-8-primiry-clock/"/>
      <url>/blog/2020-06-10-1-8-primiry-clock/</url>
      
        <content type="html"><![CDATA[<h2 id="约束主时钟"><a href="#约束主时钟" class="headerlink" title="约束主时钟"></a>约束主时钟</h2><p>&emsp;&emsp;在这一节开讲之前，我们先把<code>wave_gen</code>工程的<code>wave_gen_timing.xdc</code>中的内容都删掉，即先看下在没有任何时序约束的情况下会综合出什么结果？</p><a id="more"></a><p>对工程综合并Implementation后，Open Implemented Design，会看到下图所示内容。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial40.png"  alt="" /></fancybox></center><p>&emsp;&emsp;可以看到，时序并未收敛。可能到这里有的同学就会有疑问，我们都已经把时序约束的内容都删了，按我们第一讲中提到的“因此如果我们不加时序约束，软件是无法得知我们的时钟周期是多少，PAR后的结果是不会提示时序警告的”，这是因为在该工程中，用了一个MMCM，并在里面设置了输入信号频率，因此这个时钟软件会自动加上约束。</p><p>&emsp;&emsp;接下来，我们在tcl命令行中输入<code>report_clock_networks -name main</code>，显示如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial41.png"  alt="" /></fancybox></center><p>&emsp;&emsp;可以看出，Vivado会自动设别出两个主时钟，其中clk_pin_p是200MHz，这个是直接输入到了MMCM中，因此会自动约束；另一个输入时钟clk_in2没有约束，需要我们手动进行约束。</p><p>或者可以使用<code>check_timing -override_defaults no_clock</code>指令，这个指令我们之前的内容讲过，这里不再重复讲了。</p><p>&emsp;&emsp;在tcl中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name clk2 -period 25 [get_ports clk_in2]</span><br></pre></td></tr></table></figure><p>注：在Vivado中，可以直接通过tcl直接运行时序约束脚本，运行后Vivado会自动把这些约束加入到xdc文件中。</p><p>再执行<code>report_clock_networks -name main</code>，显示如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial42.png"  alt="" /></fancybox></center><p>可以看到，主时钟都已被正确约束。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-7-FPGA时序约束实战篇之梳理时钟树</title>
      <link href="/blog/2020-06-08-1-7-clock-tree/"/>
      <url>/blog/2020-06-08-1-7-clock-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="行万里路–时序约束实战篇"><a href="#行万里路–时序约束实战篇" class="headerlink" title="行万里路–时序约束实战篇"></a>行万里路–时序约束实战篇</h1><p>&emsp;&emsp;我们以Vivado自带的<code>wave_gen</code>工程为例，该工程的各个模块功能较为明确，如下图所示。为了引入异步时钟域，我们在此程序上又增加了另一个时钟–<code>clkin2</code>，该时钟产生脉冲信号<code>pulse</code>，<code>samp_gen</code>中在<code>pulse</code>为高时才产生信号。</p><a id="more"></a><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial37.png"  alt="" /></fancybox></center><p>下面我们来一步一步进行时序约束。</p><h2 id="1-梳理时钟树"><a href="#1-梳理时钟树" class="headerlink" title="1. 梳理时钟树"></a>1. 梳理时钟树</h2><p>&emsp;&emsp;我们首先要做的就是梳理时钟树，就是工程中用到了哪些时钟，各个时钟之间的关系又是什么样的，如果自己都没有把时钟关系理清楚，不要指望综合工具会把所有问题暴露出来。</p><p>&emsp;&emsp;在我们这个工程中，有两个主时钟，四个衍生时钟，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial38.png"  alt="" /></fancybox></center><p>&emsp;&emsp;确定了主时钟和衍生时钟后，再看各个时钟是否有交互，即clka产生的数据是否在clkb的时钟域中被使用。</p><p>&emsp;&emsp;这个工程比较简单，只有两组时钟之间有交互，即：</p><ul><li><code>clk_rx</code>与<code>clk_tx</code></li><li><code>clk_samp</code>与<code>clk2</code></li></ul><p>其中，<code>clk_rx</code>和<code>clk_tx</code>都是从同一个MMCM输出的，两个频率虽然不同，但他们却是同步的时钟，因此他们都是从同一个时钟分频得到（可以在Clock Wizard的Port Renaming中看到VCO Freq的大小），因此它们之间需要用<code>set_false_path</code>来约束；而<code>clk_samp</code>和<code>clk2</code>是两个异步时钟，需要用<code>asynchronous</code>来约束。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial39.png"  alt="" /></fancybox></center><p>完成以上两步，就可以进行具体的时钟约束操作了。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-6-FPGA时序约束理论篇之xdc约束优先级</title>
      <link href="/blog/2020-06-07-1-6-xdc-priority/"/>
      <url>/blog/2020-06-07-1-6-xdc-priority/</url>
      
        <content type="html"><![CDATA[<h2 id="xdc约束优先级"><a href="#xdc约束优先级" class="headerlink" title="xdc约束优先级"></a>xdc约束优先级</h2><p>&emsp;&emsp;在xdc文件中，按约束的先后顺序依次被执行，因此，针对同一个时钟的不同约束，只有最后一条约束生效。</p><p>&emsp;&emsp;虽然执行顺序是从前到后，但优先级却不同；就像四则运算一样，+-x÷都是按照从左到右的顺序执行，但x÷的优先级比+-要高。</p><p>时序例外的优先级从高到低为：</p><ol><li>Clock Groups (set_clock_groups)</li><li>False Path (set_false_path)</li><li>Maximum Delay Path (set_max_delay) and Minimum Delay Path (set_min_delay)</li><li>Multicycle Paths (set_multicycle_path)</li></ol><a id="more"></a><p><code>set_bus_skew</code>约束并不影响上述优先级且不与上述约束冲突。原因在于set_bus_skew并不是某条路径上的约束，而是路径与路径之间的约束。</p><p>&emsp;&emsp;对于同样的约束，定义的越精细，优先级越高。各对象的约束优先级从高到低为：</p><ol><li>ports-&gt;pins-&gt;cells</li><li>clocks。</li></ol><p>&emsp;&emsp;路径声明的优先级从高到低为：</p><ol><li>-from -through -to</li><li>-from -to</li><li>-from -through</li><li>-from</li><li>-through -to</li><li>-to</li><li>-through</li></ol><p><strong><em>优先考虑对象，再考虑路径。</em></strong></p><p>&emsp;&emsp;Example1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay 12 -from [get_clocks clk1] -to [get_clocks clk2]</span><br><span class="line">set_max_delay 15 -from [get_clocks clk1]</span><br></pre></td></tr></table></figure><p>该约束中，第一条约束会覆盖第二条约束。</p><p>&emsp;&emsp;Example2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay 12 -from [get_cells inst0] -to [get_cells inst1]</span><br><span class="line">set_max_delay 15 -from [get_clocks clk1] -through [get_pins hier0&#x2F;p0] -to</span><br><span class="line">[get_cells inst1]</span><br></pre></td></tr></table></figure><p>该约束中，第一条约束会覆盖第二条约束。</p><p>&emsp;&emsp;Example3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay 4 -through [get_pins inst0&#x2F;I0]</span><br><span class="line">set_max_delay 5 -through [get_pins inst0&#x2F;I0] -through [get_pins inst1&#x2F;I3]</span><br></pre></td></tr></table></figure><p>这个约束中，两条都会存在，这也使得时序收敛的难度更大，因为这两条语句合并成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay 4 -through [get_pins inst0&#x2F;I0] -through [get_pins inst1&#x2F;I3]</span><br></pre></td></tr></table></figure><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=6" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-5-FPGA时序约束理论篇之两种时序例外</title>
      <link href="/blog/2020-06-06-1-5-Timing-Exceptions/"/>
      <url>/blog/2020-06-06-1-5-Timing-Exceptions/</url>
      
        <content type="html"><![CDATA[<h2 id="两种时序例外"><a href="#两种时序例外" class="headerlink" title="两种时序例外"></a>两种时序例外</h2><h3 id="多周期路径"><a href="#多周期路径" class="headerlink" title="多周期路径"></a>多周期路径</h3><p>&emsp;&emsp;上面我们讲的是时钟周期约束，默认按照单周期关系来分析数据路径，即数据的发起沿和捕获沿是最邻近的一对时钟沿。如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial20.png"  alt="" /></fancybox></center><a id="more"></a><p>&emsp;&emsp;默认情况下,保持时间的检查是以建立时间的检查为前提,即总是在建立时间的前一个时钟周期确定保持时间检查。这个也不难理解，上面的图中，数据在时刻1的边沿被发起，建立时间的检查是在时刻2进行，而保持时间的检查是在时刻1（如果这里不能理解，再回头看我们讲保持时间章节的内容），因此保持时间的检查是在建立时间检查的前一个时钟沿。</p><p>&emsp;&emsp;但在实际的工程中，经常会碰到数据被发起后，由于路径过长或者逻辑延迟过长要经过多个时钟周期才能到达捕获寄存器；又或者在数据发起的几个周期后，后续逻辑才能使用。这时如果按照单周期路径进行时序检查，就会报出时序违规。因此就需要我们这一节所讲的多周期路径了。</p><p>多周期约束的语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path &lt;num_cycles&gt; [-setup|-hold] [-start|-end][-from &lt;startpoints&gt;] [-to &lt;endpoints&gt;] [-through &lt;pins|cells|nets&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>num_cycles [-setup  -hold]</td><td>建立/保持时间的周期个数</td></tr><tr><td>[-start  -end]</td><td>参数时钟选取</td></tr><tr><td>-from <startpoint></td><td>发起点</td></tr><tr><td>-to <endpoint></td><td>捕获点</td></tr><tr><td>-through &lt;pins/cells/nets&gt;</td><td>经过点</td></tr></tbody></table><p>对于建立时间，num_cycles是指多周期路径所需的时钟周期个数；对于保持时间，num_cycles是指相对于默认的捕获沿，实际捕获沿应回调的周期个数。</p><p>发起沿和捕获沿可能是同一个时钟，也可能是两个时钟，参数<code>start</code>和<code>end</code>就是选择参考时钟是发送端还是接收端。</p><ul><li>start表示参考时钟为发送端（发端）所用时钟，对于保持时间的分析，若后面没有指定<code>start</code>或<code>end</code>，则默认为为-start；</li><li>end表示参考时钟为捕获端（收端）所用时钟,对于建立时间的分析，若后面没有指定<code>start</code>或<code>end</code>，则默认为为-end；</li></ul><p>上面这两句话也不难理解，因为setup-time是在下一个时钟沿进行捕获时的约束，因此默认是对接收端的约束；而hold-up-time是对同一个时钟沿的约束，目的是发送端不能太快，是对发送端的约束。</p><p>&emsp;&emsp;对于单周期路径来说，setup的num_cycles为1，hold的num_cycles为0.</p><p>&emsp;&emsp;多周期路径要分以下几种情况进行分析：</p><p><strong>1. 单时钟域</strong></p><p>&emsp;&emsp;即发起时钟和捕获时钟是同一个时钟，其多周期路径模型如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial21.png"  alt="" /></fancybox></center><p>&emsp;&emsp;单时钟域的多周期路径常见于带有使能的电路中，我们以双时钟周期路径为例，其实现电路如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial22.png"  alt="" /></fancybox></center><p>&emsp;&emsp;若我们没有指定任何的约束，默认的建立/保持时间的分析就像我们上面所讲的单周期路径，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial23.png"  alt="" /></fancybox></center><p>&emsp;&emsp;但由于我们的的数据经过了两个时钟周期才被捕获，因此建立时间的分析时需要再延迟一个周期的时间。</p><p>采用如下的时序约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 2 -setup -from [get_pins data0_reg&#x2F;C] -to [get_pins data1_reg&#x2F;D]</span><br></pre></td></tr></table></figure><p>在建立时间被修改后，保持时间也会自动调整到捕获时钟沿的前一个时钟沿，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial24.png"  alt="" /></fancybox></center><p>很明显，这个保持时间检查是不对的，因为保持时间的检查针对的是同一个时钟沿，因此我们要把保持时间往回调一个周期，需要再增加一句约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 1 -hold -end -from [get_pins data0_reg&#x2F;C]  -to [get_pins data1_reg&#x2F;D]</span><br></pre></td></tr></table></figure><p>这里加上<code>-end</code>参数是因为我们要把捕获时钟沿往前移，因此针对的是接收端，但由于我们这边讲的是单时钟域，发送端和接收端的时钟是同一个，因此<code>-end</code>可以省略。这样，完整的时序约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 2 -setup -from [get_pins data0_reg&#x2F;C] -to [get_pins data1_reg&#x2F;D]</span><br><span class="line">set_multicycle_path 1 -hold  -from [get_pins data0_reg&#x2F;C]  -to [get_pins data1_reg&#x2F;D]</span><br></pre></td></tr></table></figure><p>约束完成后，建立保持时间检查如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial25.png"  alt="" /></fancybox></center><p>&emsp;&emsp;在单时钟域下，若数据经过N个周期到达，则约束示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path N -setup -from [get_pins data0_reg&#x2F;C] -to [get_pins data1_reg&#x2F;D]</span><br><span class="line">set_multicycle_path N-1 -hold  -from [get_pins data0_reg&#x2F;C]  -to [get_pins data1_reg&#x2F;D]</span><br></pre></td></tr></table></figure><p><strong>2. 时钟相移</strong></p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial26.png"  alt="" /></fancybox></center><p>&emsp;&emsp;前面我们讨论的是在单时钟域下，发送端和接收端时钟是同频同相的，如果两个时钟同频不同相怎么处理？</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial27.png"  alt="" /></fancybox></center><p>&emsp;&emsp;如上图所示，时钟周期为4ns，接收端的时钟沿比发送端晚了0.3ns，若不进行约束，建立时间只有0.3ns，时序基本不可能收敛；而保持时间则为3.7ns，过于丰富。可能有的同学对保持时间会有疑惑，3.7ns是怎么来的？还记得我们上面讲的保持时间的定义么，在0ns时刻，接收端捕获到发送的数据后，要再过3.7ns的时间发送端才会发出下一个数据，因此本次捕获的数据最短可持续3.7ns，即保持时间为3.7ns。</p><p>&emsp;&emsp;因此，在这种情况下，我们应把捕获沿向后移一个周期，约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 2 -setup -from [get_clocks CLK1] -to [get_clocks CLK2]</span><br></pre></td></tr></table></figure><p>对setup约束后，hold会自动向后移动一个周期，此时的建立保持时间检查如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial28.png"  alt="" /></fancybox></center><p>&emsp;&emsp;那如果接收端的时钟比发送端的时钟超前了怎么处理？</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial29.png"  alt="" /></fancybox></center><p>&emsp;&emsp;同样的，时钟周期为4ns，但接收端时钟超前了0.3ns，从图中可以看出，此时setup是3.7ns，而保持时间是0.3ns。这两个时间基本已经满足了Xilinx器件的要求，因此无需进行约束。</p><p><strong>3. 慢时钟到快时钟的多周期</strong></p><p>&emsp;&emsp;当发起时钟慢于捕获时钟时，我们应该如何处理？</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial30.png"  alt="" /></fancybox></center><p>&emsp;&emsp;假设捕获时钟频率是发起时钟频率的3倍，在没有任何约束的情况下，Vivado默认会按照如下图所示的建立保持时间进行分析。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial31.png"  alt="" /></fancybox></center><p>&emsp;&emsp;但我们可以通过约束让建立时间的要求更容易满足，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 3 -setup -from [get_clocks CLK1] -to [get_clocks CLK2]</span><br></pre></td></tr></table></figure><p>跟上面讲的一样，设置了setup，hold会自动变化，但我们不希望hold变化，因此再增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 2 -hold -end -from [get_clocks CLK1] -to [get_clocks CLK2]</span><br></pre></td></tr></table></figure><p>这里由于发起和捕获是两个时钟，因此<code>-end</code>参数是不可省的。加上时序约束后，Vivado会按照下面的方式进行时序分析。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial32.png"  alt="" /></fancybox></center><p><strong>4. 快时钟到慢时钟的多周期</strong></p><p>&emsp;&emsp;当发起时钟快于捕获时钟时，我们应该如何处理？</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial33.png"  alt="" /></fancybox></center><p>&emsp;&emsp;假设发起时钟频率是捕获时钟频率的3倍，在没有任何约束的情况下，Vivado默认会按照如下图所示的建立保持时间进行分析。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial34.png"  alt="" /></fancybox></center><p>&emsp;&emsp;同理，我们可以通过约束，让时序条件更加宽裕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path 3 -setup -start -from [get_clocks CLK1] -to [get_clocks CLK2]</span><br><span class="line">set_multicycle_path 2 -hold -from [get_clocks CLK1] -to [get_clocks CLK2]</span><br></pre></td></tr></table></figure><p>这里的hold约束中没有加<code>-end</code>参数，这样的话默认就是<code>-start</code>，是因为我们把发起时钟回调2个周期，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial35.png"  alt="" /></fancybox></center><p>针对上面讲的几种多周期路径，总结如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial36.png"  alt="" /></fancybox></center><h3 id="伪路径"><a href="#伪路径" class="headerlink" title="伪路径"></a>伪路径</h3><p>&emsp;&emsp;什么是伪路径？伪路径指的是该路径存在，但该路径的电路功能不会发生或者无须时序约束。如果路径上的电路不会发生，那Vivado综合后会自动优化掉，因此我们无需考虑这种情况。</p><p>&emsp;&emsp;为什么要创建伪路径？创建伪路径可以减少工具运行优化时间,增强实现结果,避免在不需要进行时序约束的地方花较多时间而忽略了真正需要进行优化的地方。</p><p>&emsp;&emsp;伪路径一般用于：</p><ul><li>跨时钟域</li><li>一上电就被写入数据的寄存器</li><li>异步复位或测试逻辑</li><li>异步双端口RAM</li></ul><p>&emsp;&emsp;可以看出，伪路径主要就是用在异步时钟的处理上，我们上一节讲的多周期路径中，也存在跨时钟域的情况的，但上面我们讲的是两个同步的时钟域。</p><p>伪路径的约束为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_false_path [-setup] [-hold] [-from &lt;node_list&gt;] [-to &lt;node_list&gt;] [-through &lt;node_list&gt;]</span><br></pre></td></tr></table></figure><ul><li><p><code>-from</code>的节点应是有效的起始点.有效的起始点包含时钟对象,时序单元的clock引脚,或者input(or inout)原语;</p></li><li><p><code>-to</code>的节点应包含有效的终结点.一个有效的终结点包含时钟对象,output(or inout)原语端口,或者时序功能单元的数据输入端口;</p></li><li><p><code>-through</code>的节点应包括引脚,端口,或线网.当单独使用-through时,应注意所有路径中包含-through节点的路径都将被时序分析工具所忽略.</p></li></ul><p>需要注意的是，<code>-through</code>是有先后顺序的，下面的两个约束是不同的约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -through cell1&#x2F;pin1 -through cell2&#x2F;pin2</span><br><span class="line">set_false_path -through cell2&#x2F;pin2 -through cell1&#x2F;pin1</span><br></pre></td></tr></table></figure><p>因为它们经过的先后顺序不同，伪路径的约束是单向的，并非双向的，若两个时钟域相互之间都有数据传输，则应采用如下约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -from [get_clocks clk1] -to [get_clocks clk2]</span><br><span class="line">set_false_path -from [get_clocks clk2] -to [get_clocks clk1]</span><br></pre></td></tr></table></figure><p>也可以直接采用如下的方式，与上述两行约束等效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_clock_groups -async -group [get_clocks clk1] -to [get_clocks clk2]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还有一些其他的约束，比如case analysis、disabling timing和bus_skew等，由于平时用的比较少，这里就不讲了。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-4-FPGA时序约束理论篇之时钟周期约束</title>
      <link href="/blog/2020-06-05-1-4-clock-period-constraints/"/>
      <url>/blog/2020-06-05-1-4-clock-period-constraints/</url>
      
        <content type="html"><![CDATA[<h2 id="时钟周期约束"><a href="#时钟周期约束" class="headerlink" title="时钟周期约束"></a>时钟周期约束</h2><p>&emsp;&emsp;时钟周期约束，顾名思义，就是我们对时钟的周期进行约束，这个约束是我们用的最多的约束了，也是最重要的约束。</p><p>&emsp;&emsp;下面我们讲一些Vivado中时钟约束指令。</p><p> <strong>1. Create_clock</strong></p><p>&emsp;&emsp;在Vivado中使用<code>create_clock</code>来创建时钟周期约束。使用方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name &lt;name&gt; -period &lt;period&gt; -waveform &#123;&lt;rise_time&gt; &lt;fall_time&gt;&#125; [get_ports &lt;input_port&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-name</td><td>时钟名称</td></tr><tr><td>-period</td><td>时钟周期，单位为ns</td></tr><tr><td>-waveform</td><td>波形参数，第一个参数为时钟的第一个上升沿时刻，第二个参数为时钟的第一个下降沿时刻</td></tr><tr><td>-add</td><td>在同一时刻源上定义多个时钟时使用</td></tr></tbody></table><a id="more"></a><p>&emsp;&emsp;这里的时钟必须是主时钟<code>primary clock</code>，<strong>主时钟</strong>通常有两种情形:一种是时钟由外部时钟源提供，通过时钟引脚进入FPGA，该时钟引脚绑定的时钟为主时钟:另一种是高速收发器(GT)的时钟RXOUTCLK或TXOUTCLK。对于7系列FPGA，需要对GT的这两个时钟手工约束：对于UltraScale FPGA，只需对GT的输入时钟约束即可，Vivado会自动对这两个时钟约束。</p><p>&emsp;&emsp;如何确定主时钟是时钟周期约束的关键，除了根据主时钟的两种情形判断之外，还可以借助Tcl脚本判断。</p><p>&emsp;&emsp;在vivado自带的example project里面，打开CPU(HDL)的工程，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial10.png"  alt="" /></fancybox></center><p>把工程的xdc文件中，<code>create_clock</code>的几项都注释掉。这里解释下端口（Port）和管脚（Pin）。get_ports获取的是FPGA的IO端口，get_pins获取的是FPGA内部子模块的Pin，具体的我们在第14讲的Tcl命令中会讲到。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial11.png"  alt="" /></fancybox></center><p>再<code>Open Synthesized Design</code>或者<code>Open Implementation Design</code>，并通过以下两种方式查看主时钟。</p><ul><li>方式一</li></ul><p>运行tcl指令<code>report_clock_networks -name mainclock</code>，显示结果如下：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial12.png"  alt="" /></fancybox></center><ul><li>方式二<br>运行tcl指令<code>check_timing -override_defaults no_clock</code>，显示结果如下：</li></ul><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial13.png"  alt="" /></fancybox></center><p><strong><em>Vivado中的tcl命令行相当好用，有很多的功能，大家可以开始习惯用起来了。</em></strong></p><p>&emsp;&emsp;对于高速收发器的时钟，我们也以Vivado中的CPU example工程为例，看下Xilinx官方是怎么约束的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Define the clocks for the GTX blocks</span><br><span class="line">create_clock -name gt0_txusrclk_i -period 12.8 [get_pins mgtEngine&#x2F;ROCKETIO_WRAPPER_TILE_i&#x2F;gt0_ROCKETIO_WRAPPER_TILE_i&#x2F;gtxe2_i&#x2F;TXOUTCLK]</span><br><span class="line">create_clock -name gt2_txusrclk_i -period 12.8 [get_pins mgtEngine&#x2F;ROCKETIO_WRAPPER_TILE_i&#x2F;gt2_ROCKETIO_WRAPPER_TILE_i&#x2F;gtxe2_i&#x2F;TXOUTCLK]</span><br><span class="line">create_clock -name gt4_txusrclk_i -period 12.8 [get_pins mgtEngine&#x2F;ROCKETIO_WRAPPER_TILE_i&#x2F;gt4_ROCKETIO_WRAPPER_TILE_i&#x2F;gtxe2_i&#x2F;TXOUTCLK]</span><br><span class="line">create_clock -name gt6_txusrclk_i -period 12.8 [get_pins mgtEngine&#x2F;ROCKETIO_WRAPPER_TILE_i&#x2F;gt6_ROCKETIO_WRAPPER_TILE_i&#x2F;gtxe2_i&#x2F;TXOUTCLK]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当系统中有多个主时钟，且这几个主时钟之间存在确定的相位关系时，需要用到<code>-waveform</code>参数。如果有两个主时钟，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial14.png"  alt="" /></fancybox></center><p>则时钟约束为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name clk0 -period 10.0 -waveform &#123;0 5&#125; [get_ports clk0]</span><br><span class="line">create_clock -name clk1 -period 8.0 -waveform &#123;2 8&#125; [get_ports clk1]</span><br></pre></td></tr></table></figure><p>约束中的数字的单位默认是ns，若不写<code>wavefrom</code>参数，则默认是占空比为50%且第一个上升沿出现在0时刻。使用<code>report_clocks</code>指令可以查看约束是否生效。还是上面的CPU的例子，把约束都还原到最初的状态。执行<code>report_clocks</code>后，如下所示，我们只列出其中几项内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Clock Report</span><br><span class="line"></span><br><span class="line">Clock           Period(ns)  Waveform(ns)    Attributes  Sources</span><br><span class="line">sysClk          10.000      &#123;0.000 5.000&#125;   P           &#123;sysClk&#125;</span><br><span class="line">gt0_txusrclk_i  12.800      &#123;0.000 6.400&#125;   P           &#123;mgtEngine&#x2F;ROCKETIO_WRAPPER_TILE_i&#x2F;gt0_ROCKETIO_WRAPPER_TILE_i&#x2F;gtxe2_i&#x2F;TXOUTCLK&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Generated Clocks</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Generated Clock   : clkfbout</span><br><span class="line">Master Source     : clkgen&#x2F;mmcm_adv_inst&#x2F;CLKIN1</span><br><span class="line">Master Clock      : sysClk</span><br><span class="line">Multiply By       : 1</span><br><span class="line">Generated Sources : &#123;clkgen&#x2F;mmcm_adv_inst&#x2F;CLKFBOUT&#125;</span><br><span class="line"></span><br><span class="line">Generated Clock   : cpuClk_4</span><br><span class="line">Master Source     : clkgen&#x2F;mmcm_adv_inst&#x2F;CLKIN1</span><br><span class="line">Master Clock      : sysClk</span><br><span class="line">Edges             : &#123;1 2 3&#125;</span><br><span class="line">Edge Shifts(ns)   : &#123;0.000 5.000 10.000&#125;</span><br><span class="line">Generated Sources : &#123;clkgen&#x2F;mmcm_adv_inst&#x2F;CLKOUT0&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一般来讲，我们的输入时钟都是差分的，此时我们只对P端进行约束即可。如果同时约束了P端和N端，通过<code>report_clock_interaction</code>命令可以看到提示unsafe。这样既会增加内存开销，也会延长编译时间。</p><p> <strong>2. create_generated_clock</strong></p><p>其使用方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create_generated_clock -name &lt;generated_clock_name&gt; \</span><br><span class="line">                       -source &lt;master_clock_source_pin_or_port&gt; \</span><br><span class="line">                       -multiply_by &lt;mult_factor&gt; \</span><br><span class="line">                       -divide_by &lt;div_factor&gt; \</span><br><span class="line">                       -master_clock &lt;master_clk&gt; \</span><br><span class="line">                       &lt;pin_or_port&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-name</td><td>时钟名称</td></tr><tr><td>-source</td><td>产生该时钟的源时钟</td></tr><tr><td>-multiply_by</td><td>源时钟的多少倍频</td></tr><tr><td>-divide_by</td><td>源时钟的多少分频</td></tr></tbody></table><p>&emsp;&emsp;从名字就能看出来，这个是约束我们在FPGA内部产生的衍生时钟， 所以参数在中有个<code>-source</code>，就是指定这个时钟是从哪里来的，这个时钟叫做<code>master clock</code>，是指上级时钟，区别于<code>primary clock</code>。<br>它可以是我们上面讲的primary clock，也可以是其他的衍生时钟。该命令不是设定周期或波形，而是描述时钟电路如何对上级时钟进行转换。这种转换可以是下面的关系：</p><ul><li>简单的频率分频</li><li>简单的频率倍频</li><li>频率倍频与分频的组合，获得一个非整数的比例，通常由MMCM或PLL完成</li><li>相移或波形反相</li><li>占空比改变</li><li>上述所有关系的组合</li></ul><br /><p>&emsp;&emsp;<strong>衍生时钟</strong>又分两种情况：</p><ol><li>Vivado自动推导的衍生时钟</li><li>用户自定义的衍生时钟</li></ol><p>&emsp;&emsp;首先来看第一种，如果使用PLL或者MMCM，则Vivado会自动推导出一个约束。大家可以打开Vivado中有个叫<code>wavegen</code>的工程，在这个工程中，输入时钟经过PLL输出了2个时钟，如下图所示。<br>（补充：关于DCM/DLL/PLL/MMCM的区别，可参考文章<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODY5ODU5Ng==&mid=2247484106&idx=1&sn=82983a8086732717298436e067a64d4d&chksm=fdd98441caae0d57c99c5b22cf72bfaee2372824406014680be9df1f8d85b3071182fe43656c&mpshare=1&scene=1&srcid=0928ySJ3ud0vfaGS85Teu5Xw&sharer_sharetime=1571051171309&sharer_shareid=296cfe717a7da125d89d5a7bcdf65c18&key=6234e09828e71f223a5bbb62942587523cffdc550c50d6713403e50f0f1a03c87c5b1a6fae054a425e6f27eabfd6e48eb8fd421c5841d8d8b3b054113d8e8650ff4a65e51fa211ebe10dc0a436635167&ascene=1&uin=MzkzMzM2Nzc1&devicetype=Windows+7&version=62070141&lang=zh_CN&pass_ticket=b15xLCDB%2FBp7ALLPd%2FcqR3Z4qIXNCYrUowj5c4g9AzKzb29vj6R%2F%2BP8z8RJvomTk" target="_blank" rel="noopener">DCM/DLL/PLL/MMCM区别</a></p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial15.png"  alt="" /></fancybox></center><p>&emsp;&emsp;但在xdc文件中，并未对这2个输出时钟进行约束，只对输入的时钟进行了约束，若我们使用<code>report_clocks</code>指令，则会看到：</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial16.png"  alt="" /></fancybox></center><p><em>注：有三个约束是因为PLL会自动输出一个反馈时钟</em></p><p>&emsp;&emsp;自动推导的好处在于当MMCM/PLL/BUFR的配置改变而影响到输出时钟的频率和相位时，用户无需改写约束，Vivado仍然可以自动推导出正确的频率/相位信息。劣势在于，用户并不清楚自动推导出的衍生钟的名字，当设计层次改变时，衍生钟的名字也有可能改变。但由于该衍生时钟的约束并非我们自定义的，因此可能会没有关注到它名字的改变，当我们使用者这些衍生时钟进行别的约束时，就会出现错误。</p><p>&emsp;&emsp;解决办法是用户自己手动写出自动推导的衍生时钟的名字，也仅仅写出名字即可，其余的不写。如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create_generated_clock -name &lt;generated_clock_name&gt; \</span><br><span class="line">                       -source &lt;master_clock_source_pin_or_port&gt;</span><br></pre></td></tr></table></figure><p>这一步很容易会被提示critical warning，其实有个很简单的方法，就是name和source都按照vivado中生成的来。具体我们到后面的例子中会讲到。</p><p> <strong>3. set_clock_groups</strong></p><p> 使用方法为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_clock_groups -asynchronous -group &lt;clock_name_1&gt; -group &lt;clock_name_2&gt;</span><br><span class="line">set_clock_groups -physically_exclusive  -group &lt;clock_name_1&gt; -group &lt;clock_name_2&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个约束常用的方法有三种，第一种用法是当两个主时钟是异步关系时，使用<code>asynchronous</code>来指定。这个在我们平时用的还是比较多的，一般稍微大点的工程，都会出现至少两个主时钟，而且这两个时钟之间并没有任何的相位关系，这时就要指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period 10 -name clk1 [get_ports clk1]</span><br><span class="line">create_clock -period 8 -name clk2 [get_ports clk2]</span><br><span class="line">set_clock_groups -asynchronous -group clk1 -group clk2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二种用法是当我们需要验证同一个时钟端口在不同时钟频率下能否获得时序收敛时使用。比如有两个异步主时钟clk1和clk2，需要验证在clk2频率为100MHz，clk1频率分别为50MHz、100MHz和200MHz下的时序收敛情况，我们就可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name clk1A -period 20.0 [get_ports clk1]</span><br><span class="line">create_clock -name clk1B -period 10.0 [get_ports clk1] -add</span><br><span class="line">create_clock -name clk1C -period 5.0  [get_ports clk1] -add </span><br><span class="line">create_clock -name clk2 -period 10.0 [get_ports clk2]</span><br><span class="line">set_clock_groups -physically_exclusive -group clk1A -group clk1B -group clk1C</span><br><span class="line">set_clock_groups -asynchronous -group &quot;clk1A clk1B clk1C&quot; -group clk2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三种用法就是当我们使用BUFGMUX时，会有两个输入时钟，但只会有一个时钟被使用。比如MMCM输入100MHz时钟，两个输出分别为50MHz和200MHz，这两个时钟进入了BUFGMUX，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial17.png"  alt="" /></fancybox></center><p>在这种情况下，我们需要设置的时序约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_clock_groups -logically_exclusive \</span><br><span class="line">-group [get_clocks -of [get_pins inst_mmcm&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT0]] \</span><br><span class="line">-group [get_clocks -of [get_pins inst_mmcm&#x2F;inst&#x2F;mmcm_adv_inst&#x2F;CLKOUT1]]</span><br></pre></td></tr></table></figure><p> <strong>4. 创建虚拟时钟</strong></p><p>&emsp;&emsp;虚拟时钟通常用于设定对输入和输出的延迟约束，这个约束其实是属于IO约束中的延迟约束，之所以放到这里来讲，是因为虚拟时钟的创建，用到了本章节讲的一些理论。虚拟时钟和前面讲的延迟约束的使用场景不太相同。顾名思义，虚拟时钟，就是没有与之绑定的物理管脚。<br>虚拟时钟主要用于以下三个场景：</p><ul><li>外部IO的参考时钟并不是设计中的时钟</li><li>FPGA I/O路径参考时钟来源于内部衍生时钟，但与主时钟的频率关系并不是整数倍</li><li>针对I/O指定不同的jitter和latency</li></ul><p>&emsp;&emsp;简而言之，之所以要创建虚拟时钟，对于输入来说，是因为输入到FPGA数据的捕获时钟是FPGA内部产生的，与主时钟频率不同；或者PCB上有Clock Buffer导致时钟延迟不同。对于输出来说，下游器件只接收到FPGA发送过去的数据，并没有随路时钟，用自己内部的时钟去捕获数据。</p><p>&emsp;&emsp;如下图所示，在FPGA的A和B端口分别有两个输入，其中捕获A端口的时钟是主时钟，而捕获B端口的时钟是MMCM输出的衍生时钟，而且该衍生时钟与主时钟的频率不是整数倍关系。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial18.png"  alt="" /></fancybox></center><p>&emsp;&emsp;这种情况下时序约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name sysclk -period 10 [get_ports clkin]</span><br><span class="line">create_clock -name virclk -period 6.4</span><br><span class="line">set_input_delay 2 -clock sysclk [get_ports A]</span><br><span class="line">set_input_delay 2 -clock virclk [get_ports B]</span><br></pre></td></tr></table></figure><p>可以看到，创建虚拟时钟用的也是<code>create_clock</code>约束，但后面并没有加<code>get_ports</code>参数，因此被称为虚拟时钟。</p><p>&emsp;&emsp;再举个输出的例子，我们常用的UART和SPI，当FPGA通过串口向下游器件发送数据时，仅仅发过去了uart_tx这个数据，下游器件通过自己内部的时钟去捕获uart_tx上的数据，这就需要通过虚拟时钟来约束；而当FPGA通过SPI向下游器件发送数据时，会发送sclk/sda/csn三个信号，其中sclk就是sda的随路时钟，下游器件通过sclk去捕获sda的数据，而不是用自己内部的时钟，这是就不需要虚拟时钟，直接使用<code>set_output_delay</code>即可。</p><p>注意，虚拟时钟必须在约束I/O延迟之前被定义。</p><ol start="5"><li>最大最小延迟约束</li></ol><p>&emsp;&emsp;顾名思义，就是设置路径的max/min delay，主要应用场景有两个：</p><ul><li>输入管脚的信号经过组合逻辑后直接输出到管脚</li><li>异步电路之间的最大最小延迟</li></ul><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial19.png"  alt="" /></fancybox></center><p>设置方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay &lt;delay&gt; [-datapath_only] [-from &lt;node_list&gt;][-to &lt;node_list&gt;][-through &lt;node_list&gt;]</span><br><span class="line">set_min_delay &lt;delay&gt; [-from &lt;node_list&gt;] [-to &lt;node_list&gt;][-through &lt;node_list&gt;]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-from</td><td>有效的起始节点包含:时钟,input(input)端口,或时序单元(寄存器,RAM)的时钟引脚.</td></tr><tr><td>-to</td><td>有效的终止节点包含:时钟,output(inout)端口或时序单元的数据端口.</td></tr><tr><td>-through</td><td>有效的节点包含:引脚,端口,线网.</td></tr></tbody></table><p>&emsp;&emsp;max/min delay的约束平时用的相对少一些，因为在跨异步时钟域时，我们往往会设置<code>asynchronous</code>或者<code>false_path</code>。对于异步时钟，我们一般都会通过设计来保证时序能够收敛，而不是通过时序约束来保证。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-3-FPGA时序约束理论篇之IO约束</title>
      <link href="/blog/2020-06-03-1-3-IO-constraints/"/>
      <url>/blog/2020-06-03-1-3-IO-constraints/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O约束"><a href="#I-O约束" class="headerlink" title="I/O约束"></a>I/O约束</h2><p>&emsp;&emsp;I/O约束是必须要用的约束，又包括管脚约束和延迟约束。</p><h3 id="管脚约束"><a href="#管脚约束" class="headerlink" title="管脚约束"></a>管脚约束</h3><p>&emsp;&emsp;管脚约束就是指管脚分配，我们要指定管脚的PACKAGE_PIN和IOSTANDARD两个属性的值,前者指定了管脚的位置,后者指定了管脚对应的电平标准。</p><p>&emsp;&emsp;在vivado中，使用如下方式在xdc中对管脚进行约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_property -dict &#123;PACKAGE_PIN AJ16  IOSTANDARD  LVCMOS18&#125; [get_ports &quot;led[0]&quot;    ]</span><br></pre></td></tr></table></figure><a id="more"></a><p>&emsp;&emsp;在Vivado规定，必须要指定管脚电平，不然在最后一步生成比特流时会出错。</p><p>&emsp;&emsp;除了管脚位置和电平，还有一个大家容易忽略但很容易引起错误的就是端接，当我们使用差分电平时比如LVDS，在V6中我们使用<code>IBUFDS</code>来处理输入的差分信号时，可以指定端接为TRUE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IBUFDS #(</span><br><span class="line">   .DIFF_TERM(&quot;TRUE&quot;),       &#x2F;&#x2F; Differential Termination</span><br><span class="line">   .IOSTANDARD(&quot;DEFAULT&quot;)     &#x2F;&#x2F; Specify the input I&#x2F;O standard</span><br><span class="line">) IBUFDS_inst (</span><br><span class="line">   .O(O),  &#x2F;&#x2F; Buffer output</span><br><span class="line">   .I(I),  &#x2F;&#x2F; Diff_p buffer input (connect directly to top-level port)</span><br><span class="line">   .IB(IB) &#x2F;&#x2F; Diff_n buffer input (connect directly to top-level port)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但在Ultrascale中的IBUFDS，却把端接这个选项去掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IBUFDS #(</span><br><span class="line">   .DQS_BIAS(&quot;FALSE&quot;)  &#x2F;&#x2F; (FALSE, TRUE)</span><br><span class="line">)</span><br><span class="line">IBUFDS_inst (</span><br><span class="line">   .O(O),   &#x2F;&#x2F; 1-bit output: Buffer output</span><br><span class="line">   .I(I),   &#x2F;&#x2F; 1-bit input: Diff_p buffer input (connect directly to top-level port)</span><br><span class="line">   .IB(IB)  &#x2F;&#x2F; 1-bit input: Diff_n buffer input (connect directly to top-level port)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们必须要在xdc或I/O Pors界面中，手动指定，否则可能会出错。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial6.png"  alt="" /></fancybox></center><p>笔者之前就采过一个坑，差分端口输入，当连续输入的数据为11101111这种时，中间那个0拉不下来，还是1，同样也会发生在000010000，这样就导致数据传输错误，后来才发现是端接忘记加。因为端接会影响信号的实际电平，导致FPGA判断错误。</p><p>&emsp;&emsp;当综合完成后，我们可以点击DRC，进行设计规则检查，这一步可以报出一些关键问题，比如时钟端口未分配在时钟引脚上等。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial7.png"  alt="" /></fancybox></center><h3 id="延迟约束"><a href="#延迟约束" class="headerlink" title="延迟约束"></a>延迟约束</h3><p>&emsp;&emsp;延迟约束用的是<code>set_input_delay</code>和<code>set_output_delay</code>，分别用于input端和output端，其时钟源可以是时钟输入管脚，也可以是虚拟时钟。<strong>但需要注意的是，这个两个约束并不是起延迟的作用</strong>，具体原因下面分析。</p><ul><li>set_input_delay</li></ul><p>&emsp;&emsp;这个约束跟ISE中的<code>OFFSET=IN</code>功能相同，但设置方式不同。下图所示即为input delay的约束说明图。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial8.png"  alt="" /></fancybox></center><p>从图中很容易理解，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T_inputdelay &#x3D; Tco + TD</span><br></pre></td></tr></table></figure><p>当满足图中的时序时，最大延迟为2ns，最小延迟为1ns。</p><p>因此，需要加的时序约束为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name sysclk -period 10 [get_ports clkin]</span><br><span class="line">set_input_delay 2 -max -clock sysclk [get_ports Datain]</span><br><span class="line">set_input_delay 1 -min -clock sysclk [get_ports Datain]</span><br></pre></td></tr></table></figure><ul><li>set_output_delay</li></ul><p>&emsp;&emsp;set_output_delay的用法跟set_input_delay十分相似，这里就不再展开讲了。我们上面讲set_input_delay的描述中，大家可以看到，这个约束是告诉vivado我们的输入信号和输入时钟之间的延迟关系，跟下面要讲的时钟周期约束是一个原理，让vivado在这个前提下去Place and Route。<strong>并不是调节输入信号的延迟</strong>，因为身边有不少的FPGA工程师在没用过这个约束指令之前，都以为这是调节延迟的约束。</p><p>&emsp;&emsp;如果要调整输入信号的延迟，只能使用IDELAY，在V6中，IDELAY模块有32个tap值，每个tap可延迟78ps，这样总共差不多是2.5ns。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-2-FPGA时序约束理论篇之时序路径与时序模型</title>
      <link href="/blog/2020-06-02-1-2-Timing-path/"/>
      <url>/blog/2020-06-02-1-2-Timing-path/</url>
      
        <content type="html"><![CDATA[<h3 id="时序路径"><a href="#时序路径" class="headerlink" title="时序路径"></a>时序路径</h3><p>&emsp;&emsp;典型的时序路径有4类，如下图所示，这4类路径可分为片间路径（标记①和标记③)和片内路径（标记②和标记④）。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial2.png"  alt="" /></fancybox></center><a id="more"></a><p>&emsp;&emsp;对于所有的时序路径，我们都要明确其起点和终点，这4类时序路径的起点和终点分别如下表。</p><table><thead><tr><th>时序路径</th><th>起点</th><th>终点</th><th>应用约束</th></tr></thead><tbody><tr><td>①输入端口到FPGA内部第一级触发器的路径</td><td>ChipA/clk</td><td>rega/D</td><td>set_input_delay</td></tr><tr><td>②FPGA内部触发器之间的路径</td><td>rega/clk</td><td>regb/D</td><td>create_clock</td></tr><tr><td>③FPGA内部末级触发器到输出端口的路径</td><td>regb/clk</td><td>ChipB/D</td><td>set_output_delay</td></tr><tr><td>④FPGA输入端口到输出端口的路径</td><td>输入端口</td><td>输出端口</td><td>set_max_delay</td></tr></tbody></table><p>&emsp;&emsp;这4类路径中，我们最为关心是②的同步时序路径，也就是FPGA内部的时序逻辑。</p><h3 id="时序模型"><a href="#时序模型" class="headerlink" title="时序模型"></a>时序模型</h3><p>&emsp;&emsp;典型的时序模型如下图所示，一个完整的时序路径包括源时钟路径、数据路径和目的时钟路径，也可以表示为触发器+组合逻辑+触发器的模型。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial64.png" width = "600" height = "350" alt="" /></fancybox></center><p>&emsp;&emsp;该时序模型的要求为(公式1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tclk ≥ Tco + Tlogic + Trouting + Tsetup - Tskew</span><br></pre></td></tr></table></figure><p>其中，Tco为发端寄存器时钟到输出时间；Tlogic为组合逻辑延迟；Trouting为两级寄存器之间的布线延迟；Tsetup为收端寄存器建立时间；Tskew为两级寄存器的时钟歪斜，其值等于时钟同边沿到达两个寄存器时钟端口的时间差；Tclk为系统所能达到的最小时钟周期。</p><p>&emsp;&emsp;这里我们多说一下这个Tskew，skew分为两种，positive skew和negative skew，其中positive skew见下图，这相当于增加了后一级寄存器的触发时间。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial65.png" width = "500" height = "300" alt="" /></fancybox></center><p>但对于negative skew，则相当于减少了后一级寄存器的触发时间，如下图所示。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial66.png" width = "500" height = "300" alt="" /></fancybox></center><p>&emsp;&emsp;当系统稳定后，都会是positive skew的状态，但即便是positive skew，综合工具在计算时序时，也不会把多出来的Tskew算进去。</p><p>&emsp;&emsp;用下面这个图来表示时序关系就更加容易理解了。为什么要减去Tskew，下面这个图也更加直观。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial3.png"  alt="" /></fancybox></center><p>发送端寄存器产生的数据，数据经过Tco、Tlogic、Trouting后到达接收端，同时还要给接收端留出Tsetup的时间。而时钟延迟了Tskew的时间，因此有：<br>（公式2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tdata_path + Tsetup &lt;&#x3D; Tskew + Tclk</span><br></pre></td></tr></table></figure><p>对于同步设计Tskew可忽略(认为其值为0)，因为FPGA中的时钟树会尽量保证到每个寄存器的延迟相同。</p><p>公式中提到了建立时间，那保持时间在什么地方体现呢？</p><p>&emsp;&emsp;保持时间比较难理解，它的意思是reg1的输出不能太快到达reg2，这是为了防止采到的新数据太快而冲掉了原来的数据。保持时间约束的是同一个时钟边沿，而不是对下一个时钟边沿的约束。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial4.png"  alt="" /></fancybox></center><p>&emsp;&emsp;reg2在边沿2时刻刚刚捕获reg1在边沿1时刻发出的数据，若reg1在边沿2时刻发出的数据过快到达reg2，则会冲掉前面的数据。因此保持时间约束的是同一个边沿。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial5.png"  alt="" /></fancybox></center><p>在时钟沿到达之后，数据要保持Thold的时间，因此，要满足：（公式3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tdata_path &#x3D;  Tco + Tlogic + Trouting ≥ Tskew + Thold</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个公式是FPGA的面试和笔试中经常问到的问题，因为这种问题能反映出应聘者对时序的理解。</p><p>&emsp;&emsp;在公式1中，Tco跟Tsu一样，也取决于芯片工艺，因此，一旦芯片型号选定就只能通过Tlogic和Trouting来改善Tclk。其中，Tlogic和代码风格有很大关系，Trouting和布局布线的策略有很大关系。</p><p>&emsp;&emsp;关于时序约束的基本理论就讲这么多，下面讲具体的约束。</p><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-1-FPGA时序约束理论篇之建立保持时间</title>
      <link href="/blog/2020-06-01-1-1-setup-hold/"/>
      <url>/blog/2020-06-01-1-1-setup-hold/</url>
      
        <content type="html"><![CDATA[<h1 id="读万卷书–时序约束理论篇"><a href="#读万卷书–时序约束理论篇" class="headerlink" title="读万卷书–时序约束理论篇"></a>读万卷书–时序约束理论篇</h1><h2 id="周期约束理论"><a href="#周期约束理论" class="headerlink" title="周期约束理论"></a>周期约束理论</h2><p>&emsp;&emsp;首先来看什么是时序约束，泛泛来说，就是我们告诉软件（Vivado、ISE等）从哪个pin输入信号，输入信号要延迟多长时间，时钟周期是多少，让软件PAR(Place and  Route)后的电路能够满足我们的要求。因此如果我们不加时序约束，软件是无法得知我们的时钟周期是多少，PAR后的结果是不会提示时序警告的。</p><p>&emsp;&emsp;周期约束就是告诉软件我们的时钟周期是多少，让它PAR后要保证在这样的时钟周期内时序不违规。大多数的约束都是周期约束，因为时序约束约的最多是时钟。</p><p>&emsp;&emsp;在讲具体的时序约束前，我们先介绍两个概念，在下面的讲解中，会多次用到：</p><ul><li>发起端/发起寄存器/发起时钟/发起沿：指的是产生数据的源端</li><li>接收端/接收寄存器/捕获时钟/捕获沿：指的是接收数据的目的端</li></ul><a id="more"></a><h3 id="建立-保持时间"><a href="#建立-保持时间" class="headerlink" title="建立/保持时间"></a>建立/保持时间</h3><p>&emsp;&emsp;讲时序约束，这两个概念要首先介绍，因为我们做时序约束其实就是为了满足建立/保持时间。对于DFF的输入而言，</p><ul><li>在clk上升沿到来之前，数据提前一个最小时间量“预先准备好”，这个最小时间量就是建立时间；</li><li>在clk上升沿来之后，数据必须保持一个最小时间量“不能变化”，这个最小时间量就是保持时间。</li></ul><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial0.png"  alt="" /></fancybox></center><p>建立和保持时间是由器件特性决定了，当我们决定了使用哪个FPGA，就意味着建立和保持时间也就确定了。Xilinx FPGA的setup time基本都在0.04ns的量级，hold time基本在0.2ns的量级，不同器件会有所差异，具体可以查对应器件的DC and AC Switching Characteristics，下图列出K7系列的建立保持时间。</p><center><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/fpga/timing_toturial1.png"  alt="" /></fancybox></center><br> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73006468&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/blog/2020-05-03-networks-http-status-code/"/>
      <url>/blog/2020-05-03-networks-http-status-code/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200503152722.jpg"></fancybox></fancybox></center>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给pdf文件添加书签目录</title>
      <link href="/blog/2020-04-18-add-bookmark-for-your-pdf/"/>
      <url>/blog/2020-04-18-add-bookmark-for-your-pdf/</url>
      
        <content type="html"><![CDATA[<p>pdf文档算是我们平时看到比较多的文档啦，而我们看pdf文件最喜欢的一个功能就是打开书签功能，这样我们就能快速定位，查看我们需要查看的内容，但是有时候会遇没有书签的pdf文档，这个时候看起来就有些不方便了，于是我在网上查了一下，还真的可以给pdf文件添加书签的办法，废话不多说，直接进入正题：</p><a id="more"></a><p>1，用Adobe acrobat 软件打开待添加书签的pdf文档。<br>2，打开之后点击软件左边栏的书签（有时被隐藏了，点击一下界面左边靠近中间位置的箭头）。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200418233519.png"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200418233701.png"></fancybox><p>3，打开书签栏之后，把pdf定位到要加书签的地方，然后点击新建书签（快捷键：Ctrl+B）。当然也可以用鼠标将要作为书签的文字选中，然后再按快捷键(Ctrl+B)，这样添加的书签标题就是刚刚选中的文字。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200418233815.png"></fancybox><p>4，再输入书签的名称。<br>5，如果要创建子书签，只需要像拖动文件夹一下，把要创立的子书签拖动到母书签那里，就行了。拖上去的时候，那里会显示一条细线，如题所示。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200419001554.png"></fancybox><blockquote><p>原文链接：<a href="https://blog.csdn.net/xiaotao_1/article/details/79357859" target="_blank" rel="noopener">https://blog.csdn.net/xiaotao_1/article/details/79357859</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>效率至上-一文带你真正走进vim</title>
      <link href="/blog/2020-04-03-one-article-leads-you-to-vim/"/>
      <url>/blog/2020-04-03-one-article-leads-you-to-vim/</url>
      
        <content type="html"><![CDATA[<p><code>vim</code>一直是程序员之间比较有争议的一个话题。有人认为她是编辑器之神，有人则认为她古老过时，远远不如<strong>IDE</strong>，或是以当红小生<code>vscode</code>为代表的图形化文本编辑器。无论爱恨，我们的开发工作，大到远程登录服务器<code>coding</code>，修改<code>config</code>文件，小到<code>git commit message</code>，或多或少总要接触她。</p><p>为什么要写这篇blog呢，是因为我发现各大平台充斥的<code>vim</code>教程类blog其实很不友好，大多数是命令的堆砌，很少有对思想的解读。由此造成的结果，很多工程师对<code>vim</code>总是敬畏三分，或者就算部分人可以使用<code>vim</code>，也只是以自己的固有思维，结合vim的命令操作，并没有真正掌握<code>vim</code>的精髓。所以我尝试用自己的方式，试图帮助大家<strong>系统</strong>地建立起<code>vim</code>的知识系统。</p><a id="more"></a><p>文章主要结构如下：</p><ul><li>首先介绍<code>vim</code>编辑器最简单、基本的操作，让你快速入门，在遇到<code>vim</code>时，可以不至于惊慌，从容完成任务。如果想到某些操作，比如常用的复制、粘贴之类，可以到第二部分查找对应高阶操作，循序渐进使用<code>vim</code>。</li><li>接下来，将会介绍<code>vim</code>一系列高级操作，将我们的效率最大化。注：这部分信息量较大，建议您在阅读部分内容后，快速浏览不熟悉的命令，做到心中有数；随后可前进到第三部分；回过头来，再循序渐进，边学边练。</li><li>最后，试图讲述<code>vim</code>思想的精髓，既让我们真正对<code>vim</code>的操作融会贯通，又让我们可以在使用其他IDE/编辑器时应用这些思想，甚至在我们自己设计、实现功能、组件时，都能进行应用。这才算真正掌握了神器<code>vim</code>。</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>vim有三个模式，分别为普通（正常）模式、插入模式以及命令模式。</p><ul><li>普通模式：一般用于浏览文件，也包括一些复制、粘贴、除等操作。</li><li>插入模式：主要用来输入、修改、删除字符，此时的操作，除了不能用鼠标外，与我们日常在编辑器中操作无异。普通模式下，通过<code>i</code>等命令进入插入模式。</li><li>命令模式：用以执行一些输入并执行一些vim或插件提供的指令。在普通模式下通过输入<code>:</code>后，可以发现，屏幕的右下角会出现<code>:</code>，此时便进入了命令模式。本文中使用：开头的命令，便可视为输入<code>:</code>进入命令模式后，输入后面的字符，执行命令。</li></ul><p>很多人对于<code>vim</code>的第一点疑惑，便来源于此。我们习惯了图形化编辑器下，始终处于插入状态。然而在<code>vim</code>中，大多数情况下，我们会处于正常模式。只有当需要输入字符时，进入插入模式；当需要使用命令时，进入到命令模式。在插入和命令模式下，输入<code>Esc</code>便可返回正常模式。一张图概括如下：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200403193157.png"></fancybox><blockquote><p>注：后文讲解，如无特殊说明，均为普通模式下操作。</p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>如果不追求效率，只想完成修改文件的任务，并保存退出，只需要掌握以下三个命令：</p><ol><li>移动：<code>h j k l</code>最简单的移动，相当于键盘上面的方向键，分别对应左下上右。</li><li>进入插入模式：<code>i</code></li><li>保存退出：<code>ZZ</code>（注意区分大小写）</li></ol><p>流程如下：</p><ol><li>普通模式下，通过<code>h j k l</code>移动到想要修改的位置</li><li>输入<code>i</code>进入插入模式，此时通过输入(字母、数字、符号)，删除(Backspace)等，完成基本修改操作</li><li><code>Esc</code>回到普通模式，<code>ZZ</code>，保存修改并退出。</li></ol><h2 id="进阶：命令形式"><a href="#进阶：命令形式" class="headerlink" title="进阶：命令形式"></a>进阶：命令形式</h2><p>普通模式下，<code>vim</code>的命令主要分为以下三种：</p><ol><li><p>动作，用以移动光标，或者定义操作的范围；比如：</p><ol><li><code>h</code>：定义操作范围为一格，单独使用时，向左移动光标一格。</li><li><code>w</code>：定义操作范围为一个单词，移动光标到下一个单词首部。</li></ol></li><li><p>操作，这种命令需要在后面接表示操作范围的指令；</p><ol><li><code>d</code>，删除，后接表示一个单词操作范围的<code>w</code>，即<code>dw</code>时，表示删除到当前词尾。</li><li><code>c</code>，修改，后接表示一个单词操作范围的<code>w</code>，即<code>cw</code>时，表示修改当前单词。(编辑器行为表现为，删除到当前词尾，同时进入插入模式)。</li></ol></li><li><p>命令，直接执行的命令，其中一部分，在执行命令后，直接进入编辑模式；比如：</p></li><li><p><code>D</code>，删除至行末。</p></li><li><p><code>I</code>，到行首进入插入模式。 我们的使用方式主要也是三种：命令、动作、操作+动作。 此外，在<strong>动作</strong>类的命令前，加上<code>number</code>为可选项，可实现<code>重复n次</code>的效果：</p></li><li><p><code>[number] + h/j/k/l</code>向<code>左/下/上/右</code>移动<code>number</code>个字符。比如，’2j’，向下移动光标2个字符。</p></li><li><p>依旧使用<code>d</code>和<code>w</code>来举例，<code>d</code>是删除，<code>w</code>是单词，<code>dw</code>代表删除一个单词，<code>d2w</code>代表删除两个单词。后面的命令，大多都可应用此种形式组合使用，大家多注意，养成这种<code>操作 + [次数] + 范围</code>的思维模式，举一反三，便可发挥最大功效。</p></li></ol><h3 id="移动进阶"><a href="#移动进阶" class="headerlink" title="移动进阶"></a>移动进阶</h3><h4 id="单词级别的移动"><a href="#单词级别的移动" class="headerlink" title="单词级别的移动"></a>单词级别的移动</h4><p>这里有仅大小写不同的两组命令，两组命令的功能，是相同的：跳转光标到对应位置。但是对应的单位不同，分别为<code>word</code>和<code>string</code>。具体区别是：</p><ul><li><code>string</code>仅以<strong>空格</strong>分开；</li><li><code>word</code>以<strong>字母数字以外的字符</strong>分开。</li></ul><p>以这个字符串为例：<code>hello world-hehe111 abcde</code></p><ul><li><code>word</code>有5个，分别为<code>hello world</code>, <code>-</code>, <code>hehe111</code>和<code>abcde</code>。</li><li><code>string</code>有3个，分别为<code>hello world-hehe111</code>和<code>abcde</code>。</li></ul><p>两组命令如下：（跳转光标至）</p><ul><li><code>w</code> 下一个单词开头</li><li><code>e</code> 当前或下一个单词结尾</li><li><code>b</code> 当前或上一个单词开头</li><li><code>ge</code> 上一个单词的结尾</li><li><code>W</code> 下一个字符串的开头</li><li><code>E</code> 当前或下一个字符串结尾</li><li><code>B</code> 当前或上一个字符串的开头</li><li><code>GE</code> 上一个字符串的结尾</li></ul><p>举个例子，当光标位于<code>hehe111</code>的第一个字符h时，前后的单词/字符串信息如下：</p><table><thead><tr><th></th><th>前一个</th><th>当前</th><th>后一个</th></tr></thead><tbody><tr><td>单词</td><td>-</td><td>hehe111</td><td>abcde</td></tr><tr><td>字符串</td><td>hello</td><td>world-hehe111</td><td>abcde</td></tr></tbody></table><p>那么以上各个敲击以上各个命令的结果，便一目了然(加粗字表示命令运行后光标位置)：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200403200449.png"></fancybox><h4 id="句子，段落级别的移动"><a href="#句子，段落级别的移动" class="headerlink" title="句子，段落级别的移动"></a>句子，段落级别的移动</h4><ul><li><code>0</code> 移动到当前行行首</li><li><code>^</code> 移动到当前行的第一个非空字符</li><li><code>$</code> 移动到当前行尾</li><li><code>(</code> 跳转到当前或前一个句子的开头</li><li><code>)</code> 跳转到当前或下一个句子的结尾</li><li><code>{</code> 跳转到当前或前一个段落的开头</li><li><code>}</code> 跳转到当前或下一个段落的结尾</li><li>这里段落很容易理解，是以空行分隔开的。句子麻烦些，是按照句号来算的。</li><li>记得在这些命令前添加<code>d</code>试一下效果吧，掌握<code>操作+范围</code>这种命令形式吧。</li></ul><h4 id="页面级别的移动"><a href="#页面级别的移动" class="headerlink" title="页面级别的移动"></a>页面级别的移动</h4><p><strong>按行移动光标</strong><br><code>gg</code> 移动到文本第一行行首<br><code>G</code> 移动到文本末行行首<br><code>[n] + %</code>：按百分比近似定位到某行，该行位于整个文件的<code>n%</code>处<br><code>[n] + gg/G</code> 跳转到第<code>n</code>行，常用。</p><p>要想用好上述几个命令，有两个简单的建议：</p><p>结合命令：<code>ctrl-g</code>。该命令的作用是显示当前行的位置信息（第几行，相对整个文本行数的百分比）。<br>在命令模式下输入以下命令，或在<code>~/.vimrc</code>中添加如下代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nu &quot; 显示行号</span><br><span class="line">set cursorline &quot; 高亮光标所在行&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p><strong>显示页面内移动光标</strong></p><ul><li><code>H</code>：屏幕顶部行首</li><li><code>M</code>：屏幕中央行首</li><li><code>L</code>：屏幕底部行首</li></ul><p><strong>滚动与翻页</strong></p><ul><li><code>ctrl-d/u</code>：前进/后退半页</li><li><code>ctrl-f/b</code>：前进/后退整页</li><li><code>ctrl+e</code>：上滚一行</li><li><code>ctrl+y</code>：下滚一行</li><li><code>zt</code>：使光标所在位置移动到屏幕的顶部（所有内容做位移）</li><li><code>zz</code>：使光标所在位置移动到屏幕的中央（所有内容做位移）</li><li><code>zb</code>：使光标所在位置移动到屏幕的底部（所有内容做位移）</li></ul><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><ul><li><code>f+单个字符</code>：在本行内向右移动到指定字符</li><li><code>F+单个字符</code>：在本行内向左移动到指定字符</li><li><code>t+单个字符</code>：在本行内向右移动到指定字符的前一个字符</li><li><code>T+单个字符</code>：在本行内向左移动到指定字符的前一个字符</li><li><code>%</code>: 在“( )”、“[ ]”、“{ }”类符号的首尾间切换</li><li><code>*</code> 和<code>#</code>: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）。</li></ul><h4 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h4><ul><li><code>m+[a~z]</code> ：在当前光标做标记，如ma</li><li><code>'+[mark]</code>：光标返回指定标记所在的行，如<code>'a</code>，则光标返回到标记<code>a</code>所在行首</li><li><code>`+[mark]</code>：光标返回指定标记</li><li><code>ctrl+o</code>：跳转回光标前一个位置</li><li><code>ctrl+i</code>：跳转回较新的光标位置</li><li>建议结合命令模式下如下两个命令，可获得更好体验：<ul><li><code>:marks</code>：显示全部mark</li><li><code>:delmarks [mark]</code>：删除指定mark</li></ul></li></ul><h3 id="编辑进阶"><a href="#编辑进阶" class="headerlink" title="编辑进阶"></a>编辑进阶</h3><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4><p><strong>在不同位置进入插入模式</strong></p><ul><li><code>i</code>：在光标前插入字符</li><li><code>I</code>：在行首插入字符</li><li><code>a</code>：在光标后插入字符</li><li><code>A</code>：在行尾插入字符</li><li><code>o</code>：在光标下发插入空行</li><li><code>O</code>：在光标上方插入空行</li></ul><p><strong>使用修改命令进入插入模式</strong></p><ul><li><code>c</code>：修改，后面需要接范围</li><li><code>c+w</code>：删除光标位置单词，并进入插入模式</li><li><code>c+l / s</code>：删除光标位置字符，并进入插入模式</li><li><code>c+c / S</code>：删除光标所在行，并进入插入模式</li><li><code>c+$ / C</code>：删除光标位置到行尾的字符，并进入插入模式</li><li><code>r</code>： 替换当前字符。</li><li><code>R</code>：（进入replace模式）持续替换光标所在字符，直到使用ESC退出替换模式。</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><code>x</code>： 删除当前位置或下一个位置的字符。</li><li><code>d</code>：删除，属于动作指令，后面需要加操作类指令。比如如下命令：<ul><li><code>de</code>：删除到当前单词结尾。</li><li><code>dw</code>：删除到下一个单词开始。</li><li>注意，此处与<code>de</code>的区别在于，<code>dw</code>会删除两个单词之间的空格。</li><li><code>daw</code>：删除一个单词，包含单词的边界（空格）。</li><li><code>d0</code>：删除至行首。</li><li><code>d$ / D</code>：删除至行尾。</li></ul></li><li><code>da[</code>：删除[ ]整个块，包含符号本身；</li><li><code>di[</code>：删除[ ]块，不包含符号本身；</li><li><code>da/di +</code> ‘ “ { ( 等，也与接[类似，删除整个区块。唯一需要注意的，”和’仅仅在行内。</li><li><code>dt[x]</code>：在本行，删除到[x]。比如，<code>dt"</code>删除到双引号，<code>dtf</code>，删除到字母<code>f</code>。 <code>d/foo</code>：在全文， 删除到 “foo” 。</li></ul><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><p>剪切操作其实就是我们之前讲的删除。也就是d。删除的内容，默认会存放到剪切板中。也就相当于进行了剪切。</p><h4 id="进阶操作符"><a href="#进阶操作符" class="headerlink" title="进阶操作符"></a>进阶操作符</h4><p>从这里大家可以看出，<code>i</code>和<code>a</code>的作用比较特殊，代表与区块相关的某种操作。区别就在于，<code>i</code>不包含区块边界符号。<code>a</code>包含。这两个操作符很重要，在后面的复制操作中还会用到。此外还有<code>t</code>，<code>/</code>。此外，<code>i</code>和<code>a</code>还可以接<code>t</code>，此时<code>t</code>表示一对xml标签。<code>i</code>：区块，不包含边界。<code>a</code>：区块，包含边界。<code>t</code>：”<code>t</code>o”，本行到哪里。<code>/</code>：接匹配，全文到哪里。</p><h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><ul><li><code>p</code>：粘贴到光标后，或下一行。</li><li><code>P</code>：粘贴到光标前，或前一行。</li></ul><p>为什么会有光标前后或上下一行两种情况呢？是因为我们复制或剪切的内容有可能是字符串或者整行：</p><ul><li>当复制内容为字符串时，粘贴到光标前/后。</li><li>当复制内容为整行时，粘贴到上/下一行。</li></ul><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li><p><code>y</code>，复制，属于操作，后面需要接动作来标识复制的范围。比如：</p><ul><li><code>yw</code>：复制到当前单词结尾。</li><li><code>ye</code>：从当前位置复制到本单词的最后一个字符。</li><li><code>y$</code>：复制到当前行尾。</li><li><code>yy</code>或<code>Y</code>：复制当前行。</li><li><code>nyy</code>：复制从光标所在行起的n行，注意n在最前面。<br><code>0y$</code>： 命令意味着：</li></ul></li><li><p><code>0</code> → 先到行头</p></li><li><p><code>y</code> → 从这里开始拷贝</p></li><li><p><code>$</code> → 拷贝到本行最后一个字符<br>当然也可以结合我们刚刚介绍的进阶操作符来进行操作：</p></li><li><p><code>yi"</code>：复制两个引号之间</p></li><li><p><code>yit</code>：复制两个xml标签之间</p></li><li><p><code>y/[x]</code>：复制到x。</p></li></ul><h4 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h4><p>vim 有 12 个剪切板，分别是 0、1、2、…、9、a、“、＋。<code>:reg</code>：查看各个剪切板里的内容。<code>y</code>，<code>p</code>默认使用 “剪切板中的内容。 <code>"[n]y</code>：复制到剪切板<code>n</code>中。<code>"[n]p</code>：粘贴剪切板<code>n</code>中的内容。</p><p><strong>查看是否支持系统剪切板：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version | grep &quot;clipboard&quot;</span><br></pre></td></tr></table></figure><p>观看输出中，<code>clipboard</code>前面是<code>+</code>还是<code>-</code>。若是<code>-</code>，则说明不支持系统剪切板。 <code>+</code>号剪切板比较特殊，是系统剪切板，用于与系统其他应用互动：</p><ul><li><code>"+y</code>，将内容复制到系统剪切板，<code>ctrl＋v</code>将其粘贴到其他应用中，比如<code>vs code</code>。</li><li><code>"+p</code>，将其他应用中复制的内容，粘贴到vim中。</li></ul><h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><p><code>v</code>：进入可视模式。<code>V</code>：进入行选择模式。<code>Crtl + v</code>：进入块选择模式。</p><p>进入可视模式后，可以通过之前的移动操作，来进行选择。比如：<code>hjkl</code>：前后左右选择。<code>$</code>：选择到行尾。<code>i"</code>：选择两个引号之间。</p><p>选择后，可以使用</p><ul><li><code>d</code>进行删除/剪切，</li><li><code>y</code>进行复制。</li><li>还可以使用以下很有意思的命令：<ul><li><code>gU</code>：变大写。</li><li><code>gu</code>：变小写。</li><li><code>J</code>：把所有的行连接起来（变成一行）。</li><li><code><</code> 或 <code>></code>：左右缩进。</li><li><code>=</code> ：自动缩进 。</li></ul></li></ul><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p><code>=</code>：调整格式化缩进。<code>gg=G</code>：全文代码格式化。</p><ul><li><code>gg</code>，到文章开头</li><li><code>=</code>，调整格式</li><li><code>G</code>，到文章结尾。</li></ul><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p>编辑模式下<code>Ctrl + n/p</code>出现提示，此时会出现补全的选项。按住<code>Ctrl</code>不放，用<code>n</code>和<code>p</code>来遍历提示选项，到达期待的选项后，无需其他操作，继续输入即可。</p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul><li><code>u</code>：撤销前一个动作</li><li><code>U</code>：撤销当前行的一系列动作</li><li><code>CTRL-R</code>：Redo，意思就是我又不想撤销了。</li></ul><h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><ul><li><code>/</code>： 查找，此时Terminal左下角会出现<code>/</code>，在后面输入想要查找的内容，回车即可。</li><li><code>?</code>：反向查找，同样道理，左下角会出现<code>?</code>。</li><li><code>/[search]\c</code>：忽略大小写。比如：<code>/test\c</code>，查找test，忽略大小写</li><li><code>n</code>： 下一个匹配</li><li><code>N</code>： 前一个匹配</li></ul><p>命令模式下：</p><ul><li><code>s/old/new/</code>：用<code>new</code>替换<code>old</code></li><li><code>s/old/new/g</code>：全局替换</li><li><code>set hlsearch</code>：高亮搜索结果</li></ul><h4 id="宏录制"><a href="#宏录制" class="headerlink" title="宏录制"></a>宏录制</h4><p><code>qa</code>操作序列<code>q</code>, <code>@a</code>, <code>@@</code></p><ul><li><code>qa</code>把你的操作记录在寄存器<code>a</code>。</li><li>于是<code>@a</code>会replay被录制的宏。</li><li><code>@@</code> 是一个快捷键用来replay最新录制的宏。</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>:w</code>：保存修改</li><li><code>:wq</code>：保存修改并退出</li><li><code>ZZ</code>：保存修改并退出</li><li><code>q!</code>：不保存修改，强制退出</li><li><code>e!</code>：不保存修改，强制重新打开当前文件</li></ul><blockquote><p>大家可以看到，<code>!</code>的作用便在于，强制。除此以外，他还有另一个很强势的功能，就是执行shell命令。具体信息，大家可以详细阅读下一节。</p></blockquote><ul><li><code>.</code>：重复执行前一个命令。这个命令很灵活、实用，建议多多尝试。</li><li><code>:help [command]</code>：查看某命令的help此外，在命令行中执行如下命令，便可进入vim的教程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure><h3 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h3><p>这是<code>vim</code>的一个很神奇的功能，在编辑的时候可以与外部文本互动，甚至执行一些<code>shell</code>命令。</p><ul><li><code>:w [file-name]</code>：将当前内容输出到指定文件中</li><li><code>:r [file-name]</code>：将另外一个文件的内容输出到当前位置</li><li><code>:e filename</code>：vim下打开指定文本</li><li><code>ctrl+w, s</code>：水平拆分窗口</li><li><code>ctrl+w, v</code>：垂直拆分窗口</li><li><code>ctrl+w, ARROW(h,j,k,l或方向键)</code>：在窗口间切换光标。</li><li><code>ctrl+w, w</code>：在窗口间切换光标。</li><li><code>:qa</code>：关闭所有窗口。</li><li><code>:saveas</code>：另存为。</li><li><code>:n/bn/bp</code>：在打开的多个文件间切换。</li><li><code>:![command]</code>：vim下执行某shell命令。</li><li>比如，<code>:!ls</code>，便会暂时切换到shell下，输出当前目录的文件名。此时输入回车，便可退回当前<code>vim</code>编辑的文件中。</li></ul><p>如果你觉得这种输入命令的方式还不够过瘾，<code>vim</code>还提供了保留当前工作现场，直接进入shell的方式。这种命令一个典型的工作场景是，如我们编辑了一个文件，但是发现无法保存（没有写权限），此时可以先进入到shell下，执行类似<code>chmod u+w [filename]</code>，的命令，为当前用户获取该文件的写权限，然后再回到 <code>vim</code> 保存刚刚的修改。 有如下两种方法：</p><ol><li><code>:shell</code> 或 <code>:sh</code>，当退出当前 shell 时（比如<code>exit</code>），就会回到 vim。</li><li><code>ctr-z</code> 进入 shell，<code>fg</code> 退回 vim。</li></ol><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>这部分主要是一些<code>vim</code>的config。可以直接命令模式输入，也可以保存到<code>~/.vimrc</code>中，便可每次打开<code>vim</code>自动应用。(其中一些命令是互相冲突的，请自行选择有用的命令)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax on # 开启语法高亮</span><br><span class="line"></span><br><span class="line">set nu[mber] # 显示行号</span><br><span class="line">set nonu[mber] # 隐藏行号</span><br><span class="line"></span><br><span class="line">set cursorline # 高亮当前行</span><br><span class="line">set ruler # 显示光标位置信息</span><br><span class="line">set noruler # 隐藏光标位置信息</span><br><span class="line"></span><br><span class="line">set hlsearch # 高亮匹配</span><br><span class="line">set nohlsearch # 取消高亮匹配</span><br><span class="line">nohlsearch # 临时取消高亮（只取消一次查询的高亮）</span><br><span class="line">set incsearch # 在输入字符串过程中显示匹配点</span><br><span class="line">set nowrapscan # 找到文尾后停止查找</span><br><span class="line">set wrapscan # 恢复为到文尾后自动从头开始</span><br><span class="line">set ic&#x2F;ignorecase) # 忽略大小写</span><br><span class="line">set noic&#x2F;noignorecase # 区分大小写&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><h2 id="VIM思想"><a href="#VIM思想" class="headerlink" title="VIM思想"></a>VIM思想</h2><p>这部分主要是一些我在使用<code>vim</code>过程中的一些思考和感悟，试图尽力阐述出来。如果大家能有一些思考和收获，说明我的思考是有意义的。如果大家有不同见解，十分欢迎拍砖交流。</p><h3 id="Why-Normal"><a href="#Why-Normal" class="headerlink" title="Why Normal"></a>Why Normal</h3><ul><li>为什么vim下，要放弃人们习惯的插入模式，使用命令模式呢？仔细想一想，其实原因很简单：在没有鼠标的年代，人们只能依靠键盘来移动光标，修改文本。</li><li>为什么现在有了鼠标，我们还要用正常模式呢?<ol><li>工作内容覆盖。我们每个人都认为，工程师的工作，是写代码。然而，其实我们主要的工作，是读，或者说，理解代码。经调查，工程师日常工作中，读：写代码的比例，为10：1(参考《Clean Code》一书)。所以默认的普通模式，主要满足占比重更大的”读“；遇到需要修改的时候，再进入编辑模式。</li><li>大量快捷键。相信每个人，都最起码知道一组快捷键：<code>ctrl-c/v</code>，也就是我们熟悉的copy &amp; paste. 如果你平时注重效率，养成了快捷键的习惯，还可能知道一些诸如<code>ctrl-a/x/s/w</code>等。不知你注意到没有，如刚刚列举的很多快捷键，都由<code>特殊的命令符+字母</code>构成。因为在此时，键盘上的大多数按键，都是可以<strong>输入到文本中的字符</strong>。而在vim的正常模式下面，无法直接向文件中输入这些字符，相当于<strong>不用按<code>ctrl</code>等特殊的命令符</strong>，直接可以把这些按键，用作命令的快捷键。</li></ol></li></ul><h3 id="合理的快捷键"><a href="#合理的快捷键" class="headerlink" title="合理的快捷键"></a>合理的快捷键</h3><ul><li>vim中的快捷键，布局非常合理。根据使用频繁程度，调整距离手边的距离。比如，最基础的移动操作，放在手边的<code>HJKL</code>。虽然移动将手移动到键盘上的方向键，并未真正的浪费多少时间，但是其对思维的打断，其实非常影响效率。</li><li>快捷键的设置，也是非常合理，结合了单词的意义、读音，非常便于记忆。比如：<ul><li><code>d</code> delete</li><li><code>c</code> change</li><li><code>w</code> word</li><li><code>e</code> end</li><li><code>b</code> back</li><li><code>I</code> edit</li><li><code>f</code> find</li><li><code>r</code> replace</li></ul></li></ul><h3 id="精细化，多维度命令"><a href="#精细化，多维度命令" class="headerlink" title="精细化，多维度命令"></a>精细化，多维度命令</h3><p>快捷键应有尽有，各个维度移动，都切合使用者思维，几乎可以做到”指哪儿打哪儿“。 比如，移动、删除、复制、等等操作，都可以结合精细化的位置，根据符合人类思维的不同维度，进行操作。 比如，字符，单词，行，文章，屏幕，匹配（位置、文字、符号），以及类似书签的Mark等。</p><h3 id="原子、组合命令"><a href="#原子、组合命令" class="headerlink" title="原子、组合命令"></a>原子、组合命令</h3><p><code>vim</code>的大部分快捷键，都是原子操作，并通过与范围结合，排列组合，灵活多变，完成各种强大的功能。这也与<code>unix</code>的主要思想契合：每个命令做好，且只做好同一件事。 与此同时，通过用数字和宏，代替无意义的重复。 此外，对一些常用操作，提供了现成的宏，方便操作。比如，<code>dd</code>，是删除整行，同时也可以直接用<code>D</code>来完成。<code>I</code>，<code>A</code>等，也是类似道理。</p><h3 id="外部命令-1"><a href="#外部命令-1" class="headerlink" title="外部命令"></a>外部命令</h3><p>类似栈的思路，可以放下当前操作，保存现场，然后进入另一个操作。当操作完成后，回到当前现场。</p><h3 id="思维模式"><a href="#思维模式" class="headerlink" title="思维模式"></a>思维模式</h3><p><code>vim</code>的快捷键，或者说命令，不仅很符合我们的思维，而且还能在很大程度上扩展我们的思维。 拿编辑代码时最多的操作，移动光标来说。原来我们的移动，基本就是通过键盘的方向键，上下左右，或者通过鼠标，移动到想要去的位置。而在<code>vim</code>中，你会发现，光标除了上下左右，还可以移动到词首，词尾，句首，句尾，行首，行尾，页面首部，页面中部，页面尾部，文档首部，文档尾部，文档任意一行，甚至还可以移动到某个指定字母，某个tag，匹配大、中、小括号。度过最初的不适应后，通过刻意练习和日常使用，肌肉形成记忆，便无需刻意回想是用什么命令，而是潜意识完成操作。掌握了这些命令后，当你使用原来的编辑器时，也会去寻找这些快捷键。这就不仅仅是使用<code>vim</code>时候提供效率了，而是通过提高编辑操作的意识、思想，提高了整体的工作效率。</p><p>使用<code>vim</code>一段时间后，我在其他工具中进行编辑时，编再也无法忍受，一个一个自读地移动光标。于是也会主动去找单词、行级别移动的快捷键。</p><ul><li>Mac系统<ul><li><code>cmd + ←/→</code> 移动到：当前行首/尾部</li><li><code>alt + ←/→</code> 移动到：当前单词首/尾部</li></ul></li><li>iterm：<ul><li><code>ctrl + f/b</code> 前进/后退一个字符</li><li><code>Esc + f/b</code> 前进/后退一个单词</li><li><code>ctrl + a/e</code> 行首/行尾</li><li><code>ctrl + h/d</code> 删除光标前/后一个字符</li><li><code>ctrl + w</code> 删除光标前一个单词</li><li><code>ctrl + k/u</code> 删除光标前/后所有内容</li><li><code>ctrl + y</code> 粘贴之前删除的内容</li></ul></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章到这里也就结束了，洋洋洒洒写了这么多，一次读下来就接受，很难；仅仅通过阅读就掌握，更难。想要真正用熟<code>vim</code>，掌握思想，需要后续更多思考、实践。但是相信我，这些付出，一定是值得的。因为它不仅能让你掌握一个开发利器，更能带给你很有价值的思想。</p><br><blockquote><p>原文链接：<a href="https://juejin.im/post/5c14ad47f265da614c4cb018" target="_blank" rel="noopener">https://juejin.im/post/5c14ad47f265da614c4cb018</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Linux中更改MAC地址</title>
      <link href="/blog/2020-03-31-how-to-change-mac-address-on-linux/"/>
      <url>/blog/2020-03-31-how-to-change-mac-address-on-linux/</url>
      
        <content type="html"><![CDATA[<p>在向你展示如何在 Linux 中更改 MAC 地址之前，让我们首先讨论为什么要更改它。</p><p>可能有几个原因。也许你不希望在公共网络上公开你的实际 MAC 地址（也称为物理地址）？还有可能是网络管理员可能已在路由器或防火墙中阻止了特定的 MAC 地址。</p><p>一个实用的“好处”是某些公共网络（例如机场 WiFi）允许在有限的时间内免费上网。如果你还想继续使用，那么伪造 Mac 地址可能会欺骗网络，让它认为是一台新设备。这也是一个有名的原因。</p><p>我将展示更改 MAC 地址（也称为欺骗/伪造 MAC 地址）的步骤。</p><a id="more"></a><h2 id="查找你的-MAC-地址和网络接口"><a href="#查找你的-MAC-地址和网络接口" class="headerlink" title="查找你的 MAC 地址和网络接口"></a>查找你的 MAC 地址和网络接口</h2><p>让我们找出一些<a href="https://itsfoss.com/find-network-adapter-ubuntu-linux/" target="_blank" rel="noopener">关于 Linux 中网卡的细节</a>。使用此命令获取网络接口详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link show</span><br></pre></td></tr></table></figure><p>在输出中，你将看到一些详细信息以及 MAC 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eno1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 94:c6:f8:a7:d7:30 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: enp0s31f6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 38:42:f8:8b:a7:68 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 42:02:07:8f:a7:38 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>如你所见，在这里，我的网络接口称为<code>enp0s31f6</code>，MAC 地址为<code>38:42:f8:8b:a7:68</code>。</p><p>你可能需要在安全的地方记录下来，以便稍后还原到该原始 MAC 地址。</p><p>现在你可以继续更改 MAC 地址。</p><p>注意！</p><p>如果在当前使用的网络接口上执行此操作，那么可能会中断你的网络连接。因此，请在其他网卡上尝试使用此方法，或者准备重启网络。</p><h2 id="方法-1：使用-Macchanger-更改-MAC-地址"><a href="#方法-1：使用-Macchanger-更改-MAC-地址" class="headerlink" title="方法 1：使用 Macchanger 更改 MAC 地址"></a>方法 1：使用 Macchanger 更改 MAC 地址</h2><p><a href="https://github.com/alobbs/macchanger" target="_blank" rel="noopener">Macchanger</a>是查看、修改和操作网卡 MAC 地址的简单程序。它几乎在所有 GNU/Linux 操作系统中都可用，你可以使用发行版的包安装程序进行安装。</p><p>在 Arch Linux 或 Manjaro 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S macchanger</span><br></pre></td></tr></table></figure><p>在 Fedora、CentOS 和 RHEL 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install macchanger</span><br></pre></td></tr></table></figure><p>在 Debian、Ubuntu、Linux Mint、Kali Linux 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install macchanger</span><br></pre></td></tr></table></figure><p>重要！系统会要求你选择是否应将<code>macchanger</code>设置为在每次启动或关闭网络设备时自动运行。每当你接到网线或重启 WiFi 时，它都会提供一个新的 MAC 地址。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331202604.jpg"></fancybox><p>我建议不要自动运行它，除非你确实需要每次更改 MAC 地址。因此，选择“No”（按<code>Tab</code>键），然后按回车键继续。</p><p><strong>如何使用 Macchanger 更改 MAC 地址</strong></p><p>你还记得网络接口名称吗？你在前面的步骤中获得了它。</p><p>现在，要将随机 MAC 地址分配给该网卡，请使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo macchanger -r enp0s31f6</span><br></pre></td></tr></table></figure><p>更改 MAC 后，使用以下命令进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>现在你将看到已经伪造 MAC。</p><p>要将 MAC 地址更改为特定值，请使用以下命令指定自定义 MAC 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger --mac&#x3D;XX:XX:XX:XX:XX:XX</span><br></pre></td></tr></table></figure><p>其中 XX:XX:XX:XX:XX:XX 是你要更改的新 MAC。</p><p>最后，要将 MAC 地址恢复为其原始硬件值，请运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macchanger -p enp0s31f6</span><br></pre></td></tr></table></figure><p>但是，你不必如此。重启系统后，更改将自动丢失，并且实际的 MAC 地址将再次恢复。</p><p>你可以随时查看手册页以获取更多详细信息。</p><h2 id="方法-2：使用-iproute2-更改-Mac-地址（中级知识）"><a href="#方法-2：使用-iproute2-更改-Mac-地址（中级知识）" class="headerlink" title="方法 2：使用 iproute2 更改 Mac 地址（中级知识）"></a>方法 2：使用 iproute2 更改 Mac 地址（中级知识）</h2><p>我建议你使用 macchanger，但如果你不想使用它，那么可以使用另一种方法在 Linux 中更改 MAC 地址。</p><p>首先，使用以下命令关闭网卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set dev enp0s31f6 down</span><br></pre></td></tr></table></figure><p>接下来，使用以下命令设置新的 MAC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set dev enp0s31f6 address XX:XX:XX:XX:XX:XX</span><br></pre></td></tr></table></figure><p>最后，使用以下命令重新打开网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set dev enp0s31f6 up</span><br></pre></td></tr></table></figure><p>现在，验证新的 MAC 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link show enp0s31f6</span><br></pre></td></tr></table></figure><p>就是这些了。你已经成功地在 Linux 中修改了 MAC 地址。敬请期待 FOSS 更多有关 Linux 教程和技巧的文章。</p><br><blockquote><p>原文链接：<a href="https://linux.cn/article-12008-1.html" target="_blank" rel="noopener">https://linux.cn/article-12008-1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底理解文件系统</title>
      <link href="/blog/2020-03-26-understand-file-system/"/>
      <url>/blog/2020-03-26-understand-file-system/</url>
      
        <content type="html"><![CDATA[<fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326171416.png"></fancybox><a id="more"></a><p>所有的应用程序都需要<code>存储</code>和<code>检索</code>信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。<br>第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。</p><p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。</p><p>因此，对于长久存储的信息我们有三个基本需求：</p><ul><li>必须要有可能存储的大量的信息</li><li>信息必须能够在进程终止时保留</li><li>必须能够使多个进程同时访问有关信息</li></ul><p><code>磁盘(Magnetic disk)</code> 一直是用来长久保存信息的设备。近些年来，<code>固态硬盘</code>逐渐流行起来。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326172951.png"></fancybox><p><strong>固态硬盘不仅没有易损坏的移动部件，而且能够提供快速的随机访问</strong>。相比而言，虽然磁带和光盘也被广泛使用，但是它们的<strong>性能相对较差</strong>，通常应用于备份。我们会在后面探讨磁盘，现在姑且把磁盘当作一种大小固定块的线性序列好了，并且支持如下操作</p><ul><li>读块 k</li><li>写块 k</li></ul><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326173316.png"></fancybox><p>事实上磁盘支持更多的操作，<strong>但是只要有了读写操作，原则上就能够解决长期存储的问题</strong>。</p><p>然而，磁盘还有一些不便于实现的操作，特别是在有很多程序或者多用户使用的大型系统上（如服务器）。在这种情况下，很容易产生一些问题，例如</p><ul><li>你如何找到这些信息？</li><li>你如何保证一个用户不会读取另外一个用户的数据？</li><li>你怎么知道哪些块是空闲的？等等问题</li></ul><p>我们可以针对这些问题提出一个新的抽象 - <code>文件</code>。<strong>进程和线程的抽象、地址空间和文件都是操作系统的重要概念</strong>。如果你能真正深入了解这三个概念，那么你就走上了成为操作系统专家的道路。</p><p><code>文件(Files)</code>是由进程创建的逻辑信息单元。一个磁盘会包含几千甚至几百万个文件，每个文件是独立于其他文件的。事实上，如果你能把每个文件都看作一个独立的地址空间，那么你就可以真正理解文件的概念了。</p><p>进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是<code>持久的</code>，这也就是说，不会因为进程的创建和终止而受影响。一个文件只能在当用户明确删除的时候才能消失。尽管读取和写入都是最基本的操作，但还有许多其他操作，我们将在下面介绍其中的一些。</p><p>文件由操作系统进行管理，有关文件的构造、命名、访问、使用、保护、实现和管理方式都是操作系统设计的主要内容。从总体上看，操作系统中处理文件的部分称为<code>文件系统(file system)</code>，这就是我们所讨论的。</p><p>从用户角度来说，用户通常会关心文件是由什么组成的，如何给文件进行命名，如何保护文件，以及可以对文件进行哪些操作等等。尽管是用链表还是用位图记录内存空闲区并不是用户所关心的主题，而这些对系统设计人员来说至关重要。下面我们就来探讨一下这些主题</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p><p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p><p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code>属于第一类；历史悠久的<code>MS-DOS</code>属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326175912.png"></fancybox><p>这里可能需要在文件系统上预留一个位置。Windows 95 和 Windows 98 都使用了 MS-DOS 文件系统，叫做<code>FAT-16</code>，因此继承了它的一些特征，例如有关文件名的构造方法。Windows 98 引入了对 FAT-16 的一些扩展，从而导致了<code>FAT-32</code>的生成，但是这两者很相似。另外，Windows NT，Windows 2000，Windows XP，Windows Vista，Windows 7 和 Windows 8 都支持<code>FAT</code>文件系统，这种文件系统有些过时。然而，这些较新的操作系统还具有更高级的<code>本机文件系统(NTFS)</code>，有不同的特性，那就是基于<code>Unicode</code>编码的文件名。事实上，Windows 8 还配备了另一种文件系统，简称<code>ReFS(Resilient File System)</code>，但这个文件系统一般应用于 Windows 8 的服务器版本。下面除非我们特殊声明，否则我们在提到 MS-DOS 和 FAT 文件系统的时候，所指的就是 Windows 的 FAT-16 和 FAT-32。这里要说一下，有一种类似 FAT 的新型文件系统，叫做<code>exFAT</code>。它是微软公司对闪存和大文件系统开发的一种优化的 FAT 32 扩展版本。ExFAT 是现在微软唯一能够满足<code>OS X</code>读写操作的文件系统。</p><p>许多操作系统支持两部分的文件名，它们之间用 . 分隔开，比如文件名<code>prog.c</code>。原点后面的文件称为<code>文件扩展名(file extension)</code>，文件扩展名通常表示文件的一些信息。例如在 MS-DOS 中，文件名是 1 - 8 个字符，加上 1 - 3 个字符的可选扩展名组成。在 UNIX 中，如果有扩展名，那么扩展名的长度将由用户来决定，一个文件甚至可以包括两个或更多的扩展名，例如<code>homepage.html.zip</code>，html 表示一个 web 网页而 .zip 表示文件<code>homepage.html</code>已经采用 zip 程序压缩完成。一些常用的文件扩展名以及含义如下图所示</p><table><thead><tr><th>扩展名</th><th>含义</th></tr></thead><tbody><tr><td>bak</td><td>备份文件</td></tr><tr><td>c</td><td>c 源程序文件</td></tr><tr><td>gif</td><td>符合图形交换格式的图像文件</td></tr><tr><td>hlp</td><td>帮助文件</td></tr><tr><td>html</td><td>WWW 超文本标记语言文档</td></tr><tr><td>jpg</td><td>符合 JPEG 编码标准的静态图片</td></tr><tr><td>mp3</td><td>符合 MP3 音频编码格式的音乐文件</td></tr><tr><td>mpg</td><td>符合 MPEG 编码标准的电影</td></tr><tr><td>o</td><td>目标文件（编译器输出格式，尚未链接）</td></tr><tr><td>pdf</td><td>pdf 格式的文件</td></tr><tr><td>ps</td><td>PostScript 文件</td></tr><tr><td>tex</td><td>为 TEX 格式化程序准备的输入文件</td></tr><tr><td>txt</td><td>文本文件</td></tr><tr><td>zip</td><td>压缩文件</td></tr></tbody></table><p>在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p><p>名为<code>file.txt</code>的文件是文本文件，这个文件名更多的是提醒所有者，而不是给计算机传递信息。但是另一方面，C 编译器可能要求它编译的文件以<code>.c</code>结尾，否则它会拒绝编译。然而，操作系统并不关心这一点。</p><p>对于可以处理多种类型的程序，约定就显得及其有用。例如 C 编译器可以编译、链接多种文件，包括 C 文件和汇编语言文件。这时扩展名就很有必要，编译器利用它们区分哪些是 C 文件，哪些是汇编文件，哪些是其他文件。因此，扩展名对于编译器判断哪些是 C 文件，哪些是汇编文件以及哪些是其他文件变得至关重要。</p><p>与 UNIX 相反，Windows 就会关注扩展名并对扩展名赋予了新的含义。<code>用户(或进程) </code>可以在操作系统中注册<code>扩展名</code>，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。例如，双击 file.docx 启动了 Word 程序，并以 file.docx 作为初始文件。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件的构造有多种方式。下图列出了常用的三种构造方式</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326182238.png"></fancybox><p>上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p><p>把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。</p><p>图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录</strong>。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗<code>记录树</code>构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key</code>字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p><p>在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的<code>pony</code>记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由<code>操作系统</code>决定的。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有<code>字符特殊文件(character special file) </code>和<code>块特殊文件(block special file)</code>。<code>常规文件(Regular files) </code>是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括<strong>可执行文件、文本文件、图像文件</strong>，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</p><p>字符特殊文件和输入/输出有关，用于串行 I/O 类设备，如终端、打印机、网络等。块特殊文件用于磁盘类设备。我们主要讨论的是常规文件。</p><p>常规文件一般分为<code>ASCII</code>码文件或者二进制文件。ASCII 码文件由文本组成。在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符<code>\r</code>。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符<code>\n</code>）。一些系统（比如 Windows）两者都会使用。</p><p>ASCII 文件的优点在于<code>显示</code>和<code>打印</code>，还可以用任何文本编辑器进行编辑。进一步来说，如果许多应用程序使用 ASCII 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326183010.png"></fancybox><p>其他与 ASCII 不同的是二进制文件。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是字节序列，但是操作系统只有在文件格式正确的情况下才会执行。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326183132.png"></fancybox><p>这个文件有五个段：文件头、征文、数据、重定位位和符号表。文件头以<code>魔数(magic number)</code>为开始，表明这个文件是一个可执行文件（以防止意外执行非此格式的文件）。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在<code>文件头</code>后面，他们被加载到内存中或者重定位会根据<code>重定位位</code>进行判断。符号表则用于<code>调试</code>。</p><p>二进制文件的另外一种形式是<code>存档文件</code>，它由已编译但没有链接的库过程（模块）组合而成。每个文件都以模块头开始，其中记录了<strong>名称、创建日期、所有者、保护码和文件大小</strong>。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。</p><p>所有的操作系统必须至少能够识别一种文件类型：它自己的可执行文件。以前的 TOPS-20 系统（用于DECsystem 20）甚至要检查要执行的任何文件的创建时间，为了定位资源文件来检查自动文件创建后是否被修改过。如果被修改过了，那么就会自动编译文件。在 UNIX 中，就是在 shell 中嵌入<code>make</code>程序。此时操作系统要求用户必须采用固定的文件扩展名，从而确定哪个源程序生成哪个二进制文件。</p><blockquote><p>什么是 make 程序？在软件发展过程中，make 程序是一个自动编译的工具，它通过读取称为<code>Makefiles</code>的文件来自动从源代码构建可执行程序和库，该文件指定了如何导出目标程序。尽管集成开发环境和特定于语言的编译器功能也可以用于管理构建过程，但 Make 仍被广泛使用，尤其是在 Unix 和类似 Unix 的操作系统中使用。</p></blockquote><p>当程序从文件中读写数据时，请求会转到<code>内核处理程序(kernel driver)</code>。如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。</p><p>当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事儿。</p><ul><li><code>块设备</code>也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，块设备的概念是，相应的硬件可以一次读取或者写入整个块，例如磁盘上的一个扇区</li><li><code>字符设备</code>也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。</li></ul><p><code>目录(Directories) </code>是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于<code>分层文件系统</code>中，例如 Linux，MS-DOS 和 UNIX。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326184014.png"></fancybox><p>它显示所有本地和子目录（例如，cdn 目录中的 big 目录）。当前目录是 C 盘驱动器的<code>根目录</code>。之所以称为根目录，是因为该目录下没有任何内容，而其他目录都在该目录下<code>分支</code>。</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p><p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p><p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p><p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用<code>read</code>从头开始读取。另一种是用一个特殊的<code>seek</code>操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的<code>属性(attributes)</code>。有些人也喜欢把它们称作<code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code>和<code>清除(clear)</code>。下面是一些常用的属性</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>保护</td><td>谁可以访问文件、以什么方式存取文件</td></tr><tr><td>密码（口令）</td><td>访问文件所需要的密码（口令）</td></tr><tr><td>创建者</td><td>创建文件者的 ID</td></tr><tr><td>所有者</td><td>当前所有者</td></tr><tr><td>只读标志</td><td>0 表示读/写，1 表示只读</td></tr><tr><td>隐藏标志</td><td>0 表示正常，1 表示不再列表中显示</td></tr><tr><td>系统标志</td><td>0 表示普通文件，1 表示系统文件</td></tr><tr><td>存档标志</td><td>0 表示已经备份，1 表示需要备份</td></tr><tr><td>ASCII / 二进制标志</td><td>0 表示 ASCII 文件，1 表示二进制文件</td></tr><tr><td>随机访问标志</td><td>0 表示只允许顺序访问，1 表示随机访问</td></tr><tr><td>临时标志</td><td>0 表示正常，1 表示进程退出时删除该文件</td></tr><tr><td>加锁标志</td><td>0 表示未加锁，1 表示加锁</td></tr><tr><td>记录长度</td><td>一个记录中的字节数</td></tr><tr><td>键的位置</td><td>每个记录中的键的偏移量</td></tr><tr><td>键的长度</td><td>键字段的字节数</td></tr><tr><td>创建时间</td><td>创建文件的日期和时间</td></tr><tr><td>最后一次存取时间</td><td>上一次访问文件的日期和时间</td></tr><tr><td>最后一次修改时间</td><td>上一次修改文件的日期和时间</td></tr><tr><td>当前大小</td><td>文件的字节数</td></tr><tr><td>最大长度</td><td>文件可能增长到的字节数</td></tr></tbody></table><p>没有一个系统能够同时具有上面所有的属性，但每个属性都在某个系统中采用。</p><p>前面四个属性（保护，口令，创建者，所有者）与文件保护有关，它们指出了谁可以访问这个文件，谁不能访问这个文件。</p><blockquote><p><code>保护（File Protection）</code>： 用于保护计算机上有价值数据的方法。文件保护是通过密码保护文件或者仅仅向特定用户或组提供权限来实现。</p></blockquote><p>在一些系统中，用户必须给出口令才能访问文件。<code>标志(flags)</code>是一些位或者短属性能够控制或者允许特定属性。</p><ul><li>隐藏文件位(hidden flag)表示该文件不在文件列表中出现。</li><li>存档标志位(archive flag)用于记录文件是否备份过，由备份程序清除该标志位；若文件被修改，操作系统则设置该标志位。用这种方法，备份程序可以知道哪些文件需要备份。</li><li>临时标志位(temporary flag) 允许文件被标记为是否允许自动删除当进程终止时。</li></ul><p><code>记录长度(record-length)</code>、<code>键的位置(key-position)</code>和<code>键的长度(key-length)</code>等字段只能出现在用关键字查找记录的文件中。它们提供了查找关键字所需要的信息。</p><p>不同的时间字段记录了文件的创建时间、最近一次访问时间以及最后一次修改时间，它们的作用不同。例如，目标文件生成后被修改的源文件需要重新编译生成目标文件。这些字段提供了必要的信息。</p><p>当前大小字段指出了当前的文件大小，一些旧的大型机操作系统要求在创建文件时指定文件呢最大值，以便让操作系统提前保留最大存储值。但是一些服务器和个人计算机却不用设置此功能。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p><ol><li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li><li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li><li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li><li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li><li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li><li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li><li><code>append</code>，使用 append 只能向文件末尾添加数据。</li><li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li><li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li><li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li><li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通常提供<code>目录(directories) </code>或者<code>文件夹(folders) </code>用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p><h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326230632.png"></fancybox><p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p><h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326232744.png"></fancybox><p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了<code>子目录</code>。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p><h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。举个例子，<code>/usr/ast/mailbox</code>意味着根目录包含一个子目录<code>usr</code>，usr下面包含了一个<code>mailbox</code>。绝对路径名总是以<code>/</code>开头，并且是唯一的。在UNIX中，路径的组件由<code>/</code>分隔。在Windows中，分隔符为<code>\</code>。 在 MULTICS 中，它是<code>></code>。 因此，在这三个系统中，相同的路径名将被编写如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows \usr\ast\mailbox</span><br><span class="line">UNIX &#x2F;usr&#x2F;ast&#x2F;mailbox</span><br><span class="line">MULTICS &gt;usr&gt;ast&gt;mailbox</span><br></pre></td></tr></table></figure><p>不论使用哪种方式，如果路径名的第一个字符是分隔符，那就是绝对路径。</p><p>另外一种指定文件名的方法是<code>相对路径名(relative path name)</code>。它常常和<code>工作目录(working directory) </code>（也称作<code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是<code>/usr/ast</code>，那么绝对路径<code>/usr/ast/mailbox</code>可以直接使用<code>mailbox</code>来引用。也就是说，如果工作目录是<code>/usr/ast</code>，则 UNIX 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;ast&#x2F;mailbox  &#x2F;usr&#x2F;ast&#x2F;mailbox.bak</span><br></pre></td></tr></table></figure><p>和命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mailbox mailbox.bak</span><br></pre></td></tr></table></figure><p>具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。</p><p>一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。</p><p>支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项<code>.</code>和<code>..</code>，长读作<code>dot</code>和<code>dotdot</code>。dot 指的是当前目录，dotdot 指的是其父目录（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200326234859.png"></fancybox><p>一个进程的工作目录是<code>/usr/ast</code>，它可采用<code>..</code>沿树向上，例如，可用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ..&#x2F;lib&#x2F;dictionary .</span><br></pre></td></tr></table></figure><p>把文件<code>usr/lib/dictionary</code>复制到自己的目录下，第一个路径告诉系统向上找（到 usr 目录），然后向下到<code>lib</code>目录，找到 dictionary 文件</p><p>第二个参数 . 指定当前的工作目录，当 cp 命令用目录名作为最后一个参数时，则把全部的文件复制到该目录中。当然，对于上述复制，键入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary</span><br></pre></td></tr></table></figure><p>是更常用的方法。用户这里采用<code>.</code>可以避免键入两次 dictionary 。无论如何，键入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary dictionary</span><br></pre></td></tr></table></figure><p>也可正常工作，就像键入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary &#x2F;usr&#x2F;lib&#x2F;dictionary</span><br></pre></td></tr></table></figure><p>一样。所有这些命令都能够完成同样的工作。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p><ol><li><code>Create</code>，创建目录，除了目录项<code>.</code>和<code>..</code>外，目录内容为空。</li><li><code>Delete</code>，删除目录，只有空目录可以删除。只包含<code>.</code>和<code>..</code>的目录被认为是空目录，这两个目录项通常不能删除</li><li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li><li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li><li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li><li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li><li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为硬链接(hard link)。</li><li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li></ol><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><p>在对文件有了基本认识之后，现在是时候把目光转移到文件系统的<code>实现</code>上了。之前用户关心的一直都是文件是怎样命名的、可以进行哪些操作、目录树是什么，如何找到正确的文件路径等问题。而设计人员关心的是文件和目录是怎样存储的、磁盘空间是如何管理的、如何使文件系统得以流畅运行的问题，下面我们就来一起讨论一下这些问题。</p><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存储在<code>磁盘</code>中。大部分的磁盘能够划分出一到多个分区，叫做<code>磁盘分区(disk partitioning) </code>或者是<code>磁盘分片(disk slicing)</code>。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为<code>主引导记录(Master Boot Record, MBR)</code>，用来<code>引导(boot) </code>计算机。在 MBR 的结尾是<code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。系统管理员使用一个称为分区编辑器的程序来创建，调整大小，删除和操作分区。这种方式的一个缺点是很难适当调整分区的大小，导致一个分区具有很多可用空间，而另一个分区几乎完全被分配。</p><blockquote><p>MBR 可以用在 DOS 、Microsoft Windows 和 Linux 操作系统中。从 2010 年代中期开始，大多数新计算机都改用 GUID 分区表（GPT）分区方案。</p></blockquote><p>下面是一个用<code>GParted</code>进行分区的磁盘，表中的分区都被认为是<code>活动的(active)</code>。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327104048.png"></fancybox><p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>MBR 做的第一件事就是<code>确定活动分区</code>，读入它的第一个块，称为<code>引导块(boot block) </code>并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</p><blockquote><p>在计算机中，引导就是启动计算机的过程，它可以通过硬件（例如按下电源按钮）或者软件命令的方式来启动。开机后，电脑的 CPU 还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中，然后才能让 CPU 开始执行。也就是计算机开机后，首先会进行软件的装载过程。</p><p>重启电脑的过程称为<code>重新引导(rebooting)</code>，从休眠或睡眠状态返回计算机的过程不涉及启动。</p></blockquote><p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327113055.png"></fancybox><h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>紧跟在引导块后面的是<code>超级块(Superblock)</code>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</p><ul><li>文件系统的大小</li><li>文件系统中的数据块数</li><li>指示文件系统状态的标志</li><li>分配组大小</li></ul><p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p><h4 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h4><p>接着是文件系统中<code>空闲块</code>的信息，例如，可以用位图或者指针列表的形式给出。</p><p><strong>BitMap 位图或者 Bit vector 位向量</strong></p><p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327115456.png"></fancybox><p><strong>使用链表进行管理</strong></p><p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327120339.png"></fancybox><p><strong>碎片</strong></p><p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。如果你不理解这个概念就给你举个例子。比如你用 Windows 电脑创建了一个文件，你会发现这个文件可以存储在任何地方，比如存在桌面上，存在磁盘中的文件夹中或者其他地方。你可以打开文件，编辑文件，删除文件等等。你可能以为这些都在一个地方发生，但是实际上并不是，你的硬盘驱动器可能会将文件中的一部分存储在一个区域内，另一部分存储在另外一个区域，在你打开文件时，硬盘驱动器会迅速的将文件的所有部分汇总在一起，以便其他计算机系统可以使用它。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327120828.png"></fancybox><p><strong>inode</strong></p><p>然后在后面是一个<code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</p><p>有一种简单的方法可以找到它们<code>ls -lai</code>命令。让我们看一下根文件系统：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327121225.png"></fancybox><p>inode 节点主要包括了以下信息</p><ul><li>模式/权限（保护）</li><li>所有者 ID</li><li>组 ID</li><li>文件大小</li><li>文件的硬链接数</li><li>上次访问时间</li><li>最后修改时间</li><li>inode 上次修改时间</li></ul><p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p><p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<code>有效利用文件空间</code>和<code>快速访问文件</code> ，主要有三种分配方案</p><ul><li>连续分配</li><li>链表分配</li><li>索引分配</li></ul><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327122537.png"></fancybox><p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p><p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了<code>3 又 1/2</code>个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p><p>连续的磁盘空间分配有两个优点。</p><ul><li><p>第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</p></li><li><p>第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</p></li></ul><p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p><p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327122917.png"></fancybox><p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p><p>刚开始的时候，这个碎片不是问题，因为每个新文件都会在之前文件的结尾处进行写入。然而，磁盘最终会被填满，<strong>因此要么压缩磁盘、要么重新使用空闲块的空间</strong>。压缩磁盘的开销太大，因此不可行；后者会维护一个空闲列表，这个是可行的。但是这种情况又存在一个问题，为空闲块匹配合适大小的文件，需要知道该文件的<code>最终大小</code>。</p><p>想象一下这种设计的结果会是怎样的。用户启动 word 进程创建文档。应用程序首先会询问最终创建的文档会有多大。这个问题必须回答，否则应用程序就不会继续执行。如果空闲块的大小要比文件的大小小，程序就会终止。因为所使用的磁盘空间已经满了。那么现实生活中，有没有使用连续分配内存的介质出现呢？</p><p><code>CD-ROM</code>就广泛的使用了连续分配方式。</p><blockquote><p>CD-ROM（Compact Disc Read-Only Memory）即只读光盘，也称作只读存储器。是一种在电脑上使用的光碟。这种光碟只能写入数据一次，信息将永久保存在光碟上，使用时通过光碟驱动器读出信息。</p></blockquote><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327123251.png"></fancybox><p>然而 DVD 的情况会更加复杂一些。原则上，一个<code>90分钟</code>的电影能够被编码成一个独立的、大约 4.5 GB 的文件。但是文件系统所使用的<code>UDF(Universal Disk Format) </code>格式，使用一个 30 位的数来代表文件长度，从而把文件大小限制在 1 GB。所以，DVD 电影一般存储在 3、4个连续的 1 GB 空间内。这些构成单个电影中的文件块称为<code>扩展区(extends)</code>。</p><p>就像我们反复提到的，<code>历史总是惊人的相似</code>，许多年前，连续分配由于其<code>简单</code>和<code>高性能</code>被实际使用在磁盘文件系统中。后来由于用户不希望在创建文件时指定文件的大小，于是放弃了这种想法。但是随着 CD-ROM 、DVD、蓝光光盘等光学介质的出现，连续分配又流行起来。从而得出结论，<code>技术永远没有过时性</code>，现在看似很老的技术，在未来某个阶段可能又会流行起来。</p><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327123911.png"></fancybox><p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327124053.png"></fancybox><p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p><p>另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</p><p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p><h4 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h4><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327124240.png"></fancybox><p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址<strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为<code>文件分配表(File Application Table,FAT)</code>。</p><p>使用这种组织方式，整个块都可以存放数据。进而，随机访问也容易很多。虽然仍要顺着链在内存中查找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。</p><p>这种方式存在缺点，那就是<strong>必须要把整个链表放在内存中</strong>。对于 1TB 的磁盘和 1KB 的大小的块，那么这张表需要有 10 亿项。。。每一项对应于这 10 亿个磁盘块中的一块。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 的内存。FAT 的管理方式不能较好地扩展并应用于大型磁盘中。而这正是最初 MS-DOS 文件比较实用，并仍被各个 Windows 版本所安全支持。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为<code>inode(索引节点) </code>的数据结构，每个文件都与一个<code>inode</code>进行关联，inode 由整数进行标识。</p><p>下面是一个简单例子的描述。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327124635.png"></fancybox><p>给出 inode 的长度，就能够找到文件中的所有块。</p><p>相对于在内存中使用表的方式而言，这种机制具有很大的优势。即只有在文件打开时，其 inode 才会在内存中。如果每个 inode 需要 n 个字节，最多 k 个文件同时打开，那么 inode 占有总共打开的文件是 kn 字节。仅需预留这么多空间。</p><p>这个数组要比我们上面描述的<code>FAT(文件分配表) </code>占用的空间小的多。原因是用于保存所有磁盘块的链接列表的表的大小与磁盘本身成正比。如果磁盘有 n 个块，那么这个表也需要 n 项。随着磁盘空间的变大，那么该表也随之<code>线性增长</code>。相反，inode 需要节点中的数组，其大小和可能需要打开的最大文件个数成正比。它与磁盘是 100GB、4000GB 还是 10000GB 无关。</p><p>inode 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是<strong>最后一个磁盘地址不指向数据块</strong>，而是<strong>指向一个包含额外磁盘块地址的地址</strong>，如上图所示。一个更高级的解决方案是：有两个或者更多包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。Windows 的 NTFS 文件系统采用了相似的方法，所不同的仅仅是大的 inode 也可以表示小的文件。</p><blockquote><p>NTFS 的全称是<code>New Technology File System</code>，是微软公司开发的专用系统文件，NTFS 取代 FAT(文件分配表) 和<code>HPFS(高性能文件系统) </code>，并在此基础上进一步改进。例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率等。</p></blockquote><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用那种情况，目录系统的主要功能就是<strong>将文件的 ASCII 码的名称映射到定位数据所需的信息上</strong>。</p><p>与此关系密切的问题是属性应该存放在哪里。每个文件系统包含不同的文件属性，例如文件的所有者和创建时间，需要存储的位置。一种显而易见的方法是直接<strong>把文件属性存放在目录中</strong>。有一些系统恰好是这么做的，如下。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327125212.png"></fancybox><p>在这种简单的设计中，目录有一个固定大小的目录项列表，每个文件对应一项，其中包含一个固定长度的文件名，文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p><p>对于采用 inode 的系统，会把 inode 存储在属性中而不是目录项中。在这种情况下，目录项会更短：仅仅只有文件名称和 inode 数量。这种方式如下所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327125259.png"></fancybox><p>到目前为止，我们已经假设文件具有较短的、固定长度的名字。在 MS-DOS 中，具有 1 - 8 个字符的基本名称和 1 - 3 个字符的可拓展名称。在 UNIX 版本 7 中，文件有 1 - 14 个字符，包括任何拓展。然而，几乎所有的现代操作系统都支持可变长度的扩展名。这是如何实现的呢？</p><p>最简单的方式是给予文件名一个长度限制，比如 255 个字符，然后使用上图中的设计，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间，因为只有很少的文件会有那么长的文件名称。所以，需要一种其他的结构来处理。</p><p>一种可选择的方式是放弃所有目录项大小相同的想法。在这种方法中，每个目录项都包含一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括<strong>所有者、创建时间、保护信息和其他属性</strong>。这个固定长度的头的后面是一个任意长度的实际文件名，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327125457.png"></fancybox><p>上图是 SPARC 机器使用正序放置。</p><blockquote><p>处理机中的一串字符存放的顺序有<code>正序(big-endian) </code>和<code>逆序(little-endian) </code>之分。正序存放的就是高字节在前低字节在后，而逆序存放的就是低字节在前高字节在后。</p></blockquote><p>这个例子中，有三个文件，分别是<code>project-budget</code>、<code>personnel</code>和<code>foo</code>。每个文件名以一个特殊字符（通常是 0 ）结束，用矩形中的叉进行表示。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327130244.png"></fancybox><p>这个方法的缺点是当文件被移除后，就会留下一块固定长度的空间，而新添加进来的文件大小不一定和空闲空间大小一致。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327130417.png"></fancybox><p>这个问题与我们上面探讨的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行<code>紧凑拼接</code>操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页上，<code>在读取文件名时可能发生缺页中断</code>。</p><p>处理可变长度文件名字的另外一种方法是，使目录项自身具有固定长度，而将文件名放在目录末尾的堆栈中。如上图所示的这种方式。这种方法的优点是当目录项被移除后，下一个文件将能够正常匹配移除文件的空间。当然，必须要对<code>堆</code>进行管理，因为在处理文件名的时候也会发生缺页异常。</p><p>到目前为止的所有设计中，在需要查找文件名时，所有的方案都是线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低。提高文件检索效率的一种方式是在每个目录上使用<code>哈希表(hash table)</code>，也叫做散列表。我们假设表的大小为 n，在输入文件名时，文件名被散列在 0 和 n - 1 之间，例如，它被 n 除，并取余数。或者对构成文件名字的字求和或类似某种方法。</p><p>无论采用哪种方式，<strong>在添加一个文件时都要对与散列值相对 应的散列表进行检查</strong>。如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表（这种构造方式是不是和 HashMap 使用的数据结构一样？），链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327130718.png"></fancybox><p>查找文件的过程和添加类似，首先对文件名进行哈希处理，在哈希表中查找是否有这个哈希值，如果有的话，就检查这条链上所有的哈希项，查看文件名是否存在。如果哈希不在链上，那么文件就不在目录中。</p><p>使用哈希表的优势是<code>查找非常迅速</code>，缺点是<code>管理起来非常复杂</code>。只有在系统中会有成千上万个目录项存在时，才会考虑使用散列表作为解决方案。</p><p>另外一种在大量目录中加快查找指令目录的方法是使用<code>缓存</code>，缓存查找的结果。在开始查找之前，会首先检查文件名是否在缓存中。如果在缓存中，那么文件就能立刻定位。当然，只有在较少的文件下进行多次查找，缓存才会发挥最大功效。</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是<strong>C 的一个文件也出现在了 B 的目录下</strong>。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327131031.png"></fancybox><p>如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为<code>链接(link)</code>。那么文件系统现在就是一个<code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p><blockquote><p>在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个<code>有向无环图</code>，我们不会在此着重探讨关于图论的东西，大家可以自行 google。</p></blockquote><p>将文件系统组织成为有向无环图会使得维护复杂化，但也是必须要付出的代价。</p><p><code>共享文件</code>很方便，但这也会带来一些问题。如果目录中包含磁盘地址，则当链接文件时，<code>必须把 C 目录中的磁盘地址复制到 B 目录中</code>。如果 B 或者 C 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327131647.png"></fancybox><p>有两种方案可以解决这种问题。</p><ul><li><p>第一种解决方案，磁盘块不列入目录中，而是会把磁盘块放在与文件本身相关联的小型数据结构中。目录将指向这个小型数据结构。这是<code>UNIX</code>中使用的方式（小型数据结构就是 inode）。</p></li><li><p>在第二种解决方案中，通过让系统建立一个类型为<code>LINK</code>的新文件，并把该文件放在 B 的目录下，使得 B 与 C 建立链接。新的文件中只包含了它所链接的文件的路径名。当 B 想要读取文件时，操作系统会检查 B 的目录下存在一个类型为 LINK 的文件，进而找到该链接的文件和路径名，然后再去读文件，这种方式称为<code>符号链接(symbolic linking)</code>。</p></li></ul><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327140723.png"></fancybox><p>上面的每一种方法都有各自的缺点，在第一种方式中，B 链接到共享文件时，inode 记录文件的所有者为 C。<strong>建立一个链接并不改变所有关系</strong>，如下图所示。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327141156.png"></fancybox><p>第一开始的情况如图 a 所示，此时 C 的目录的所有者是 C ，当目录 B 链接到共享文件时，并不会改变 C 的所有者关系，只是把计数 + 1，所以此时<strong>系统知道目前有多少个目录指向这个文件</strong>。然后 C 尝试删除这个文件，这个时候有个问题，如果 C 把文件移除并清除了 inode 的话，那么 B 会有一个目录项指向无效的节点。如果 inode 以后分配给另一个文件，则 B 的链接指向一个错误的文件。系统通过 inode 可知文件仍在被引用，但是没有办法找到该文件的全部目录项以删除它们。指向目录的指针不能存储在 inode 中，原因是有可能有无数个这样的目录。</p><p>所以我们能做的就是删除 C 的目录项，但是将 inode 保留下来，并将计数设置为 1 ，如上图 c 所示。c 表示的是只有 B 有指向该文件的目录项，而该文件的前者是 C 。如果系统进行记账操作的话，那么 C 将继续为该文件付账直到 B 决定删除它，如果是这样的话，只有到计数变为 0 的时刻，才会删除该文件。</p><p>对于<code>符号链接</code>，以上问题不会发生，只有真正的文件所有者才有一个指向 inode 的指针。链接到该文件上的用户只有路径名，没有指向 inode 的指针。当文件所有者删除文件时，该文件被销毁。以后若试图通过符号链接访问该文件将会失败，因为系统不能找到该文件。删除符号链接不会影响该文件。</p><p>符号链接的问题是<strong>需要额外的开销</strong>。必须读取包含路径的文件，然后要一个部分接一个部分地扫描路径，直到找到 inode 。这些操作也许需要很多次额外的磁盘访问。此外，每个符号链接都需要额外的 inode ，以及额外的一个磁盘块用于存储路径，虽然如果路径名很短，作为一种优化，系统可以将它存储在 inode 中。符号链接有一个优势，即只要<strong>简单地提供一个机器的网络地址以及文件在该机器上驻留的路径</strong>，就可以连接全球任何地方机器上的文件。</p><p>还有另一个由链接带来的问题，在符号链接和其他方式中都存在。如果允许链接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被链接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被链接的文件将被两次复制到磁盘上，而不是只是被链接起来。</p><h3 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p><p>这些因素结合起来意味着许多系统文件中出现性能瓶颈。为此，<code>Berkeley</code>设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是<code>日志结构文件系统(Log-structured File System, LFS)</code>。</p><p>日志结构文件系统由<code>Rosenblum</code>和<code>Ousterhout</code>于90年代初引入，旨在解决以下问题。</p><ul><li>不断增长的系统内存</li><li>顺序 I/O 性能胜过随机 I/O 性能</li><li>现有低效率的文件系统</li><li>文件系统不支持 RAID（虚拟化）</li></ul><p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为<code>Page cache</code>的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p><p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的<code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p><blockquote><p>日志结构文件系统主要使用四种数据结构：Inode、Inode Map、Segment、Segment Usage Table。</p></blockquote><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327142224.png"></fancybox><p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p><p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p><p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327142603.png"></fancybox><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，它会记录系统下一步将要做什么的日志。微软的<code>NTFS</code>文件系统、Linux 的<code>ext3</code>就使用了此日志。<code>OS X</code>将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如<code>移除文件</code>，这个操作在 UNIX 中需要三个步骤完成：</p><ul><li>在目录中删除文件</li><li>释放 inode 到空闲 inode 池</li><li>将所有磁盘块归还给空闲磁盘池。</li></ul><p>在 Windows 中，也存在类似的步骤。不存在系统崩溃时，这些步骤的执行顺序不会带来问题。但是一旦系统崩溃，就会带来问题。假如在第一步完成后系统崩溃。inode 和文件块将不会被任何文件获得，也不会再分配；它们只存在于废物池中的某个地方，并因此减少了可利用的资源。如果崩溃发生在第二步后，那么只有磁盘块会丢失。<code>日志文件系统</code>保留磁盘写入期间对文件系统所做的更改的日志或日志，该日志可用于快速重建可能由于系统崩溃或断电等事件而发生的损坏。</p><blockquote><p>一般文件系统崩溃后必须运行<code>fsck（文件系统一致性检查）</code>实用程序。</p></blockquote><p>为了让日志能够正确工作，被写入的日志操作必须是<code>幂等的(idempotent)</code>，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作<strong>更新位表并标记 inode k 或者块 n 是空闲的</strong>可以重复执行任意次。同样地，查找一个目录并且删除所有叫<code>foobar</code>的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327143157.png"></fancybox><p>为了增加可靠性，一个文件系统可以引入数据库中<code>原子事务(atomic transaction) </code>的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。</p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统。Windows 中的主要文件系统是<code>NTFS 文件系统</code>，但不是说 Windows 只有 NTFS 操作系统，它还有一些其他的例如旧的<code>FAT -32</code>或<code>FAT -16</code>驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。Windows 通过指定不同的盘符来处理这些不同的文件系统，比如<code>C:</code>，<code>D:</code>等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。</p><p>相比之下，UNIX 采用了一种不同的方式，即 UNIX 把多种文件系统整合到一个统一的结构中。一个 Linux 系统可以使用<code>ext2</code>作为根文件系统，<code>ext3</code>分区装载在<code>/usr</code>下，另一块采用<code>Reiser FS</code>文件系统的硬盘装载到<code>/home</code>下，以及一个 ISO 9660 的 CD - ROM 临时装载到<code>/mnt</code>下。从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，对于用户和进程是不可见的。</p><p>UNIX 操作系统使用一种<code>虚拟文件系统(Virtual File System, VFS) </code>来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327144159.png"></fancybox><p>还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个<code>代理</code>来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的<code>POSIX 系统调用</code>，比如 open、read、write 和 seek 等。VFS 对用户进程有一个<code>上层</code>接口，这个接口就是著名的 POSIX 接口。</p><p>VFS 也有一个对于实际文件的<code>下层</code>接口，就是上图中标记为 VFS 的接口。这个接口包含许多功能调用，这样 VFS 可以使每一个文件系统完成任务。因此，要创建一个可以与 VFS 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 VFS 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，VFS具有两个不同的接口：上一个到用户进程，下一个到具体文件系统。</p><p>当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件时，不管在启动时还是在操作过程中，它们也必须在 VFS 中注册。当一个文件系统注册时，根文件系统注册到 VFS。另外，在引导时或操作期间挂载其他文件系统时，它们也必须向 VFS 注册。当文件系统注册时，其基本作用是提供 VFS 所需功能的地址列表、调用向量表、或者 VFS 对象。因此一旦文件系统注册到 VFS，它就知道从哪里开始读取数据块。</p><p>装载文件系统后就可以使用它了。比如，如果一个文件系统装载到<code>/usr</code>并且一个进程调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;&#x2F;usr&#x2F;include&#x2F;unistd.h&quot;,O_RDONLY)</span><br></pre></td></tr></table></figure><p>当解析路径时， VFS 看到新的文件系统被挂载到<code>/usr</code>，并且通过搜索已经装载文件系统的超级块来确定它的超块。然后它找到它所转载的文件的根目录，在那里查找路径<code>include/unistd.h</code>。然后 VFS 创建一个 vnode 并调用实际文件系统，以返回所有的在文件 inode 中的信息。这个信息和其他信息一起复制到 vnode （内存中）。而这些其他信息中最重要的是指向包含调用 vnode 操作的函数表的指针，比如 read、write 和 close 等。</p><p>当 vnode 被创建后，为了进程调用，VFS 在文件描述符表中创建一个表项，并将它指向新的 vnode，最后，VFS 向调用者返回文件描述符，所以调用者可以用它去 read、write 或者 close 文件。</p><p>当进程用文件描述符进行一个读操作时，VFS 通过进程表和文件描述符确定 vnode 的位置，并跟随指针指向函数表，这样就调用了处理 read 函数，运行在实际系统中的代码并得到所请求的块。VFS 不知道请求时来源于本地硬盘、还是来源于网络中的远程文件系统、CD-ROM 、USB 或者其他介质，所有相关的数据结构欧如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327145335.png"></fancybox><p><strong>从调用者进程号和文件描述符开始，进而是 vnode，读函数指针，然后是对实际文件系统的访问函数定位。</strong></p><h2 id="文件系统的管理和优化"><a href="#文件系统的管理和优化" class="headerlink" title="文件系统的管理和优化"></a>文件系统的管理和优化</h2><p>能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</p><h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><p>文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：<strong>分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</strong>。在存储管理系统中，主要有<code>分段管理</code>和<code>分页管理</code>两种方式。</p><p>正如我们所看到的，按<code>连续字节序列</code>存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照<strong>磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</strong>。在分页系统中，分页大小也是主要因素。</p><p>拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块<code>太大</code>会浪费<code>空间</code>；分配的块<code>太小</code>会浪费<code>时间</code>。</p><h4 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h4><p>一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327150300.png"></fancybox><p>第一种方法是采用<code>磁盘块链表</code>，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</p><p>另一种空闲空间管理的技术是<code>位图(bitmap)</code>，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</p><p>如果空闲块是长期连续的话，那么空闲列表可以改成记录连续分块而不是单个的块。每个块都会使用 8位、16位、32 位的计数来与每个块相联，来记录连续空闲块的数量。最好的情况是一个空闲块可以用两个数字来表示：<strong>第一个空闲块的地址和空闲块的计数</strong>。另一方面，如果磁盘严重碎片化，那么跟踪连续分块要比跟踪单个分块运行效率低，因为不仅要存储地址，还要存储数量。</p><blockquote><p>这种情况说明了一个操作系统设计者经常遇到的一个问题。有许多数据结构和算法可以用来解决问题，但是选择一个<code>最好</code>的方案需要数据的支持，而这些数据是设计者无法预先拥有的。只有在系统部署完毕真正使用使用后才会获得。</p></blockquote><p>现在，回到空闲链表的方法，只有一个指针块保存在内存中。创建文件时，所需要的块从指针块中取出。当它用完时，将从磁盘中读取一个新的指针块。类似地，删除文件时，文件的块将被释放并添加到主存中的指针块中。当块被填满时，写回磁盘。</p><p>在某些特定的情况下，这个方法导致了不必要的磁盘 IO，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327150630.png"></fancybox><p>上面内存中的指针块仅有两个空闲块，如果释放了一个含有三个磁盘块的文件，那么该指针块就会溢出，必须将其写入磁盘，那么就会产生如下图的这种情况。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327150803.png"></fancybox><p>如果现在写入含有三个块的文件，已满的指针不得不再次读入，这将会回到上图 a 中的情况。如果有三个块的文件只是作为临时文件被写入，在释放它时，需要进行另一次磁盘写操作以将完整的指针块写回到磁盘。简而言之，当指针块几乎为空时，一系列短暂的临时文件可能会<strong>导致大量磁盘 I/O</strong>。</p><p>避免大部分磁盘 I/O 的另一种方法是<code>拆分完整的指针块</code>。这样，当释放三个块时，变化不再是从 a - b，而是从 a - c，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327151032.png"></fancybox><p>现在，系统可以处理一系列临时文件，而不需要进行任何磁盘 I/O。如果内存中指针块满了，就写入磁盘，半满的指针块从磁盘中读入。这里的思想是：要保持磁盘上的大多数指针块为满的状态（减少磁盘的使用），但是在内存中保留了一个半满的指针块。这样，就可以既处理文件的创建又同时可以处理文件的删除操作，而不会为空闲表进行磁盘 I/O。</p><p>对于位图，会在内存中只保留一个块，只有在该块满了或空了的情形下，才到磁盘上取另一个块。通过在位图的单一块上进行所有的分配操作，磁盘块会紧密的聚集在一起，从而<code>减少了磁盘臂的移动</code>。由于位图是一种固定大小的数据结构，所以如果内核是<code>分页</code>的，就可以把位图放在虚拟内存中，在需要时将位图的页面调入。</p><h3 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h3><p>为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种<code>磁盘配额(enforcing disk quotas)</code>的机制。系统管理员为每个用户分配<strong>最大的文件和块分配</strong>，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</p><p>在用户打开一个文件时，操作系统会找到<code>文件属性</code>和<code>磁盘地址</code>，并把它们送入内存中的打开文件表。其中一个属性告诉<code>文件所有者</code>是谁。任何有关文件的增加都会记到所有者的配额中。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200327153856.png"></fancybox><p>第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</p><p>当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加<code>硬限制</code>和<code>软限制</code>的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</p><blockquote><p>什么是硬限制和软限制？<strong>硬限制是软限制的上限</strong>。软限制是为会话或进程实际执行的限制。这允许管理员（或用户）将硬限制设置为允许它们希望允许的最大使用上限。然后，其他用户和进程可以根据需要使用软限制将其资源使用量自限制到更低的上限。</p></blockquote><p>当一个用户尝试登陆，系统将检查配额文件以查看用户是否超出了文件数量或磁盘块数量的<code>软限制</code>。如果违反了任一限制，则会显示警告，保存的警告计数减 1，如果警告计数为 0 ，表示用户多次忽略该警告，因而将不允许该用户登录。要想再得到登录的许可，就必须与系统管理员协商。</p><p>如果用户在退出系统时消除所超过的部分，他们就可以再一次终端会话期间超过其软限制，但<strong>无论什么情况下都不会超过硬限制</strong>。</p><h3 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h3><p>文件系统的毁坏要比计算机的损坏严重很多。无论是硬件还是软件的故障，只要计算机文件系统被破坏，要恢复起来都是及其困难的，甚至是不可能的。因为文件系统无法抵御破坏，因而我们要在文件系统在被破坏之前做好<code>数据备份</code>，但是备份也不是那么容易，下面我们就来探讨备份的过程。</p><p>许多人认为为文件系统做备份是不值得的，并且很浪费时间，直到有一天他们的磁盘坏了，他们才意识到事情的严重性。相对来说，公司在这方面做的就很到位。磁带备份主要要处理好以下两个潜在问题中的一个</p><ul><li>从意外的灾难中恢复</li></ul><p>这个问题主要是由于外部条件的原因造成的，比如磁盘破裂，水灾火灾等。</p><ul><li>从错误的操作中恢复</li></ul><p>第二个问题通常是由于用户意外的删除了原本需要还原的文件。这种情况发生的很频繁，使得 Windows 的设计者们针对<code>删除</code>命令专门设计了特殊目录，这就是<code>回收站(recycle bin)</code>，也就是说，在删除文件的时候，文件本身并不真正从磁盘上消失，而是被放置到这个特殊目录下，等以后需要的时候可以还原回去。文件备份更主要是指这种情况，能够允许几天之前，几周之前的文件从原来备份的磁盘进行还原。</p><p>做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要<strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p><p>其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种<code>增量转储(incremental dumps)</code> 的思想。最简单的增量转储的形式就是<code>周期性</code>的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</p><blockquote><p>周期性：比如一周或者一个月</p></blockquote><p>稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为<strong>最近的全面转储先要全部恢复，随后按逆序进行增量转储</strong>。为了方便恢复，人们往往使用更复杂的转储模式。</p><p>第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</p><p>第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的<code>瞬时快照</code>，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</p><p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。<code>物理转储(physical dump) </code>是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</p><p>第二个需要考虑的是<strong>坏块的转储</strong>。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些<code>坏块(bad blocks)</code>。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</p><p>然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的<code>文件</code>来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。<strong>那么此文件是完全不可读的</strong>。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</p><p>Windows 系统有<code>分页文件(paging files)</code>和<code>休眠文件(hibernation files)</code>。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</p><h4 id="物理转储和逻辑转储"><a href="#物理转储和逻辑转储" class="headerlink" title="物理转储和逻辑转储"></a>物理转储和逻辑转储</h4><p>物理转储的主要优点是简单、极为快速（基本上是以磁盘的速度运行），缺点是<code>全量备份</code>，不能跳过指定目录，也不能增量转储，也不能恢复个人文件的请求。因此绝<strong>大多数情况下不会使用物理转储，而使用逻辑转储</strong>。</p><p><code>逻辑转储(logical dump)</code>从一个或几个指定的目录开始，递归转储自指定日期开始后更改的文件和目录。因此，在逻辑转储中，转储磁盘上有一系列经过仔细识别的目录和文件，这使得根据请求轻松还原特定文件或目录。</p><p>既然逻辑转储是最常用的方式，那么下面就让我们研究一下逻辑转储的通用算法。此算法在 UNIX 系统上广为使用，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331154513.png"></fancybox><p>待转储的文件系统，其中方框代表<code>目录</code>，圆圈代表<code>文件</code>。黄色的项目表是自上次转储以来修改过。每个目录和文件都被标上其 inode 号。</p><p>此算法会转储位于修改文件或目录路径上的所有目录（也包括未修改的目录），原因有两个。第一是能够在不同电脑的文件系统中恢复转储的文件。通过这种方式，转储和重新存储的程序能够用来在两个电脑之间<code>传输整个文件系统</code>。第二个原因是能够对单个文件进行<code>增量恢复</code>。</p><p>逻辑转储算法需要维持一个inode为索引的<code>位图(bitmap)</code>，每个 inode 包含了几位。随着算法的进行，位图中的这些位会被设置或清除。算法的执行分成四个阶段。第一阶段从<code>起始目录（本例为根目录）</code>开始检查其中所有的目录项。对每一个修改过的文件，该算法将在位图中标记其 inode。算法还会标记并递归检查每一个目录（不管是否修改过）。</p><p>在第一阶段结束时，所有修改过的文件和全部目录都在位图中标记了，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331155147.png"></fancybox><p>理论上来说，第二阶段再次递归遍历目录树，并去掉目录树中任何不包含被修改过的文件或目录的标记。本阶段执行的结果如下</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331155344.png"></fancybox><p>注意，inode 编号为 10、11、14、27、29 和 30 的目录已经被去掉了标记，因为它们所包含的内容<code>没有修改</code>。它们也不会转储。相反，inode 编号为 5 和 6 的目录本身尽管没有被修改过也要被转储，因为在新的机器上恢复当日的修改时需要这些信息。为了提高算法效率，可以将这两阶段的目录树遍历合二为一。</p><p>现在已经知道了哪些目录和文件必须被转储了，这就是上图 b 中标记的内容，第三阶段算法将以节点号为序，扫描这些 inode 并转储所有标记为需转储的目录，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331155612.png"></fancybox><p>为了进行恢复，每个被转储的目录都用目录的属性（所有者、时间）作为前缀。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331155846.png"></fancybox><p>最后，在第四阶段，上图中被标记的文件也被转储，同样，由其文件属性作为前缀。至此，转储结束。</p><p>从转储磁盘上还原文件系统非常简单。一开始，需要在磁盘上创建空文件系统。然后恢复最近一次的完整转储。由于磁带上最先出现目录，所以首先恢复目录，给出文件系统的<code>框架(skeleton)</code>，然后恢复文件系统本身。在完整存储之后是第一次增量存储，然后是第二次重复这一过程，以此类推。</p><p>尽管逻辑存储十分简单，但是也会有一些棘手的问题。首先，既然空闲块列表并不是一个文件，那么在所有被转储的文件恢复完毕之后，就需要从零开始重新构造。</p><p>另外一个问题是关于<code>链接</code>。如果文件链接了两个或者多个目录，而文件只能还原一次，那么并且所有指向该文件的目录都必须还原。</p><p>还有一个问题是，UNIX 文件实际上包含了许多<code>空洞(holes)</code>。打开文件，写几个字节，然后找到文件中偏移了一定距离的地址，又写入更多的字节，这么做是合法的。但两者之间的这些块并不属于文件本身，从而也不应该在其上进行文件转储和恢复。</p><p>最后，无论属于哪一个目录，<strong>特殊文件，命名管道以及类似的文件</strong>都不应该被转储。</p><h3 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h3><p>影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p><p>为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有<code>fsck</code>；Windows有<code>sfc</code>，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</p><p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p><p>然后检验程序使用原始设备读取所有的 inode，忽略文件的结构，只返回从零开始的所有磁盘块。从 inode 开始，很容易找到文件中的块数量。每当读取一个块时，该块在第一个表中的计数器 + 1，应用程序会检查空闲块或者位图来找到没有使用的块。空闲列表中块的每次出现都会导致其在第二表中的计数器增加。</p><p>如果文件系统一致，则每一个块或者在第一个表计数器为 1，或者在第二个表计数器中为 1，如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331160347.png"></fancybox><p>但是当系统崩溃后，这两张表可能如下所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331160510.png"></fancybox><p>其中，磁盘块 2 没有出现在任何一张表中，这称为<code>块丢失(missing block)</code>。尽管块丢失不会造成实际的损害，但它的确浪费了磁盘空间，减少了磁盘容量。块丢失的问题很容易解决，文件系统检验程序把他们加到空闲表中即可。</p><p>有可能出现的另外一种情况如下所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331160726.png"></fancybox><p>其中，块 4 在空闲表中出现了 2 次。这种解决方法也很简单，只要重新建立空闲表即可。</p><p>最糟糕的情况是在两个或者多个文件中出现同一个数据块，如下所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331160842.png"></fancybox><p>比如上图的磁盘块 5，如果其中一个文件被删除，块 5 会被添加到空闲表中，导致一个块同时处于使用和空闲的两种状态。如果删除这两个文件，那么在空闲表中这个磁盘块会出现两次。</p><p>文件系统检验程序采取的处理方法是，先分配一磁盘块，把块 5 中的内容复制到空闲块中，然后把它插入到其中一个文件中。这样文件的内容未改变，虽然这些内容可以肯定是不对的，但至少保证了文件的一致性。这一错误应该报告给用户，由用户检查受检情况。</p><p>除了检查每个磁盘块计数的正确性之外，文件系统还会检查目录系统。这时候会用到一张<code>计数器表</code>，但这时是一个文件（而不是一个块）对应于一个计数器。程序从根目录开始检验，沿着目录树向下查找，检查文件系统的每个目录。对每个目录中的文件，使其计数 + 1。</p><blockquote><p>注意，由于存在硬连接，一个文件可能出现在两个或多个目录中。而遇到符号链接是不计数的，不会对目标文件的计数器 + 1。</p></blockquote><p>在检验程序完成后，会得到一张由 inode 索引的表，说明每个文件和目录的包含关系。检验程序会将这些数字与存储在文件 inode 中的链接数目做对比。如果 inode 节点的链接计数大户目录项个数，这时即使所有文件从目录中删除，这个计数仍然不是 0 ，inode 不会被删除。这种错误不严重，却因为存在不属于任何目录的文件而浪费了磁盘空间。</p><p>另一种错误则是潜在的风险。如果同一个文件链接两个目录项，但是 inode 链接计数只为 1，如果删除了任何一个目录项，对应 inode 链接计数变为 0。当 inode 计数为 0 时，文件系统标志 inode 为<code>未使用</code>，并释放全部的块。这会导致其中一个目录指向一未使用的 inode，而很有可能其块马上就被分配给其他文件。</p><h3 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h3><p>访问磁盘的效率要比内存慢的多，是时候又祭出这张图了</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331161658.png"></fancybox><p>从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>最常用的减少磁盘访问次数的技术是使用<code>块高速缓存(block cache)</code>或者<code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p><p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p><p>高速缓存的操作如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331162001.png"></fancybox><p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p><p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似，所有常用的页面置换算法我们之前已经介绍过，如果有不熟悉的小伙伴可以参考 <a href="https://mp.weixin.qq.com/s/5-k2BJDgEp9symxcSwoprw" target="_blank" rel="noopener">内存：你跑慢点行不行？CPU：跑慢点你养我吗？内存：我不管！</a> <strong>FIFO 算法、第二次机会算法、LRU 算法、时钟算法、老化算法等</strong>。它们都适用于高速缓存。</p><h4 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h4><p>第二个明显提高文件系统的性能是，在需要用到块之前，试图<code>提前</code>将其写入高速缓存，从而<code>提高命中率</code>。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p><p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p><h4 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h4><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p><p>不过，即使采用空闲表，也可以使用<code>块簇</code>技术。即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有 512 个字节，有可能系统采用 1 KB 的块（2 个扇区），但却按每 2 块（4 个扇区）一个单位来分配磁盘存储区。这和 2 KB 的磁盘块并不相同，因为在高速缓存中它仍然使用 1 KB 的块，磁盘与内存数据之间传送也是以 1 KB 进行，但在一个空闲的系统上顺序读取这些文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方法的变体。在分配块时，系统尽量把一个文件中的连续块存放在同一个柱面上。</p><p>在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：<strong>一次是访问 inode，一次是访问块</strong>。通常情况下，inode 的放置如下图所示</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200331162923.png"></fancybox><p>其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。</p><p>一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表，如上图 b 所示。</p><p>当然，只有在磁盘中装有磁盘臂的情况下，讨论寻道时间和旋转时间才是有意义的。现在越来越多的电脑使用<code>固态硬盘(SSD)</code>，对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问和顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。但是也引发了新的问题。</p><h4 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h4><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p><p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序<code>defrag</code>就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p><p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p><br><blockquote><p>相关参考：</p><p><a href="https://zhuanlan.zhihu.com/p/41358013" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41358013</a><br><a href="https://www.linuxtoday.com/blog/what-is-an-inode.html" target="_blank" rel="noopener">what-is-an-inode</a><br><a href="https://www.lifewire.com/what-is-fragmentation-defragmentation-2625884" target="_blank" rel="noopener">what-is-fragmentation-defragmentation</a><br><a href="https://www.geeksforgeeks.org/free-space-management-in-operating-system/" target="_blank" rel="noopener">free-space-management-in-operating-system</a><br>…<br>原文链接<br><a href="https://juejin.im/post/5e7aea03f265da57616abd46" target="_blank" rel="noopener">https://juejin.im/post/5e7aea03f265da57616abd46</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何请教别人</title>
      <link href="/blog/2020-03-22-how-to-get-help/"/>
      <url>/blog/2020-03-22-how-to-get-help/</url>
      
        <content type="html"><![CDATA[<h2 id="合适的自我介绍"><a href="#合适的自我介绍" class="headerlink" title="合适的自我介绍"></a>合适的自我介绍</h2><p>上次有一个人在一个线下分享会后一直拉着我问问题，我一直忍着没有问他是谁，后来问了太多，我实在受不了了，我问他：你是谁呀，为什么好像和我很熟的样子？他说：哦，我是一个 iOS 开发，你没必要记住我的名字。</p><p>类似的情形出现过多次，还有一些人把名字故意取成很个性的，完全无法记住的 emoji 表情或者符号，也不做自我介绍，我完全无法记住这些人。</p><p>合适的自我介绍为什么重要呢？因为它代表着一种尊重和平等。我义务解答问题没有关系，但是我即使完全不求回报，也希望我到底帮助的是谁。这个提问者的名字，毕业学校，工作单位，以及他的问题，都会给我带来记忆。</p><p>这其实是基本的礼仪，看看那些著名演讲或者发布会的提问环节吧，提问者都会先自我介绍一番。</p><a id="more"></a><h2 id="在吗？"><a href="#在吗？" class="headerlink" title="在吗？"></a>在吗？</h2><p>「在吗」，基本上以这种方式和我打招呼的提问者，通常都是令我感受非常差的。因为这意味着：我看到了必须回答在，我回答在了之后，还必须立即响应他后续的问题。</p><p>同学们，现在连 QQ 都取消在线状态了，有什么事情不能用留言的方式解决呢？说白了，还不是提问者自我为中心，他们希望偷懒，连在请教别人这件事情上，他们都希望不要浪费自己的打字 —- 如果对方不在，我就可以不用打字提问题了，免得提了别人不答。</p><p>但是，如果你这么不尊重对方的时间，又何来让对方免费的、在线互动地和你一问一答帮助你解决你的问题？</p><p>凭什么？</p><h2 id="不会提问"><a href="#不会提问" class="headerlink" title="不会提问"></a>不会提问</h2><p>很多人都描述不清楚自己的问题，需要我来帮助他们一点点来弄清楚他到底想问什么。我举一个例子：</p><p>上次一个人在群里面问：有谁知道怎么更新 Mac 的 Numbers 吗？我以为他是一个 Mac 新手，于是我说：打开 Mac 的 App Store 应用，在 Updates 里面找到 Numbers，然后点 “update” 按钮。</p><p>结果他说：我知道，但是我为什么点了没有反应呢？我这个时候才发现，他其实是想问为什么 App Store 响应慢。于是我推荐他设置了一些加速下载的 DNS。</p><p>因为这个人我认识，所以我继续在帮助他。但是其实他给了我相当糟糕的体验。因为我在帮助他的时候，我在努力把解决方案说清楚，但是他懒得连问题都不想说清楚。或者，他认为只要他说「不会更新某个应用」，就表示的是 AppStore 卡顿，而不是别的意思。</p><h2 id="提傻问题"><a href="#提傻问题" class="headerlink" title="提傻问题"></a>提傻问题</h2><p>对于 iOS 开发者来说，向我提的最傻的两类问题是：审核问题和具体的 API 问题。</p><p>例如：</p><blockquote><p>唐老师，麻烦看看：<br>Your app uses public APIs in an unapproved manner, which does not comply with section 3.3.1 of the Apple Developer Program License Agreement.</p><p>Specifically, your app was found to use “canOpenURL:” to scan for an arbitrarily large list of apps. Use of this method for generalized app detection is not appropriate.</p><p>Since there is no accurate way of predicting how an API may be modified and what effects those modifications may have, Apple does not permit unapproved uses of public APIs in App Store apps.</p></blockquote><p>审核的问题大部分情况下英文的审核意见已经说得非常清楚了，我实在没有什么动力做翻译。</p><p>另外如果是问 iOS 开发某个特定细节 API 的使用问题，其实是没有哪个人能够对苹果的所有 API 都了解得那么清楚的，与其问我，还不如用 Google 搜索或者查文档更好。</p><h2 id="扔代码"><a href="#扔代码" class="headerlink" title="扔代码"></a>扔代码</h2><p>上来就扔一段代码，然后说：照着你的博客写的，为什么出问题了呢？好象我写了免费的博客，就有义务帮他找 Bug 一样。</p><p>当然，扔代码的还算好的，还有扔过来一个 GitHub 工程的，说：「麻烦帮忙看看」，这真的是要让我吐血。。。</p><h2 id="情绪方面的问题"><a href="#情绪方面的问题" class="headerlink" title="情绪方面的问题"></a>情绪方面的问题</h2><p>巧哥，我 iOS 找不到工作怎么办？</p><p>巧哥，我希望从 xx 方向换到 iOS 方向，你怎么看？</p><p>巧哥，我的老大对我很差，你说我应不应该换一份工作？</p><p>大部分这些问题，我其实也只能说：努力努力再努力，或者选择沉默。因为我确实也帮不上什么忙。如果需要找人安抚心情的话，找好朋友可能更适合。</p><h2 id="不会感谢"><a href="#不会感谢" class="headerlink" title="不会感谢"></a>不会感谢</h2><p>说句谢谢是最最基本的。</p><p>如果你的问题花费了别人大量的时间，例如几个小时或者一天，那么请别人吃个饭也是正常的。大家都是成年人，倒不是说要多功利，这仅是相互的尊重。</p><p>我现在如果有很困扰的问题要请教别人，简单几句能说清楚的，我会给别人微信留言说清楚，然后附一个 66 元的红包。简单几句说不清楚的，我会和别人约个时间当面请教，然后顺便请别人吃顿饭。外地的朋友，实在不知道如何感谢，我会说：希望以后如果需要我的时候，能够找我提供帮助。</p><h2 id="我的困境"><a href="#我的困境" class="headerlink" title="我的困境"></a>我的困境</h2><p>最后分享一下我的困境。</p><p>我每天收到几十个求助的问题，但是我精力非常有限，对于我来说时间优先级肯定是：首先完成工作上的事情、然后完成家里的事情、然后是娱乐和学习、然后是和朋友聊天交流、然后是休息，如果上面这些做完了，偶尔有精力，正好遇上了会提问，提的问题又是经过深入思考，而恰好我又知道答案，答案又恰好不会花费特别多的时间，那么我才有可能回答。</p><p>当然，如果是朋友的问题，我会把这个看作我处理社交关系的一件事情，那我可能就会放弃一些休息或学习时间来帮助朋友，因为或许有一天我也会需要朋友的帮助，同时朋友的成功也会给我带来开心。</p><p>希望这篇文章能够教会大家这个简单的「换位思考」法则。</p><p>谢谢。</p><br><blockquote><p>原文链接：<a href="http://blog.devtang.com/2017/03/04/how-to-get-help" target="_blank" rel="noopener">http://blog.devtang.com/2017/03/04/how-to-get-help</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 iOS 的内存管理</title>
      <link href="/blog/2020-03-22-ios-memory-management/"/>
      <url>/blog/2020-03-22-ios-memory-management/</url>
      
        <content type="html"><![CDATA[<h2 id="远古时代的故事"><a href="#远古时代的故事" class="headerlink" title="远古时代的故事"></a>远古时代的故事</h2><p>那些经历过手工管理内存（MRC）时代的人们，一定对 iOS 开发中的内存管理记忆犹新。那个时候大约是 2010 年，国内 iOS 开发刚刚兴起，tinyfool 大叔的大名已经如雷贯耳，而我还是一个默默无闻的刚毕业的小子。那个时候的 iOS 开发过程是这样的：</p><blockquote><p>我们先写好一段 iOS 的代码，然后屏住呼吸，开始运行它，不出所料，它崩溃了。在 MRC 时代，即使是最牛逼的 iOS 开发者，也不能保证一次性就写出完美的内存管理代码。于是，我们开始一步一步调试，试着打印出每个怀疑对象的引用计数（Retain Count），然后，我们小心翼翼地插入合理的 retain 和 release 代码。经过一次又一次的应用崩溃和调试，终于有一次，应用能够正常运行了！于是我们长舒一口气，露出久违的微笑。</p></blockquote><a id="more"></a><p>是的，这就是那个年代的 iOS 开发者，通常情况下，我们在开发完一个功能后，需要再花好几个小时，才能把引用计数管理好。</p><p>苹果在 2011 年的时候，在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。</p><p>在 ARC 刚刚出来的时候，业界对此黑科技充满了怀疑和观望，加上现有的 MRC 代码要做迁移本来也需要额外的成本，所以 ARC 并没有被很快接受。直到 2013 年左右，苹果认为 ARC 技术足够成熟，直接将 macOS（当时叫 OS X）上的垃圾回收机制废弃，从而使得 ARC 迅速被接受。</p><p>2014 年的 WWDC 大会上，苹果推出了 Swift 语言，而该语言仍然使用 ARC 技术，作为其<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" target="_blank" rel="noopener">内存管理方式</a>。</p><p>为什么我要提这段历史呢？就是因为现在的 iOS 开发者实在太舒服了，大部分时候，他们根本都不用关心程序的内存管理行为。但是，<b>虽然 ARC 帮我们解决了引用计数的大部分问题，一些年轻的 iOS 开发者仍然会做不好内存管理工作</b>。他们甚至不能理解常见的循环引用问题，而这些问题会导致内存泄漏，最终使得应用运行缓慢或者被系统终止进程。</p><p>所以，我们每一个 iOS 开发者，需要理解引用计数这种内存管理方式，只有这样，才能处理好内存管理相关的问题。</p><h2 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h2><p>引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 和 Swift 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322125616.png"></fancybox><p>为了更形象一些，我们再来看一段 Objective-C 的代码。新建一个工程，因为现在默认的工程都开启了自动的引用计数 ARC（Automatic Reference Count)，我们先修改工程设置，给 AppDelegate.m 加上 <code>-fno-objc-arc</code> 的编译参数（如下图所示），这个参数可以启用手工管理引用计数的模式。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322130038.png"></fancybox><p>然后，我们在中输入如下代码，可以通过 Log 看到相应的引用计数的变化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </span><br><span class="line">       didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    <span class="built_in">NSObject</span> *another = [object <span class="keyword">retain</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [another release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="comment">// 到这里时，object 的内存被释放了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reference Count &#x3D; 1</span><br><span class="line">Reference Count &#x3D; 2</span><br><span class="line">Reference Count &#x3D; 1</span><br></pre></td></tr></table></figure><p>对 Linux 文件系统比较了解的同学可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 <code>ln</code> 命令可以创建一个硬链接（相当于我们这里的 retain)，当删除一个文件时（相当于我们这里的 release)，系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。</p><h2 id="我们为什么需要引用计数"><a href="#我们为什么需要引用计数" class="headerlink" title="我们为什么需要引用计数"></a>我们为什么需要引用计数</h2><p>从上面那个简单的例子中，我们还看不出来引用计数真正的用处。因为该对象的生命期只是在一个函数内，所以在真实的应用场景下，我们在函数内使用一个临时的对象，通常是不需要修改它的引用计数的，只需要在函数返回前将该对象销毁即可。</p><p>引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。我们举一个具体的例子：</p><p>假如对象 A 生成了一个对象 M，需要调用对象 B 的某一个方法，将对象 M 作为参数传递过去。在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么对象 A 就需要在对象 B 不再需要对象 M 的时候，将对象 M 销毁。但对象 B 可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322142243.png"></fancybox><p>对于这种情况，有一个暴力的做法，就是对象 A 在调用完对象 B 之后，马上就销毁参数对象 M，然后对象 B 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。如下图所示：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322142501.png"></fancybox><p>我们另外还有一种办法，就是对象 A 在构造完对象 M 之后，始终不销毁对象 M，由对象 B 来完成对象 M 的销毁工作。如果对象 B 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 AB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在对象 A 中，释放在对象 B 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象 B 需要再向对象 C 传递对象 M，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322142627.png"></fancybox><p>所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。</p><h2 id="不要向已经释放的对象发送消息"><a href="#不要向已经释放的对象发送消息" class="headerlink" title="不要向已经释放的对象发送消息"></a>不要向已经释放的对象发送消息</h2><p>有些同学想测试当对象释放时，其 <code>retainCount</code> 是否变成了 0，他们的试验代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果你真的这么实验，你得到的输出结果可能是以下这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference Count &#x3D; 1</span><br><span class="line">Reference Count &#x3D; 1</span><br></pre></td></tr></table></figure><p>我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。</p><p>那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。</p><p>拿我们之前提到的 Linux 文件系统举列，Linux 文件系统下删除一个文件，也不是真正的将文件的磁盘区域进行抹除操作，而只是删除该文件的索引节点号。这也和引用计数的内存回收方式类似，即回收时只做标记，并不抹除相关的数据。</p><h2 id="ARC-下的内存管理问题"><a href="#ARC-下的内存管理问题" class="headerlink" title="ARC 下的内存管理问题"></a>ARC 下的内存管理问题</h2><p>ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外还有 10% 内存管理，是需要开发者自己处理的，这主要就是与底层 Core Foundation 对象交互的那部分，底层的 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。</p><p>对于 ARC 盲目依赖的 iOS 新人们，由于不知道引用计数，他们的问题主要体现在：</p><ol><li>过度使用 block 之后，无法解决循环引用问题。</li><li>遇到底层 Core Foundation 对象，需要自己手工管理它们的引用计数时，显得一筹莫展。</li></ol><h3 id="循环引用（Reference-Cycle）问题"><a href="#循环引用（Reference-Cycle）问题" class="headerlink" title="循环引用（Reference Cycle）问题"></a>循环引用（Reference Cycle）问题</h3><p>引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322152810.png"></fancybox><p>不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322152912.png"></fancybox><h3 id="主动断开循环引用"><a href="#主动断开循环引用" class="headerlink" title="主动断开循环引用"></a>主动断开循环引用</h3><p>解决循环引用问题主要有两个办法，第一个办法是我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322153107.png"></fancybox><p>主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。例如在我开源的 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a> 网络库中，网络请求的回调 block 是被持有的，但是如果这个 block 中又存在对于 View Controller 的引用，就很容易产生从循环引用，因为：</p><ul><li>Controller 持有了网络请求对象</li><li>网络请求对象持有了回调的 block</li><li>回调的 block 里面使用了 <code>self</code>，所以持有了 Controller</li></ul><p>解决办法就是，在网络请求结束后，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。相关的代码见：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKBaseRequest.m</span></span><br><span class="line"><span class="comment">// 第 147 行：</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</span><br><span class="line">    <span class="comment">// 主动释放掉对于 block 的引用</span></span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存（这通常与具体的业务逻辑相关），所以这种解决方法并不常用，更常见的办法是使用弱引用 (weak reference) 的办法。</p><h3 id="使用弱引用"><a href="#使用弱引用" class="headerlink" title="使用弱引用"></a>使用弱引用</h3><p>弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。举个例子来说，两个 ViewController A 和 B，ViewController A 需要弹出 ViewController B，让用户输入一些内容，当用户输入完成后，ViewController B 需要将内容返回给 ViewController A。这个时候，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 相互引用对方造成循环引用问题，如下所示：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322153527.png"></fancybox><h3 id="弱引用的实现原理"><a href="#弱引用的实现原理" class="headerlink" title="弱引用的实现原理"></a>弱引用的实现原理</h3><p>弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。</p><p>从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为：</p><ol><li>我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。</li><li>大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。</li><li>早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见<a href="http://blog.devtang.com/2013/05/18/goodbye-viewdidunload" target="_blank" rel="noopener">《再见，viewDidUnload方法》</a>。</li></ol><h3 id="使用-Xcode-检测循环引用"><a href="#使用-Xcode-检测循环引用" class="headerlink" title="使用 Xcode 检测循环引用"></a>使用 Xcode 检测循环引用</h3><p>Xcode 的 Instruments 工具集可以很方便的检测循环引用。为了测试效果，我们在一个测试用的 ViewController 中填入以下代码，该代码中的 firstArray 和 secondArray 相互引用了对方，构成了循环引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *firstArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *secondArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [firstArray addObject:secondArray];</span><br><span class="line">    [secondArray addObject:firstArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。如下图</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322153911.jpg"></fancybox><p>这个时候 iOS 模拟器会运行起来，我们在模拟器里进行一些界面的切换操作。稍等几秒钟，就可以看到 Instruments 检测到了我们的这次循环引用。Instruments 中会用一条红色的条来表示一次内存泄漏的产生。如下图所示：</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322154006.jpg"></fancybox><p>我们可以切换到 Leaks 这栏，点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。这样我们就可以非常方便地找到循环引用的对象了。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322154057.png"></fancybox><h3 id="Core-Foundation-对象的内存管理"><a href="#Core-Foundation-对象的内存管理" class="headerlink" title="Core Foundation 对象的内存管理"></a>Core Foundation 对象的内存管理</h3><p>下面我们就来简单介绍一下对底层 Core Foundation 对象的内存管理。底层的 Core Foundation 对象，在创建时大多以 XxxCreateWithXxx 这样的方式创建，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 CFStringRef 对象</span></span><br><span class="line"><span class="built_in">CFStringRef</span> str= <span class="built_in">CFStringCreateWithCString</span>(kCFAllocatorDefault, “hello world<span class="string">", kCFStringEncodingUTF8);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 创建一个 CTFontRef 对象</span></span><br><span class="line"><span class="string">CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@"</span>ArialMT<span class="string">", fontSize, NULL);</span></span><br></pre></td></tr></table></figure><p>对于这些对象的引用计数的修改，要相应的使用 <code>CFRetain</code> 和 <code>CFRelease</code> 方法。如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 CTFontRef 对象</span></span><br><span class="line"><span class="built_in">CTFontRef</span> fontRef = <span class="built_in">CTFontCreateWithName</span>((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数加 1</span></span><br><span class="line"><span class="built_in">CFRetain</span>(fontRef);</span><br><span class="line"><span class="comment">// 引用计数减 1</span></span><br><span class="line"><span class="built_in">CFRelease</span>(fontRef);</span><br></pre></td></tr></table></figure><p>对于 <code>CFRetain</code> 和 <code>CFRelease</code> 两个方法，读者可以直观地认为，这与 Objective-C 对象的 <code>retain</code> 和 <code>release</code> 方法等价。</p><p>所以对于底层 Core Foundation 对象，我们只需要延续以前手工管理引用计数的办法即可。</p><p>除此之外，还有另外一个问题需要解决。在 ARC 下，我们有时需要将一个 Core Foundation 对象转换成一个 Objective-C 对象，这个时候我们需要告诉编译器，转换过程中的引用计数需要做如何的调整。这就引入了 <code>bridge</code> 相关的关键字，以下是这些关键字的说明：</p><ul><li><code>__bridge</code>: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</li><li><code>__bridge_retained</code>：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</li><li><code>__bridge_transfer</code>：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法。</li></ul><p>我们根据具体的业务逻辑，合理使用上面的 3 种转换关键字，就可以解决 Core Foundation 对象与 Objective-C 对象相对转换的问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 ARC 的帮助下，iOS 开发者的内存管理工作已经被大大减轻，但是我们仍然需要理解引用计数这种内存管理方式的优点和常见问题，特别要注意解决循环引用问题。对于循环引用问题有两种主要的解决办法，一是主动断开循环引用，二是使用弱引用的方式避免循环引用。对于 Core Foundation 对象，由于不在 ARC 管理之下，我们仍然需要延续以前手工管理引用计数的办法。</p><p>在调试内存问题时，Instruments 工具可以很好地对我们进行辅助，善用 Instruments 可以节省我们大量的调试时间。</p><p>愿每一个 iOS 开发者都可以掌握 iOS 的内存管理技能。</p><br><blockquote><p>原文链接：<a href="http://blog.devtang.com/2016/07/30/ios-memory-management" target="_blank" rel="noopener">http://blog.devtang.com/2016/07/30/ios-memory-management</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为码农，我们为什么要写作</title>
      <link href="/blog/2020-03-21-why-we-need-write/"/>
      <url>/blog/2020-03-21-why-we-need-write/</url>
      
        <content type="html"><![CDATA[<p>在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。</p><p>不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。</p><a id="more"></a><h2 id="提高自己对知识的掌握层次"><a href="#提高自己对知识的掌握层次" class="headerlink" title="提高自己对知识的掌握层次"></a>提高自己对知识的掌握层次</h2><p>美国教育心理学家 <a href="http://zh.wikipedia.org/wiki/%E6%9C%AC%E5%82%91%E6%98%8E%C2%B7%E5%B8%83%E9%AD%AF%E5%A7%86" target="_blank" rel="noopener">Bloom</a> 将知识认知分为了两个维度，其中认知历程维度又分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。</p><fancybox><img src="https://cdn.jsdelivr.net/gh/voiue/cdn-img/img/20200322113417.png"></fancybox><p>对于写作者来说，在写作过程中，因为需要对知识进行精确地表述，常常要对知识的细节再次的探索。在这个过程中，写作者可能会发现自己的观点不清晰的地方，通过二次学习，使自己的理解更加完善。写作者也可能会发现自己观点中的错误，从而改正自己的曲解。在经历过这段过程后，通常对于自己所写的知识的掌握程度，都上升了一个层次。</p><p>我自己的每次技术写作都经历了这样的提高过程。所以，我更多时候是把写作当成学习的一种方式。这种学习方式比普通的学习方式更加深入，效果更好。当然，花费的时间也更多。</p><h2 id="提高表达和沟通的能力"><a href="#提高表达和沟通的能力" class="headerlink" title="提高表达和沟通的能力"></a>提高表达和沟通的能力</h2><p>作为一个程序员，日常的工作大部分时间都是面对电脑。许多人周末也喜欢当一个技术宅，待在家里上网、看电影或者玩游戏来消遣。长时间的面对机器，使得我们的语言表达能力极度衰退。而写作是一个很好的机会，让我们练习自己的表达能力。</p><p>长时间写作之后，你会更加注意平时沟通的语言。你的用词更加精准，表达更加生动。在表达能力提高的同时，你的沟通效率也得到提高。</p><h2 id="接受读者的沟通和反馈"><a href="#接受读者的沟通和反馈" class="headerlink" title="接受读者的沟通和反馈"></a>接受读者的沟通和反馈</h2><p>当你的文章通过博客或者 InfoQ 网站发表出来后，你就会接着获得写作的第三个好处：来自读者的沟通和反馈。一篇好的文章通常会吸引一些读者回复，通过和读者的交流，你可以收获以下好处：<br>1 错误内容反馈：尽管文章在写作时经历过二次学习，但是人难免会犯错。写作将你的思想完全暴露出来，有水平的读者可以指出你文章中的错误，从而使你对知识的理解更加准确。我的很多博客文章都有一些细微错误，通过读者的找反馈，我很快就将错误内容改正过来了，自己的水平也得到了提高。</p><p>2 认识朋友：一个乐于分享的人总会比沉默寡言的人更招人喜欢。所以通过写作，你可以结交很多和你一样，乐于分享的朋友。</p><p>3 了解更多相关信息：一些读者会回复说：” 某某框架也用了这个技术方案 “，或者是：” 你的这个实现方案没有另一个某某开源方案好 “。这些信息，作为你当前文章知识点的补充，使你能够了解更多相关的资料，再一次完善自己所学的知识。</p><h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2><p>当你持续的写作，坚持一年以上，你就会慢慢收获影响力。这个时候，你也会收到技术大会的分享邀请，出版社的约稿邀请，著名互联网公司的工作邀请，甚至是创业项目的合伙人邀请。你相比那些不分享的人，获得了更多的机会。当然你的技术观点也会被更多人接受，你也会收获到传递知识的乐趣。</p><p>#结束语</p><p>在写作过程中，你将收获提高自己对知识的掌握层次和提高表达和沟通的能力的好处。</p><p>在写作结束后，你将收获错误内容反馈、认识朋友和了解更多相关信息的好处。</p><p>在坚持写作一段时间，你将收获影响力和传递知识的乐趣。</p><p>另外，<a href="http://book.douban.com/subject/6709809/" target="_blank" rel="noopener">《暗时间》</a> 的作者刘未鹏在 <a href="http://blog.csdn.net/pongba/article/details/3896311" target="_blank" rel="noopener">他的文章</a>，也总结了很多写作的好处，大家也可以看看。</p><p>看了写作的这么多好处，你是否心动？那赶快创建一个博客，开始你的技术写作之旅吧！</p><br><blockquote><p>原文链接：<a href="http://blog.devtang.com/2014/01/08/why-we-need-write/" target="_blank" rel="noopener">http://blog.devtang.com/2014/01/08/why-we-need-write</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解inode</title>
      <link href="/blog/2020-03-15-inode/"/>
      <url>/blog/2020-03-15-inode/</url>
      
        <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Inode" target="_blank" rel="noopener">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p>下面就是我的inode学习笔记，尽量保持简单。</p><a id="more"></a><h1 id="理解inode"><a href="#理解inode" class="headerlink" title="理解inode"></a>理解inode</h1><h2 id="一、inode是什么？"><a href="#一、inode是什么？" class="headerlink" title="一、inode是什么？"></a>一、inode是什么？</h2><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2 id="二、inode的内容"><a href="#二、inode的内容" class="headerlink" title="二、inode的内容"></a>二、inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li>文件的字节数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li><li>链接数，即有多少文件名指向这个inode</li><li>文件数据block的位置</li></ul><p>可以用stat命令，查看某个文件的inode信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat example.txt</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120402.png"></fancybox><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h2 id="三、inode的大小"><a href="#三、inode的大小" class="headerlink" title="三、inode的大小"></a>三、inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120403.png"></fancybox><p>查看每个inode节点的大小，可以用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep &quot;Inode size&quot;</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120404.png"></fancybox><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h2 id="四、inode号码"><a href="#四、inode号码" class="headerlink" title="四、inode号码"></a>四、inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -i example.txt</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120405.png"></fancybox><h2 id="五、目录文件"><a href="#五、目录文件" class="headerlink" title="五、目录文件"></a>五、目录文件</h2><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>ls命令只列出目录文件中的所有文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;etc</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120406.png"></fancybox><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -i &#x2F;etc</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120407.png"></fancybox><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120408.png"></fancybox><p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p><h2 id="六、硬链接"><a href="#六、硬链接" class="headerlink" title="六、硬链接"></a>六、硬链接</h2><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p><p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p>ln命令可以创建硬链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 源文件 目标文件</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120409.png"></fancybox><p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p><p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p><h2 id="七、软链接"><a href="#七、软链接" class="headerlink" title="七、软链接"></a>七、软链接</h2><p>除了硬链接以外，还有一种特殊情况。</p><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p><p>ln -s命令可以创建软链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><fancybox><img src="/img/bg2011120410.png"></fancybox><h2 id="八、inode的特殊作用"><a href="#八、inode的特殊作用" class="headerlink" title="八、inode的特殊作用"></a>八、inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p><p>　　1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p><p>　　2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</p><p>　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</p><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><p>（完）</p><br><blockquote><p>原文链接：<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 磁盘 </tag>
            
            <tag> inode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 Git 命令清单</title>
      <link href="/blog/2020-03-13-git-cheat-sheet/"/>
      <url>/blog/2020-03-13-git-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p>我每天使用 Git ，但是很多命令记不住。</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><fancybox><img src="/img/bg2015120901.png"></fancybox><a id="more"></a><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<red>.gitconfig</red>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><p>（完）</p><br><blockquote><p>原文链接：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客中加入Bili标签插件添加视频</title>
      <link href="/blog/2020-03-13-add-bili-vedio-with-tag-in-hexo/"/>
      <url>/blog/2020-03-13-add-bili-vedio-with-tag-in-hexo/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是上篇文章《Hexo博客中加入B站视频播放器》的第二种实现过程，使用新增hexo标签的形式来添加B站视频。使用起来更方便~</p><p>回顾下之前的实现过程代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;24897960&amp;cid&#x3D;42007693&amp;page&#x3D;3&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>两个视频见唯一不同就是iframe标签中src的?后面aid=24897960&amp;cid=42007693&amp;page=3这部分。所以我们可以把它封装成一个hexo tag标签插件。</p><p>有关于标签插件具体可以查看官方API文档<a href="https://hexo.io/zh-cn/api/tag" target="_blank" rel="noopener">标签Tag</a>。</p><h1 id="以下内容来自官方文档："><a href="#以下内容来自官方文档：" class="headerlink" title="以下内容来自官方文档："></a>以下内容来自官方文档：</h1><h2 id="标签插件（Tag）"><a href="#标签插件（Tag）" class="headerlink" title="标签插件（Tag）"></a>标签插件（Tag）</h2><p>标签插件帮助开发者在文章中快速插入内容。</p><p>概要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.tag.register(name, function(args, content)&#123;</span><br><span class="line">&#125;, options);</span><br></pre></td></tr></table></figure><p>标签函数会传入两个参数：args 和 content，前者代表开发者在使用标签插件时传入的参数，而后者则是标签插件所覆盖的内容。</p><h2 id="youtube视频栗子"><a href="#youtube视频栗子" class="headerlink" title="youtube视频栗子"></a>youtube视频栗子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.tag.register(&#39;youtube&#39;, function(args)&#123;</span><br><span class="line">  var id &#x3D; args[0];</span><br><span class="line">  return &#39;&lt;div class&#x3D;&quot;video-container&quot;&gt;&lt;iframe width&#x3D;&quot;560&quot; height&#x3D;&quot;315&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;&#39; + id + &#39;&quot; frameborder&#x3D;&quot;0&quot; allowfullscreen&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#39;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="youtube使用栗子"><a href="#youtube使用栗子" class="headerlink" title="youtube使用栗子"></a>youtube使用栗子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure><p>咳咳，看了以上内容应该已经大致了解，接下来开始实现。</p><h2 id="第一步-找到标签插件位置"><a href="#第一步-找到标签插件位置" class="headerlink" title="第一步 找到标签插件位置"></a>第一步 找到标签插件位置</h2><p>位置在<b>博客目录</b>\node_modules\hexo\lib\plugins\tag\下。<br>先看下index.js内容如下:</p><fancybox><img src="/img/006bYVyvly1fzsfvpxiplj30ji0gujtc.jpg"></fancybox><p>我们学着youtube在后面加个bilibili</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag.register(&#39;bili&#39;, require(&#39;.&#x2F;bili&#39;));</span><br></pre></td></tr></table></figure><h2 id="第二步-编写tag插件bili-js"><a href="#第二步-编写tag插件bili-js" class="headerlink" title="第二步 编写tag插件bili.js"></a>第二步 编写tag插件bili.js</h2><p>上一步我们注册了bili插件，但是还没有插件的js文件，可以看到他的require目录是./所以就在当前目录下（即tag目录下）新建bili.js文件，不理解./的童鞋可以搜索下绝对路径与相对路径的意思就懂了。</p><p>建好js文件后我们开始编写插件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Bilibili tag</span><br><span class="line">*</span><br><span class="line">* Syntax:</span><br><span class="line">*   &#123;% bili video_id %&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">function biliTag(args, content) &#123;</span><br><span class="line">  var id &#x3D; args[0];</span><br><span class="line"></span><br><span class="line">  return &#96;&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?$&#123;id&#125;&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; biliTag;</span><br></pre></td></tr></table></figure><h2 id="第三步-在md文章中使用"><a href="#第三步-在md文章中使用" class="headerlink" title="第三步 在md文章中使用"></a>第三步 在md文章中使用</h2><p>在文章中使用的语法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bili bili_id %&#125;</span><br></pre></td></tr></table></figure><p>其中bili_id为你从B站获取的iframe的src的id部分。比如分享的iframe代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;24897960&amp;cid&#x3D;42007944&amp;page&#x3D;1&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot;&gt; &lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure><p>bili_id就是aid=24897960&amp;cid=42007944&amp;page=1，使用语法就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bili aid&#x3D;24897960&amp;cid&#x3D;42007944&amp;page&#x3D;1 %&#125;</span><br></pre></td></tr></table></figure><p>在文章中加入以上标签就可以快速插入B站视频了。</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github常用命令</title>
      <link href="/blog/2020-03-11-github-common-command/"/>
      <url>/blog/2020-03-11-github-common-command/</url>
      
        <content type="html"><![CDATA[<h2 id="本地仓库推送至github"><a href="#本地仓库推送至github" class="headerlink" title="本地仓库推送至github"></a>本地仓库推送至github</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">  coding</span><br><span class="line">$ git add.</span><br><span class="line">$ git commit -m &quot;balabala&quot;</span><br><span class="line">  github上新建仓库（最好同名）复制链接</span><br><span class="line">$ git remote add origin + 你的链接</span><br><span class="line">$ git pull --rebase oring master</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="平时推送"><a href="#平时推送" class="headerlink" title="平时推送"></a>平时推送</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;balabala&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><h2 id="github仓库克隆到本地coding再推送"><a href="#github仓库克隆到本地coding再推送" class="headerlink" title="github仓库克隆到本地coding再推送"></a>github仓库克隆到本地coding再推送</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 仓库链接</span><br><span class="line">  coding</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;balabala&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><h2 id="PR（pull-request）"><a href="#PR（pull-request）" class="headerlink" title="PR（pull request）"></a>PR（pull request）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  github网页上fork源仓库</span><br><span class="line">$ git clone 自己fork的项目</span><br><span class="line">$ git remote add upstream 源仓库</span><br><span class="line">$ git remote -v</span><br><span class="line">$ git checkout -b 新的分支</span><br><span class="line">  change code</span><br><span class="line">$ git status</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;说明&quot;</span><br><span class="line">$ git push origin 分支名</span><br><span class="line">  github网页上提交pr(New pull request)</span><br></pre></td></tr></table></figure><br><blockquote><p>原文链接：<a href="https://www.hojun.cn/2018/03/24/ck70npt44000ue0tusk97bg40/" target="_blank" rel="noopener">https://www.hojun.cn/2018/03/24/ck70npt44000ue0tusk97bg40/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除github的release或tag</title>
      <link href="/blog/2020-03-10-delete-github-release-or-tag/"/>
      <url>/blog/2020-03-10-delete-github-release-or-tag/</url>
      
        <content type="html"><![CDATA[<p>如何删除或者说如何更新当前的release呢？今天刚开始学习利用jsDeliver搭建图床的时候就遇到这个问题。</p><p>刚开始的时候跟着网上的教程创建了一个cdn-wallpaper的仓库，也push了一张图片进去了，根据jsDeliver的引用链接成功的设置了博客的背景图片，但是后面发现这张图片的名字太长了，于是就把这张图片的名字删减了一部分，之后就重新提交到github仓库了，但是发现博客的背景却引用不了这个图片，通过网页调试发现引用的链接居然无效。</p><a id="more"></a><h2 id="更新release"><a href="#更新release" class="headerlink" title="更新release"></a>更新release</h2><p>回到cdn-wallpaper项目的主界面，点击release进去后，发现旁边有个edit按钮，于是就点击后就update release了，继续刷新博客，还是不能引用刚刚的图片。看来，这个release还是没有更新成功，于是索性直接把这个1.0版本的release删掉，之后重新再release一次，发现还是有问题。</p><h2 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h2><p>上面的删除操错虽然把release删除了，但是这个release对应的tag还没有删除，后来网上搜了一下，还真找到了解决办法。<br>要删除哪个版本的release就要点击对应的版本（我这里是1.0版本）。因为github的release是建立在tag上的，是对tag的一层封装。Git的tag只是一个标签，而github的release在tag的基础上还可以包含更多的打包文件，比如可执行文件等。因此，在github上，删除了release后，这个release对应的tag还存在，还要继续再删除一次，这个tag才会消失。</p><br><blockquote><p>参考链接：<a href="https://www.maixj.net/ict/release-tag-22821" target="_blank" rel="noopener">https://www.maixj.net/ict/release-tag-22821</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超级励志的视频</title>
      <link href="/blog/2020-03-10-ultra-inspirational/"/>
      <url>/blog/2020-03-10-ultra-inspirational/</url>
      
        <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1861309&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> video </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video </tag>
            
            <tag> 励志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用jsDeliver+github实现免费CDN</title>
      <link href="/blog/2020-03-10-free-cdn-with-jsdeliver-and-github/"/>
      <url>/blog/2020-03-10-free-cdn-with-jsdeliver-and-github/</url>
      
        <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><a id="more"></a><h2 id="jsDeliver"><a href="#jsDeliver" class="headerlink" title="jsDeliver"></a>jsDeliver</h2><p>jsDeliver是一个免费开源的CDN解决方案，用于帮助开发者和站长。包含JavaScript库、jQuery插件、CSS框架、字体等等Web上常用的静态资源。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>github是一个面向开源及私有软件项目托管平台，因为只支持git作为唯一的版本库格式进行托管，故名github</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><blockquote><p>jsDeliver不支持加载超过20M的资源，所以一些视频最好压缩到20M一下</p></blockquote><h3 id="1、新建github仓库并clone至本地"><a href="#1、新建github仓库并clone至本地" class="headerlink" title="1、新建github仓库并clone至本地"></a>1、新建github仓库并clone至本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 你的仓库链接 #本地克隆github仓库</span><br></pre></td></tr></table></figure><h3 id="2、将需要的静态资源放到本地git仓库中，并提交到github仓库"><a href="#2、将需要的静态资源放到本地git仓库中，并提交到github仓库" class="headerlink" title="2、将需要的静态资源放到本地git仓库中，并提交到github仓库"></a>2、将需要的静态资源放到本地git仓库中，并提交到github仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status                 #查看状态</span><br><span class="line">$ git add .                  #添加所有文件到暂存区</span><br><span class="line">$ git commit -m &#39;第一次提交&#39; #把文件提交到仓库，文字部分是备注信息说明</span><br><span class="line">$ git push                   #推送至远程仓库</span><br></pre></td></tr></table></figure><h3 id="3、在github仓库中点击release发布（版本号可以自定义）"><a href="#3、在github仓库中点击release发布（版本号可以自定义）" class="headerlink" title="3、在github仓库中点击release发布（版本号可以自定义）"></a>3、在github仓库中点击release发布（版本号可以自定义）</h3><h3 id="4、通过jsDeliver引用资源"><a href="#4、通过jsDeliver引用资源" class="headerlink" title="4、通过jsDeliver引用资源"></a>4、通过jsDeliver引用资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;你的用户名&#x2F;你的仓库名@发布的版本号&#x2F;文件路径</span><br><span class="line">&lt;green&gt;# 举个栗子&lt;&#x2F;green&gt;</span><br><span class="line">$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;voiue&#x2F;cdn-wallpaper@1.0&#x2F;abstract&#x2F;8782D9-08FE07-E5E73E.jpg #加载1.0版本</span><br><span class="line"></span><br><span class="line">&lt;green&gt;# 注意：如果不加 @发布的版本号 默认加载最新版本&lt;&#x2F;green&gt;</span><br><span class="line">&lt;green&gt;# 举个栗子&lt;&#x2F;green&gt;</span><br><span class="line">$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;voiue&#x2F;cdn-wallpaper&#x2F;abstract&#x2F;8782D9-08FE07-E5E73E.jpg # 加载最新版本</span><br></pre></td></tr></table></figure><br><blockquote><p>参考链接：<a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/" target="_blank" rel="noopener">https://www.itrhx.com/2019/02/10/A18-free-cdn/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/fofade/p/11380935.html" target="_blank" rel="noopener">https://www.cnblogs.com/fofade/p/11380935.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> CDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsDeliver </tag>
            
            <tag> github </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows虚拟内存-折腾</title>
      <link href="/blog/2020-03-09-virtual-memory/"/>
      <url>/blog/2020-03-09-virtual-memory/</url>
      
        <content type="html"><![CDATA[<p>由于自己电脑之前是机械硬盘的，读写速度太慢了，后来就买了个120G的固态硬盘给扩展了，机械硬盘就用来存资料文档啥的，固态硬盘就被我分成40G的用作系统（C）盘，剩下的用作软件安装（D）盘。</p><p>对操作系统有些了解的人应该听说过<a href="https://baike.baidu.com/item/虚拟内存" target="_blank" rel="noopener">虚拟内存</a>的概念，这里也不做过多的解释。虚拟内存默认是有系统自动托管的，对应着windows系统磁盘根目录下的pagefiles.sys文件，但是随着用户的慢慢使用，这个pagefiles.sys文件会越来越大，直到有一天，我发现C盘和D盘都红了，我才意识到了——该折腾了。</p><a id="more"></a><h2 id="开始折腾"><a href="#开始折腾" class="headerlink" title="开始折腾"></a>开始折腾</h2><p>于是开始找原因，到磁盘里面一个个文件夹看属性，看占多大空间，可是不管怎样还是凭空少了20多G的空间没了，于是心想，肯定是操作系统给隐藏起来了，接着就用组合键<kbd>WIN</kbd> + <kbd>R</kbd> ，输入cmd打开命令行，输入D:回车将路径切换到D盘根目录下，然后输入命令dir /a，果不其然居然有一个20多G的pagefiles.sys文件，于是想把它删掉，却发现怎么也删不掉，来回的折腾，对于经常折腾系统的我来说，删掉这个文件也很容易，于是拿出之前制作好的U盘启动盘（就是可以用来重装系统的那种），开机从U盘启动，然后就把那个pagefiles.sys文件删除了，D盘的20多G的空间瞬间又回来了，心里乐呵呵的。</p><h2 id="然并卵"><a href="#然并卵" class="headerlink" title="然并卵"></a>然并卵</h2><p>重新开机后发现磁盘也不再是红色的啦，可是用着没多长时间发现磁盘又变红了，输入上面的命令，又产生了那个文件，心里那个失望啊(T_T)，这可不是办法啊，每次删掉都会重新生成这么大的文件，太麻烦了，终于今天又产生了这个文件，这次居然直接系统卡死了，这不能忍啊，于是又开始网上找原因，说是可以手动修改虚拟内存的大小，也就是不让系统来托管，网上的都是建议虚拟内存设置的是物理内存的2倍，我电脑内存是8G，也就是要设置成16G，那相比20多G的也少不了多少啊，于是就打算将虚拟内存设置成8G大小，具体设置方法，先用组合键<kbd>WIN</kbd> + <kbd>Pause</kbd> ,打开系统属性，然后“高级”—&gt;“性能”里面的“设置”—&gt;再选“高级”—&gt;“虚拟内存”里面的“更改”—&gt;将第一行的“自动管理所有驱动器的文件大小”前面的☑去掉，然后选择要手动设置虚拟内存的磁盘，勾选☑自定义大小，因为是8G的内存，所以我就将初始值设置成4096（MB），也就是4G，最大值设置成8192（MB），也就是8G，然后点击旁边的<b>设置</b> ，这个一定要点，不然不会生效，之后再点击最下面的确定，这样就将D盘的虚拟内存大小设置好了，同样的可以来设置C盘，其他盘等等。</p><fancybox><img src="/img/20200309221104.png">&nbsp;<img src="/img/20200309221050.png">&nbsp;<img src="/img/20200309215221.png">&nbsp;</fancybox><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>按照上面的设置完了后，我们再打开我的电脑（快捷键：<kbd>WIN</kbd> + <kbd>E</kbd>），发现磁盘的颜色又恢复正常了，容量也都回来了，相比之前占用的20多G的pagefiles.sys文件，现在只是会占用4G的空间了（注意：这个虚拟内存不能比我这还设置的更小了，不然会对操作系统的性能产生很大的影响，笔者之前可是深有体会的，特别是对图片的加载速度，比如在浏览器里面要上传个本地的图片，这个过程要加载10S左右，期间还不能操作鼠标点击，不然浏览器就无响应了，当时一直找不到问题出在哪里，后来将虚拟内存改成自动托管后，这个速度真的是明显的提提升啊）</p><br><blockquote><p>参考链接：<a href="http://www.winwin7.com/JC/Win7JC-7699.html" target="_blank" rel="noopener">http://www.winwin7.com/JC/Win7JC-7699.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> 虚拟内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客必备神器</title>
      <link href="/blog/2020-03-09-write-blog-tools/"/>
      <url>/blog/2020-03-09-write-blog-tools/</url>
      
        <content type="html"><![CDATA[<p>完成了博客的搭建之后，接下来就是内容创作了。而创作的过程中，我们又会有一系列的问题，比如：</p><ul><li>我们用什么工具来写文章呢？</li><li>怎么才能快速生成格式化的<a href="https://tableconvert.com/" target="_blank" rel="noopener">Markdown</a> 表格呢？</li><li>怎么样才能画出一些高逼格的图片呢？</li><li>这些图片的存储和处理怎么办呢？文章中的代码高亮如何实现呢？</li></ul><p>要解决这些问题其实并不难，无非就是引入不同的工具来帮助我们，好的工具可以让我们的创作事半功倍！</p><a id="more"></a><h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><p>先来推荐一下我们要用的最重要的一个工具：Markdown编辑器。我们需要使用它来完成所有的创作内容，本人尝试了非常多的编辑器，最终锁定在下面这款Typora，因此推荐给大家。</p><ul><li>推荐工具：Typora</li><li>官方地址：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io/</a></li><li>推荐理由：作为一款免费编辑器，可以说是相当良心，是我目前所知道的最好用的免费编辑器了，没有之一！！！它支持多个主流的操作系统，不论你是Windows用户还是Mac用户，都能轻易的安装和使用它！除此之外，它还有不同的主题选择、导出一些常用格式（PDF、Word、HTML）等等非常有用的功能！</li></ul><h2 id="Markdown表格生成器"><a href="#Markdown表格生成器" class="headerlink" title="Markdown表格生成器"></a>Markdown表格生成器</h2><p>对于强迫症来说，写Markdown表格是一件很痛苦的事情，在语法对齐的问题上我真的是受尽了折磨，所以强烈推荐一个在线Markdown表格生成工具，它出来能快速生成格式化后的Markdown表格外，还支持导入各种数据，在线编辑，简直强大！</p><ul><li>推荐工具：Table Convert Online</li><li>官方地址：<a href="https://tableconvert.com" target="_blank" rel="noopener">https://tableconvert.com/</a></li><li>推荐理由：作为一款免费的在线工具，支持Excel、JSON、HTML、CSV甚至是从URL中提取HTML表格转为Markdown表格，多功能集一身，并融合在一个界面，使用非常方便，不需要切换界面。还可以像编辑Excel一样编辑生成各种表格，不愧为表格中的瑞士军刀！</li></ul><h2 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h2><p>对于我们这些写技术文章的博主来说，画画流程图、架构图是辅助描述文章内容的最佳途径，下面要推荐的ProcessOn就是目前我用得最多的画图工具。</p><ul><li>推荐工具：ProcessOn</li><li>官方地址：<a href="https://www.processon.com" target="_blank" rel="noopener">https://processon.com/</a></li><li>推荐理由：难得的国产在线图片编辑器，支持多人协作。同时，还有大量好看的图标支持，可以让我们的绘图更加生动！</li></ul><h2 id="图片存储"><a href="#图片存储" class="headerlink" title="图片存储"></a>图片存储</h2><p>可能有人会问，为什么要图片存储呢？我们直接存Wordpress或者Hexo的目录下不久好了吗？实际上，使用这些主要是为了经济性的考虑，随着访问量的增大，图片对于我们的虚拟主机或ECS的空间以及带宽消耗都会造成一定的压力，使用类似图床的平台就可以帮助我们减轻这些压力。</p><ul><li>推荐工具：外链工厂</li><li>官方地址：<a href="http://www.wailian.work" target="_blank" rel="noopener">http://www.wailian.work/</a></li><li>推荐理由：简单好用、足够稳定，释放自己虚拟空间或虚拟主机的存储和带宽消耗，但是记得做好备份哦！</li></ul><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>如果你跟我一样是一名程序猿，那么代码高亮是必备的。大多Hexo的主题中都包含了高亮插件，但是有些并没有，那么我们需要知道鼎鼎大名的highlight.js。对于一些已经有这个插件的主题，也可以通过官网来做一些定制，没有的直接引入来使用即可。</p><ul><li>推荐工具：highlight.js</li><li>官方地址：<a href="https://highlightjs.org" target="_blank" rel="noopener">https://highlightjs.org/</a></li><li>推荐理由：使用于所有主流编程语言，兼容性好，多种多样的预设样式，总有一款适合你！</li></ul><br><blockquote><p>原文链接：<a href="http://fech.in/2019/write-blog-tools/" target="_blank" rel="noopener">http://fech.in/2019/write-blog-tools/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo template</title>
      <link href="/blog/2020-03-05-hexo-template/"/>
      <url>/blog/2020-03-05-hexo-template/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
